'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _btoa = require('btoa');

var _btoa2 = _interopRequireDefault(_btoa);

var _webexCore = require('@webex/webex-core');

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

/**
   * Calendar Item Create Event
   * Emitted when a calendar item has been added
   * @event calendar:meeting:create
   * @instance
   * @memberof Calendar
   */

/**
   * Calendar Item Update Event
   * Emitted when a calendar item has been updated
   * @event calendar:meeting:update
   * @instance
   * @memberof Calendar
   */

/**
   * Calendar Item Update Event
   * Emitted when a calendar item has been deleted
   * @event calendar:meeting:delete
   * @instance
   * @memberof Calendar
   */

/**
 * Calendar Registered Event
 * Emitted when the calendar instance has been registered and listening
 * @event calendar:registered
 * @instance
 * @memberof Calendar
 */

/**
 * Calendar Registered Event
 * Emitted when the calendar instance has been registered and listening
 * @event calendar:unregistered
 * @instance
 * @memberof Calendar
 */

var Calendar = _webexCore.WebexPlugin.extend({
  namespace: 'Calendar',

  /**
   * registered value indicating events registration is successful
   * @instance
   * @type {Boolean}
   * @memberof Calendar
   */
  registered: false,

  /**
   * Explicitly sets up the calendar plugin by registering
   * the device, connecting to mercury, and listening for calendar events.
   * @returns {Promise}
   * @public
   * @memberof Calendar
   */
  register: function register() {
    var _this = this;

    if (!this.webex.canAuthorize) {
      this.logger.error('calendar->register#ERROR, Unable to register, SDK cannot authorize');

      return _promise2.default.reject(new Error('SDK cannot authorize'));
    }

    if (this.registered) {
      this.logger.info('calendar->register#INFO, Calendar plugin already registered');

      return _promise2.default.resolve();
    }

    return this.webex.internal.device.register().then(function () {
      return _this.webex.internal.mercury.connect();
    }).then(function () {
      _this.listenForEvents();
      _this.trigger(_constants.CALENDAR_REGISTERED);
      _this.registered = true;
    }).catch(function (error) {
      _this.logger.error('calendar->register#ERROR, Unable to register, ' + error.message);

      return _promise2.default.reject(error);
    });
  },


  /**
   * Explicitly tears down the calendar plugin by deregistering
   * the device, disconnecting from mercury, and stops listening to calendar events
   *
   * @returns {Promise}
   * @public
   * @memberof Calendar
   */
  unregister: function unregister() {
    var _this2 = this;

    if (!this.registered) {
      this.logger.info('calendar->unregister#INFO, Calendar plugin already unregistered');

      return _promise2.default.resolve();
    }

    this.stopListeningForEvents();

    return this.webex.internal.mercury.disconnect().then(function () {
      return _this2.webex.internal.device.unregister();
    }).then(function () {
      _this2.trigger(_constants.CALENDAR_UNREGISTERED);
      _this2.registered = false;
    });
  },


  /**
   * registers for calendar events through mercury
   * @returns {undefined}
   * @private
   */
  listenForEvents: function listenForEvents() {
    var _this3 = this;

    // Calendar mercury events listener
    this.webex.internal.mercury.on('event:calendar.meeting.create', function (envelope) {
      _this3._handleCreate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.update', function (envelope) {
      _this3._handleUpdate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.create.minimal', function (envelope) {
      _this3._handleCreate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.update.minimal', function (envelope) {
      _this3._handleUpdate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.delete', function (envelope) {
      _this3._handleDelete(envelope.data);
    });
  },


  /**
   * unregisteres all the calendar events from mercury
   * @returns {undefined}
   * @private
   */
  stopListeningForEvents: function stopListeningForEvents() {
    this.webex.internal.mercury.off('event:calendar.meeting.create');
    this.webex.internal.mercury.off('event:calendar.meeting.create.minimal');
    this.webex.internal.mercury.off('event:calendar.meeting.update');
    this.webex.internal.mercury.off('event:calendar.meeting.update.minimal');
    this.webex.internal.mercury.off('event:calendar.meeting.delete');
  },


  /**
   * handles update events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleUpdate: function _handleUpdate(data) {
    var id = _collection2.default.set(data.calendarMeetingExternal);

    this.trigger(_constants.CALENDAR_UPDATED, _collection2.default.get(id));
  },


  /**
   * handles create events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleCreate: function _handleCreate(data) {
    var id = _collection2.default.set(data.calendarMeetingExternal);

    this.trigger(_constants.CALENDAR_CREATE, _collection2.default.get(id));
  },


  /**
   * handles delete events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleDelete: function _handleDelete(data) {
    var item = _collection2.default.remove(data.calendarMeetingExternal.id);

    this.trigger(_constants.CALENDAR_DELETE, item);
  },


  /**
   * Retrieves a collection of calendars based on the request parameters
   * Defaults to 1 day before and 7 days ahead
   * @param {Object} options
   * @param {Date} options.fromDate the start of the time range
   * @param {Date} options.toDate the end of the time range
   * @returns {Promise} Resolves with an array of calendars
   */
  syncCalendar: function syncCalendar() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { fromDate: this.config.fromDate, toDate: this.config.toDate };

    return this.list({ fromDate: options.fromDate, toDate: options.toDate }).then(function (res) {
      _collection2.default.setAll(res);

      return _collection2.default.getAll();
    });
  },

  /**
   * get the calendar item that has a matching value
   * @param {String} key meeting property
   * @param {Any} value the meeting property to match
   * @returns {Object}
   */
  getByType: function getByType(key, value) {
    if (['spaceURI', 'spaceMeetURL', 'conversationId'].includes(key)) {
      return _collection2.default.getBy(key, value);
    }
    throw new Error('key must be one of, spaceURI, spaceMeetURL, or conversationId');
  },


  /**
   * gets all the calendar items that have been populated
   * @returns {Object}
   */
  getAll: function getAll() {
    return _collection2.default.getAll();
  },


  /**
   * Decrypts an encrypted incoming calendar event
   * @param {Object} event
   * @returns {Promise} Resolves with a decrypted calendar event
   */
  processMeetingEvent: function processMeetingEvent(event) {
    return this.webex.transform('inbound', event).then(function () {
      return event;
    });
  },


  /**
   * Retrieves an array of meeting participants for the meeting id
   * @param {String} id
   * @returns {Promise} Resolves with an object of meeting participants
   */
  getParticipants: function getParticipants(id) {
    return this.request({
      method: 'GET',
      service: 'calendar',
      resource: 'calendarEvents/' + (0, _btoa2.default)(id) + '/participants'
    });
  },


  /**
   * Retrieves a collection of meetings based on the request parameters
   * @param {String} id
   * @returns {Promise} Resolves with an object of meeting notes
   */
  getNotes: function getNotes(id) {
    return this.request({
      method: 'GET',
      service: 'calendar',
      resource: 'calendarEvents/' + (0, _btoa2.default)(id) + '/notes'
    });
  },


  /**
   * Retrieves a collection of meetings based on the request parameters
   * @param {Object} options
   * @param {Date} options.fromDate the start of the time range
   * @param {Date} options.toDate the end of the time range
   * @returns {Promise} Resolves with an array of meetings
   */
  list: function list(options) {
    var _this4 = this;

    options = options || {};

    return this.webex.request({
      method: 'GET',
      service: 'calendar',
      resource: 'calendarEvents',
      qs: options
    }).then(function (res) {
      var meetingObjects = res.body.items;
      var promises = [];

      meetingObjects.forEach(function (meeting) {
        if (!meeting.encryptedNotes) {
          promises.push(_this4.getNotes(meeting.id).then(function (notesResponse) {
            meeting.encryptedNotes = notesResponse.body && notesResponse.body.encryptedNotes;
          }));
        }

        if (!meeting.encryptedParticipants) {
          promises.push(_this4.getParticipants(meeting.id).then(function (notesResponse) {
            meeting.encryptedParticipants = notesResponse.body.encryptedParticipants;
          }));
        }
      });

      return _promise2.default.all(promises).then(function () {
        return meetingObjects;
      });
    });
  },
  version: '1.80.147'
});

exports.default = Calendar;
//# sourceMappingURL=calendar.js.map
