'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _calendar = require('./calendar');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_calendar).default;
  }
});

require('@webex/internal-plugin-device');

require('@webex/internal-plugin-encryption');

require('@webex/internal-plugin-conversation');

var _webexCore = require('@webex/webex-core');

var _calendar2 = _interopRequireDefault(_calendar);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

(0, _webexCore.registerInternalPlugin)('calendar', _calendar2.default, {
  config: _config2.default,
  payloadTransformer: {
    predicates: [{
      name: 'transformMeetingNotes',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise2.default.resolve((0, _has3.default)(response, 'body.encryptedNotes'));
      },
      extract: function extract(response) {
        return _promise2.default.resolve(response.body);
      }
    }, {
      name: 'transformMeetingParticipants',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise2.default.resolve((0, _has3.default)(response, 'body.encryptedParticipants'));
      },
      extract: function extract(response) {
        return _promise2.default.resolve(response.body);
      }
    }, {
      name: 'transformMeetingArray',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise2.default.resolve((0, _has3.default)(response, 'body.items[0].seriesId'));
      },
      extract: function extract(response) {
        return _promise2.default.resolve(response.body.items);
      }
    }, {
      name: 'transformMeeting',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise2.default.resolve((0, _has3.default)(response, 'body.seriesId'));
      },
      extract: function extract(response) {
        return _promise2.default.resolve(response.body);
      }
    }, {
      name: 'transformMeeting',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise2.default.resolve((0, _has3.default)(response, 'calendarMeetingExternal'));
      },
      extract: function extract(response) {
        return _promise2.default.resolve(response.calendarMeetingExternal);
      }
    }],
    transforms: [{
      name: 'transformMeetingArray',
      fn: function fn(ctx, array) {
        return _promise2.default.all(array.map(function (item) {
          return ctx.transform('transformMeeting', item);
        }));
      }
    }, {
      name: 'transformMeeting',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise2.default.resolve();
        }

        if (!object.encryptionKeyUrl) {
          return _promise2.default.resolve();
        }

        // Decrypt participant properties if meeting object contains participants
        var decryptedParticipants = object.encryptedParticipants ? object.encryptedParticipants.map(function (participant) {
          return _promise2.default.all([ctx.transform('decryptTextProp', 'encryptedEmailAddress', object.encryptionKeyUrl, participant), ctx.transform('decryptTextProp', 'encryptedName', object.encryptionKeyUrl, participant)]);
        }) : [];

        return _promise2.default.all([ctx.transform('decryptTextProp', 'encryptedSubject', object.encryptionKeyUrl, object), ctx.transform('decryptTextProp', 'encryptedLocation', object.encryptionKeyUrl, object), ctx.transform('decryptTextProp', 'encryptedNotes', object.encryptionKeyUrl, object), ctx.transform('decryptTextProp', 'webexURI', object.encryptionKeyUrl, object), ctx.transform('decryptTextProp', 'webexURL', object.encryptionKeyUrl, object), ctx.transform('decryptTextProp', 'spaceMeetURL', object.encryptionKeyUrl, object), ctx.transform('decryptTextProp', 'spaceURI', object.encryptionKeyUrl, object), ctx.transform('decryptTextProp', 'spaceURL', object.encryptionKeyUrl, object)].concat(decryptedParticipants));
      }
    }, {
      name: 'transformMeetingNotes',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise2.default.resolve();
        }

        if (!object.encryptionKeyUrl) {
          return _promise2.default.resolve();
        }

        return _promise2.default.all([ctx.transform('decryptTextProp', 'encryptedNotes', object.encryptionKeyUrl, object)]);
      }
    }, {
      name: 'transformMeetingParticipants',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise2.default.resolve();
        }

        if (!object.encryptionKeyUrl || !object.encryptedParticipants) {
          return _promise2.default.resolve();
        }

        // Decrypt participant properties
        var decryptedParticipants = object.encryptedParticipants.map(function (participant) {
          return _promise2.default.all([ctx.transform('decryptTextProp', 'encryptedEmailAddress', object.encryptionKeyUrl, participant), ctx.transform('decryptTextProp', 'encryptedName', object.encryptionKeyUrl, participant)]);
        });

        return _promise2.default.all(decryptedParticipants);
      }
    }]
  }
});
//# sourceMappingURL=index.js.map
