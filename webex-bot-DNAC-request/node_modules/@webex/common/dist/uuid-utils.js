'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constructHydraId = constructHydraId;
exports.deconstructHydraId = deconstructHydraId;
exports.buildHydraMessageId = buildHydraMessageId;
exports.buildHydraPersonId = buildHydraPersonId;
exports.buildHydraRoomId = buildHydraRoomId;
exports.buildHydraOrgId = buildHydraOrgId;
exports.buildHydraMembershipId = buildHydraMembershipId;
exports.getHydraRoomType = getHydraRoomType;
exports.getHydraFiles = getHydraFiles;

var _base = require('./base64');

var _constants = require('./constants');

var hydraBaseUrl = 'https://api.ciscospark.com/v1';

var isRequired = function isRequired() {
  throw Error('parameter is required');
};

/**
 * Constructs a Hydra ID for a given UUID and type.
 *
 * @export
 * @param {string} type one of PEOPLE, TEAM, ROOM
 * @param {any} id identifying the "TYPE" object
 * @param {string} cluster containing the "TYPE" object
 * @returns {string}
 */
function constructHydraId() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isRequired();
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isRequired();
  var cluster = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'us';

  if (!type.toUpperCase) {
    throw Error('"type" must be a string');
  }

  return (0, _base.encode)('ciscospark://' + cluster + '/' + type.toUpperCase() + '/' + id);
}

/**
 * @typedef {Object} DeconstructedHydraId
 * @property {UUID} id identifying the object
 * @property {String} type of the object
 * @property {String} cluster containing the object
 */

/**
 * Deconstructs a Hydra ID.
 *
 * @export
 * @param {String} id Hydra style id
 * @returns {DeconstructedHydraId} deconstructed id
 */
function deconstructHydraId(id) {
  var payload = (0, _base.decode)(id).split('/');

  return {
    id: payload.pop(),
    type: payload.pop(),
    cluster: payload.pop()
  };
}

/**
 * Constructs a Hydra ID for a message based on internal UUID
 *
 * @export
 * @param {any} uuid
 * @param {string} cluster containing the message
 * @returns {string}
 */
function buildHydraMessageId(uuid, cluster) {
  return constructHydraId(_constants.hydraTypes.MESSAGE, uuid, cluster);
}

/**
 * Constructs a Hydra ID for a person based on internal UUID
 *
 * @export
 * @param {any} uuid
 * @param {string} cluster containing the person
 * @returns {string}
 */
function buildHydraPersonId(uuid, cluster) {
  return constructHydraId(_constants.hydraTypes.PEOPLE, uuid, cluster);
}

/**
 * Constructs a Hydra ID for a room based on internal UUID
 *
 * @export
 * @param {any} uuid
 * @param {string} cluster containing the room
 * @returns {string}
 */
function buildHydraRoomId(uuid, cluster) {
  return constructHydraId(_constants.hydraTypes.ROOM, uuid, cluster);
}

/**
 * Constructs a Hydra ID for an organization based on internal UUID
 *
 * @export
 * @param {any} uuid
 * @param {string} cluster containing the organization
 * @returns {string}
 */
function buildHydraOrgId(uuid, cluster) {
  return constructHydraId(_constants.hydraTypes.ORGANIZATION, uuid, cluster);
}

/**
 * Constructs a Hydra ID for an membership based on an
 * internal UUID for the person, and the space
 *
 * @export
 * @param {any} personUUID
 * @param {any} spaceUUID
 * @param {string} cluster containing the membership
 * @returns {string}
 */
function buildHydraMembershipId(personUUID, spaceUUID, cluster) {
  return constructHydraId(_constants.hydraTypes.MEMBERSHIP, personUUID + ':' + spaceUUID, cluster);
}

/**
 * Returns a Hydra roomType based on conversation tags
 *
 * @export
 * @param {arra} tags
 * @param {any} spaceUUID
 * @returns {string}
 */
function getHydraRoomType(tags) {
  if (tags.includes(_constants.SDK_EVENT.INTERNAL.ACTIVITY_TAG.ONE_ON_ONE)) {
    return _constants.SDK_EVENT.EXTERNAL.SPACE_TYPE.DIRECT;
  }

  return _constants.SDK_EVENT.EXTERNAL.SPACE_TYPE.GROUP;
}

/**
 * Returns file URLs for the activity, adhering to Hydra details,
 * e.g., https://api.ciscospark.com/v1/contents/Y2lzY29zcGF...
 * @see https://developer.webex.com/docs/api/v1/messages/get-message-details
 * @param {Object} activity from mercury
 * @param {string} cluster containing the files
 * @returns {Array} file URLs
 */
function getHydraFiles(activity, cluster) {
  var hydraFiles = [];
  var files = activity.object.files;


  if (files) {
    var items = files.items;

    // Note: Generated ID is dependent on file order.

    for (var i = 0; i < items.length; i += 1) {
      var contentId = constructHydraId(_constants.hydraTypes.CONTENT, activity.id + '/' + i, cluster);

      hydraFiles.push(hydraBaseUrl + '/contents/' + contentId);
    }
  }

  return hydraFiles;
}
//# sourceMappingURL=uuid-utils.js.map
