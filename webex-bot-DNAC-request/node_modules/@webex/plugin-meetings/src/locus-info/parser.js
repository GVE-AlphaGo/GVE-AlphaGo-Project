import {min} from 'lodash';

import LocusUtil from '../locus-info/utils';
import {DELTAEVENT, LOCUS} from '../constants';

const Parser = {};

// https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events
Parser.updateWithDeltaLocus = (deltaLocus, meeting) => {
  if (!(deltaLocus.sequence && (deltaLocus.sequence.rangeStart <= deltaLocus.sequence.rangeEnd) && (deltaLocus.sequence.rangeEnd <= min(deltaLocus.sequence.entries)))) {
    return null;
  }

  // Its a new meeting and has incomplete information
  if (!meeting.locusInfo.baseSequence) {
    return meeting.meetingRequest.getFullLocus({
      desync: true,
      locusUrl: meeting.locusUrl
    }).then((res) => {
      if (res && res.body) {
        res.body.baseSequence = deltaLocus.baseSequence; // TODO: verify baseSequence age and update as necessary
        meeting.locusInfo.onFullLocus(res.body);
      }

      // Sending EQ if there is an error as next request will fixe it
      return DELTAEVENT.EQ;
    });
  }

  // THIS IS A NEW MEETING OBJECT
  // // If meeting has no sequence, it means just initialized and will apply whatever in locus DTO
  // if (isNewMeeting || !this.locus.sequence) {
  //   meeting._updateWithDeltaLocus(deltaLocus, emitter);
  //   meeting.locusDesync = false;
  //   meeting.needToGetFullLocus = false;
  //   return DELTAEVENT.GT;
  // }

  if (!deltaLocus.sequence) {
    // TODO: force update
  }

  // TODO: If this was the first event, the client will not have a syncURL
  // in its working copy to do a GET on. In this case clients should do a GET on locusUrl contained in the DTO

  let res;
  let resBase;

  res = LocusUtil.compareLocus(deltaLocus.sequence, meeting.locusInfo.sequence);
  // In-coming locus is greater than working copy, need to compare with base if there
  // is base sequence except the first delta locus event
  if (res === DELTAEVENT.GT && deltaLocus.baseSequence && meeting.locusInfo.syncUrl) {
    resBase = LocusUtil.compareLocus(deltaLocus.baseSequence, meeting.locusInfo.sequence);
    if (resBase === DELTAEVENT.LT || resBase === DELTAEVENT.CF) {
      res = DELTAEVENT.CF;
    }
  }
  // Special case for OBTP with meeting size equal or over 5. Locus might change this later
  // This is a temporary fix. I will find a better solution later.
  if (!deltaLocus.baseSequence && res === DELTAEVENT.EQ && deltaLocus.fullState.state === LOCUS.STATE.INITIALIZING &&
        deltaLocus.sequence.rangeStart === 0 && deltaLocus.sequence.rangeEnd === 0 &&
        deltaLocus.sequence.entries.length === 0) {
    res = DELTAEVENT.GT;
  }
  switch (res) {
    case DELTAEVENT.LT:
    case DELTAEVENT.EQ:
      meeting.locusDesync = false;
      meeting.needToGetFullLocus = false;
      break;
    case DELTAEVENT.CF:
      LocusUtil.generateSyncDebugFlag(meeting, deltaLocus);
      if (meeting.locusDesync) {
        meeting.meetingRequest.getFullLocus({
          desync: true,
          locusUrl: meeting.locusUrl
        }).then((res) => {
          meeting.locusInfo.onFullLocus(res.body);
        });
      }
      else {
        meeting.locusDesync = true;
        Parser.syncMeeting(meeting, deltaLocus);
      }
      break;
    case DELTAEVENT.GT:
      meeting.locusInfo.onDeltaLocus(deltaLocus);
      // Turn off desync in case this delta locus comes from a sync request
      meeting.locusDesync = false;
      meeting.needToGetFullLocus = false;
      break;
    default:
  }

  return res;
};


Parser.syncMeeting = (meeting, deltaLocus) => {
  if (meeting &&
        meeting.locusInfo &&
        meeting.locusInfo.syncUrl &&
        meeting.locusInfo.fullState &&
        meeting.locusInfo.fullState.state !== LOCUS.STATE.INACTIVE) {
    // found that the locus syncs were happening even after 4 hrs of meeting
    // completion, resulting in 403 errors. This check ensures we call
    // syncing only if the locus state is not INACTIVE.
    meeting.meetingRequest.syncMeeting({
      syncUrl: deltaLocus.syncUrl,
      desync: meeting.desync
    })
      .then((res) => {
        meeting.locusInfo.onDeltaLocus(res.body);
      });
  }
};

export default Parser;
