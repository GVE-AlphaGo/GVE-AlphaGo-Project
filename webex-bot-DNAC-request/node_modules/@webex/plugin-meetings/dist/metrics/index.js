'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _bowser = require('bowser');

var _bowser2 = _interopRequireDefault(_bowser);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _window = require('global/window');

var _window2 = _interopRequireDefault(_window);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

var _config = require('../common/config');

var _config2 = _interopRequireDefault(_config);

var _config3 = require('./config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @description Metrics handles all the call metrics events
 * @export
 * @class Metrics
 */
var Metrics = function () {
  /**
     * Create Metrics Object
     * @constructor
     * @public
     * @memberof Meetings
     */
  function Metrics() {
    (0, _classCallCheck3.default)(this, Metrics);

    if (!Metrics.instance) {
      /**
       * @instance
       * @type {Array}
       * @private
       * @memberof Metrics
       */
      this._events = [];
      /**
      * @instance
      * @type {MeetingCollection}
      * @private
      * @memberof Metrics
      */
      this.meetingCollection = null;
      /**
      * @instance
      * @type {MeetingCollection}
      * @private
      * @memberof Metrics
      */
      this.keys = (0, _values2.default)(_config3.eventType);
      /**
       * @instance
       * @type {Metrics}
       * @private
       * @memberof Metrics
       */
      Metrics.instance = this;
    }

    return Metrics.instance;
  }

  /**
   * setup Metrics with meeting Collection
   * @param {object} meetingCollection meetings object
   * @param {object} webexVersion webex version
   * @returns {object} null
   */


  (0, _createClass3.default)(Metrics, [{
    key: 'initialSetup',
    value: function initialSetup(meetingCollection, webexVersion) {
      this.meetingCollection = meetingCollection;
      this.webexVersion = webexVersion;
    }

    /**
     * poste Meeting event metrics
     * @param {object} options {meetingId/meeting} as a json object
     * @param {String} options.meetingId
     * @param {object} options.data
     * @param {object} options.event
     * @returns {object} null
     */

  }, {
    key: 'postEvent',
    value: function postEvent(options) {
      var meetingId = options.meetingId,
          _options$data = options.data,
          data = _options$data === undefined ? {} : _options$data,
          event = options.event;
      var meeting = options.meeting;


      if (this.keys.indexOf(event) === -1) {
        _loggerProxy2.default.logger.error('Metrics: Event ' + event + ' doesnt exist in dictionary');
      }

      if (!meeting && meetingId) {
        meeting = this.meetingCollection.get(meetingId);
      }

      if (meeting) {
        if (!meeting.callEvents) {
          meeting.callEvents = [];
        }
        if (event === _config3.eventType.MEDIA_QUALITY) {
          data.event = event;
          meeting.sendMediaQualityAnalyzerMetrics(data);
        } else {
          meeting.callEvents.push(event);
          data.event = event;
          meeting.sendCallAnalyzerMetrics(data);
        }
      } else {
        _loggerProxy2.default.logger.error('Metrics->postEvent: Meeting object not defined');
      }
    }

    /**
     *  Docs for Call analyzer metrics
    *   https://sqbu-github.cisco.com/WebExSquared/call-analyzer/wiki
    *   https://sqbu-github.cisco.com/WebExSquared/event-dictionary/blob/master/diagnostic-events.raml
    */

  }, {
    key: 'initPayload',
    value: function initPayload(eventType, identifiers, options) {
      var payload = {
        eventId: _uuid2.default.v4(),
        version: 1,
        origin: {
          buildType: 'prod',
          name: 'endpoint',
          networkType: 'unknown',
          userAgent: this.getUserAgentInfo(),
          clientInfo: {
            clientType: options.clientType,
            os: 'linux', // TODO: BUG AND DOESNT ACCEPT OSNAME ON CA -> bowser.osname || 'null'
            osVersion: _bowser2.default.osVersion || '-1'
          }
        },
        originTime: {
          triggered: new Date().toISOString()
        },
        event: {
          name: eventType,
          canProceed: true,
          identifiers: identifiers,
          eventData: { webClientDomain: _window2.default.location.hostname }
        }
      };

      // TODO: more options should be checked and some of them should be mandatory in certain conditions
      if (options) {
        if (Object.prototype.hasOwnProperty.call(options, 'canProceed')) {
          payload.event.canProceed = options.canProceed;
        }
        if (options.errors) {
          payload.event.errors = options.errors;
        }
        if (options.mediaType) {
          payload.event.mediaType = options.mediaType;
        }
        if (options.trigger) {
          payload.event.trigger = options.trigger;
        }
        if (options.pstnAudioType) {
          payload.event.pstnAudioType = options.pstnAudioType;
        }
        if (options.mediaCapabilities) {
          payload.event.mediaCapabilities = options.mediaCapabilities;
        }
        if (options.recoveredBy) {
          payload.event.recoveredBy = options.recoveredBy;
        }
      }

      return payload;
    }

    /**
     * get the payload specific for a media quality event through call analyzer
     * @param {String} eventType the event name
     * @param {Object} identifiers contains the identifiers needed for CA
     * @param {String} identifiers.correlationId
     * @param {String} identifiers.locusUrl
     * @param {String} identifiers.locusId
     * @param {Object} options
     * @param {Object} options.intervalData
     * @param {String} options.clientType
     * @returns {Object}
     * @public
     * @memberof Metrics
     */

  }, {
    key: 'initMediaPayload',
    value: function initMediaPayload(eventType, identifiers, options) {
      var payload = {
        eventId: _uuid2.default.v4(),
        version: 1,
        origin: {
          buildType: 'prod',
          name: 'endpoint',
          networkType: 'unknown',
          userAgent: this.getUserAgentInfo(),
          clientInfo: {
            clientType: options.clientType,
            os: 'linux', // TODO: BUG AND DOESNT ACCEPT OSNAME ON CA -> bowser.osname || 'null'
            osVersion: _bowser2.default.osVersion || '-1'
          }
        },
        originTime: {
          triggered: new Date().toISOString()
        },
        event: {
          name: eventType,
          canProceed: true,
          identifiers: identifiers,
          intervals: [options.intervalData],
          eventData: { webClientDomain: _window2.default.location.hostname }
        }
      };

      return payload;
    }

    /*
     * This function Parses a Locus error and returns a diagnostic event payload.
     * It should keep updating from:
     * https://sqbu-github.cisco.com/WebExSquared/spark-client-framework/blob/master/spark-client-framework/Adapters/TelephonyAdapter/TelephonyAdapter.cpp#L920
     * @param err {Object} the error Object from Locus response
     * @param {boolean} showToUser true if a toast is shown to user
     * @returns {{showToUser: boolean, category: string, errorDescription: string,
     *  errorCode: number, errorData: *, fatal: boolean, name: string}}
     */

  }, {
    key: 'parseLocusError',
    value: function parseLocusError(err, showToUser) {
      var errorCode = void 0;

      if (err && err.body && err.body.errorCode) {
        switch (_config3.errorCodes[err.body.errorCode]) {
          case _constants.MEETING_ERRORS.FREE_USER_MAX_PARTICIPANTS_EXCEEDED:
            errorCode = 3007;
            break;
          case _constants.MEETING_ERRORS.PAID_USER_MAX_PARTICIPANTS_EXCEEDED:
          case _constants.MEETING_ERRORS.SERVICE_MAX_PARTICIPANTS_EXCEEDED:
            errorCode = 3002;
            break;
          case _constants.MEETING_ERRORS.INACTIVE:
            errorCode = 4001;
            break;
          case _constants.MEETING_ERRORS.EXCEEDED_MAX_JOINED_PARTICIPANTS:
          case _constants.MEETING_ERRORS.EXCEEDED_SERVICE_MAX_PARTICIPANTS:
            errorCode = 3001;
            break;
          case _constants.MEETING_ERRORS.MEETING_IS_LOCKED:
            errorCode = 4002;
            break;
          case _constants.MEETING_ERRORS.MEETING_IS_TERMINATING:
            errorCode = 4003;
            break;
          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN_INTENT:
            errorCode = 4004;
            break;
          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN:
            errorCode = 4005;
            break;
          case _constants.MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_ROLE:
            errorCode = 4006;
            break;
          case _constants.MEETING_ERRORS.JOIN_RESTRICTED_USER:
          case _constants.MEETING_ERRORS.GET_RESTRICTED_USER:
          case _constants.MEETING_ERRORS.CREATE_MEDIA_RESTRICTED_USER:
            errorCode = 3005;
            break;
          case _constants.MEETING_ERRORS.JOIN_RESTRICTED_USER_NOT_IN_ROOM:
            errorCode = 4007;
            break;
          case _constants.MEETING_ERRORS.MEETING_NOT_FOUND:
            errorCode = 4011;
            break;
          case _constants.MEETING_ERRORS.NOT_WEBEX_SITE:
            errorCode = 4012;
            break;
          case _constants.MEETING_ERRORS.INVALID_JOIN_TIME:
            errorCode = 4013;
            break;
          case _constants.MEETING_ERRORS.PHONE_NUMBER_NOT_A_NUMBER:
            errorCode = 4016;
            break;
          case _constants.MEETING_ERRORS.PHONE_NUMBER_TOO_LONG:
            errorCode = 4017;
            break;
          case _constants.MEETING_ERRORS.INVALID_DIALABLE_KEY:
            errorCode = 4018;
            break;
          case _constants.MEETING_ERRORS.ONE_ON_ONE_TO_SELF_NOT_ALLOWED:
            errorCode = 4019;
            break;
          case _constants.MEETING_ERRORS.REMOVED_PARTICIPANT:
            errorCode = 4020;
            break;
          case _constants.MEETING_ERRORS.MEETING_LINK_NOT_FOUND:
            errorCode = 4021;
            break;
          case _constants.MEETING_ERRORS.PHONE_NUMBER_TOO_SHORT_AFTER_IDD:
            errorCode = 4022;
            break;
          case _constants.MEETING_ERRORS.INVALID_INVITEE_ADDRESS:
            errorCode = 4023;
            break;
          case _constants.MEETING_ERRORS.PMR_ACCOUNT_LOCKED:
            errorCode = 4024;
            break;
          case _constants.MEETING_ERRORS.RESOURCE_GUEST_FORBIDDEN:
            errorCode = 4025;
            break;
          case _constants.MEETING_ERRORS.PMR_ACCOUNT_SUSPENDED:
            errorCode = 4026;
            break;
          case _constants.MEETING_ERRORS.EMPTY_PHONE_NUMBER_OR_COUNTRY_CODE:
            errorCode = 4027;
            break;
          case _constants.MEETING_ERRORS.INVALID_SINCE_OR_SEQUENCE_HASH_IN_REQUEST:
            errorCode = 1006;
            break;
          case _constants.MEETING_ERRORS.CONVERSATION_NOT_FOUND:
            errorCode = 4028;
            break;
          case _constants.MEETING_ERRORS.RECORDING_CONTROL_NOT_SUPPORTED:
          case _constants.MEETING_ERRORS.RECORDING_NOT_STARTED:
          case _constants.MEETING_ERRORS.RECORDING_NOT_ENABLED:
            errorCode = 4029;
            break;
          default:
            errorCode = 4008;
        }
      } else {
        errorCode = 4008;
      }

      return this.generateErrorPayload(errorCode, showToUser, _config3.error.name.LOCUS_RESPONSE, err);
    }
  }, {
    key: 'generateErrorPayload',
    value: function generateErrorPayload(errorCode, shownToUser, name, err) {
      if (_config3.error.errors[errorCode]) {
        var errorPayload = {
          shownToUser: shownToUser || false,
          category: _config3.error.errors[errorCode][2],
          errorDescription: _config3.error.errors[errorCode][0],
          errorCode: errorCode,
          fatal: !(0, _includes3.default)(_config3.error.notFatalErrorList, errorCode),
          name: name || _config3.error.name.OTHER
        };

        if (err && err.body) {
          errorPayload.errorData = err.body;
        }

        return errorPayload;
      }

      return null;
    }
  }, {
    key: 'getUserAgentInfo',
    value: function getUserAgentInfo() {
      var userAgentOption = void 0;
      var browserInfo = void 0;
      var osInfo = void 0;
      var clientInfo = _util2.default.format('client=%s', '' + _config2.default.meetings.metrics.clientName);

      if (_bowser2.default.name && ['chrome', 'firefox', 'msie', 'msedge', 'safari'].indexOf(_bowser2.default.name.toLowerCase()) !== -1 && _bowser2.default.version) {
        browserInfo = _util2.default.format('browser=%s', _bowser2.default.name.toLowerCase() + '/' + _bowser2.default.version.split('.')[0]);
      }
      if (_bowser2.default.osname && _bowser2.default.osversion) {
        osInfo = _util2.default.format('os=%s', _bowser2.default.osname + '/' + _bowser2.default.osversion.split('.')[0]);
      }

      if (browserInfo) {
        userAgentOption = '(' + browserInfo;
      }
      if (osInfo) {
        userAgentOption = userAgentOption ? userAgentOption + '; ' + clientInfo + '; ' + osInfo : clientInfo + '; (' + osInfo;
      }
      if (userAgentOption) {
        userAgentOption += ')';

        return _util2.default.format('webex-js-sdk/%s %s', process.env.NODE_ENV + '-' + this.webexVersion, userAgentOption);
      }

      return _util2.default.format('webex-js-sdk/%s', process.env.NODE_ENV + '-' + this.webexVersion);
    }
  }]);
  return Metrics;
}();

var instance = new Metrics();

exports.default = instance;
//# sourceMappingURL=index.js.map
