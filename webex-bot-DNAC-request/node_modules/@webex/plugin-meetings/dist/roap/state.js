'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _javascriptStateMachine = require('javascript-state-machine');

var _javascriptStateMachine2 = _interopRequireDefault(_javascriptStateMachine);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shouldStep = function shouldStep(roap, meeting) {
  var messageType = roap.msg.messageType;


  if (meeting) {
    if (messageType === _constants._OFFER_ && roap.remote && meeting.shareStatus === _constants._REQUESTED_) {
      // The peer-connection is waiting for answer but got an offer Reset. Try to
      // send the offer later after you accept the answer
      return false;
    }
    // Assuming the mercury event has come first before the response for the event
    // we have to wait for the response and trigger the ROAP request later on
    if (!meeting.mediaProperties.peerConnection && messageType === _constants._ANSWER_) {
      return false;
    }
  }
  _loggerProxy2.default.logger.log('RoapStateMachine->shouldStep-> PeerConnectionState, ', meeting.mediaProperties.peerConnection.signalingState);
  _loggerProxy2.default.logger.log('RoapStateMachine->shouldStep-> success save proceeding with transition, ', roap.msg);

  return true;
};

var handleTransition = function handleTransition(value, signal, meeting) {
  switch (value) {
    case _constants.ROAP.ROAP_STATE.INIT:
      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OFFER) {
        return _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER;
      }
      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_OFFER) {
        return _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER;
      }

      return value;

    case _constants.ROAP.ROAP_STATE.WAIT_RX_OFFER:
      return value;

    case _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER:
      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_ANSWER) {
        // There is a race condition where the /call response comes after mercury event from the server
        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that
        if (meeting.mediaId) {
          return _constants.ROAP.ROAP_STATE.WAIT_TX_OK;
        }
        _loggerProxy2.default.logger.error('RoapStateMachine->handleTransition#Race Condition no mediaId, continuing.');

        return value;
      }

      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OFFER) {
        return _constants.ROAP.ROAP_STATE.GLARE;
      }

      return value;

    case _constants.ROAP.ROAP_STATE.WAIT_TX_OFFER:
      return value;

    case _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER:
      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_ANSWER) {
        return _constants.ROAP.ROAP_STATE.WAIT_RX_OK;
      }

      return value;

    case _constants.ROAP.ROAP_STATE.WAIT_TX_OK:
      if (signal === _constants.ROAP.ROAP_SIGNAL.TX_OK) {
        return _constants.ROAP.ROAP_STATE.INIT;
      }

      return value;

    case _constants.ROAP.ROAP_STATE.WAIT_RX_OK:
      if (signal === _constants.ROAP.ROAP_SIGNAL.RX_OK) {
        return _constants.ROAP.ROAP_STATE.INIT;
      }

      return value;

    case _constants.ROAP.ROAP_STATE.ERROR:
      // eslint-disable-next-line no-warning-comments
      // TODO: resolve error state. Add a signal constant and handle the cleanup
      return _constants.ROAP.ROAP_STATE.INIT;

    case _constants.ROAP.ROAP_STATE.GLARE:
      return _constants.ROAP.ROAP_STATE.WAIT_RX_ANSWER;
    default:
      return value;
  }
};

var RoapStateMachine = {
  /**
   * @param {Roap} roapRef
   * initializes the state machine
   * @returns {StateMachine} an instance of a state machine
   */
  createState: function createState() {
    var RoapState = _javascriptStateMachine2.default.factory({
      init: _constants.ROAP.ROAP_STATE.INIT,
      transitions: [{
        name: _constants.ROAP.ROAP_TRANSITIONS.STEP,
        from: '*',
        /**
         * Method to handle the transitions between states
         * @param {String} signal
         * @param {Meeting} meeting instance of a Meeting
         * @param {Object} roap
         * @returns {String} new state value
         */
        to: function to(signal, meeting, roap) {
          var value = this.state;

          if (!shouldStep(roap, meeting)) {
            return value;
          }

          return handleTransition(value, signal, meeting);
        }
      }],
      methods: {
        /**
         * Event that fires after we've transitioned to a new state
         * @param {Object} transition
         * @returns {null}
         */
        onAfterStep: function onAfterStep(transition) {
          _loggerProxy2.default.logger.log('RoapStateMachine->onAfterStep#fired! State changed from \'' + transition.from + '\' to \'' + transition.to + '\' with transition \'' + transition.transition + '\'\'.');
        }
      }
    });

    return new RoapState();
  }
};

exports.default = RoapStateMachine;
//# sourceMappingURL=state.js.map
