{"version":3,"sources":["state.js"],"names":["shouldStep","roap","meeting","messageType","msg","_OFFER_","remote","shareStatus","_REQUESTED_","mediaProperties","peerConnection","_ANSWER_","LoggerProxy","logger","log","signalingState","handleTransition","value","signal","ROAP","ROAP_STATE","INIT","ROAP_SIGNAL","RX_OFFER","WAIT_TX_ANSWER","TX_OFFER","WAIT_RX_ANSWER","WAIT_RX_OFFER","RX_ANSWER","mediaId","WAIT_TX_OK","error","GLARE","WAIT_TX_OFFER","TX_ANSWER","WAIT_RX_OK","TX_OK","RX_OK","ERROR","RoapStateMachine","createState","RoapState","StateMachine","factory","init","transitions","name","ROAP_TRANSITIONS","STEP","from","to","state","methods","onAfterStep","transition"],"mappings":";;;;;;AAAA;;;;AAEA;;;;AACA;;;;AAEA,IAAMA,aAAa,SAAbA,UAAa,CAACC,IAAD,EAAOC,OAAP,EAAmB;AAAA,MAC7BC,WAD6B,GACdF,KAAKG,GADS,CAC7BD,WAD6B;;;AAGpC,MAAID,OAAJ,EAAa;AACX,QAAIC,gBAAgBE,kBAAhB,IAA2BJ,KAAKK,MAAhC,IAA0CJ,QAAQK,WAAR,KAAwBC,sBAAtE,EAAmF;AACjF;AACA;AACA,aAAO,KAAP;AACD;AACD;AACA;AACA,QAAI,CAACN,QAAQO,eAAR,CAAwBC,cAAzB,IAA2CP,gBAAgBQ,mBAA/D,EAAyE;AACvE,aAAO,KAAP;AACD;AACF;AACDC,wBAAYC,MAAZ,CAAmBC,GAAnB,CAAuB,sDAAvB,EAA+EZ,QAAQO,eAAR,CAAwBC,cAAxB,CAAuCK,cAAtH;AACAH,wBAAYC,MAAZ,CAAmBC,GAAnB,CAAuB,0EAAvB,EAAmGb,KAAKG,GAAxG;;AAEA,SAAO,IAAP;AACD,CAnBD;;AAqBA,IAAMY,mBAAmB,SAAnBA,gBAAmB,CAACC,KAAD,EAAQC,MAAR,EAAgBhB,OAAhB,EAA4B;AACnD,UAAQe,KAAR;AACE,SAAKE,gBAAKC,UAAL,CAAgBC,IAArB;AACE,UAAIH,WAAWC,gBAAKG,WAAL,CAAiBC,QAAhC,EAA0C;AACxC,eAAOJ,gBAAKC,UAAL,CAAgBI,cAAvB;AACD;AACD,UAAIN,WAAWC,gBAAKG,WAAL,CAAiBG,QAAhC,EAA0C;AACxC,eAAON,gBAAKC,UAAL,CAAgBM,cAAvB;AACD;;AAED,aAAOT,KAAP;;AAEF,SAAKE,gBAAKC,UAAL,CAAgBO,aAArB;AACE,aAAOV,KAAP;;AAEF,SAAKE,gBAAKC,UAAL,CAAgBM,cAArB;AACE,UAAIR,WAAWC,gBAAKG,WAAL,CAAiBM,SAAhC,EAA2C;AACzC;AACA;AACA,YAAI1B,QAAQ2B,OAAZ,EAAqB;AACnB,iBAAOV,gBAAKC,UAAL,CAAgBU,UAAvB;AACD;AACDlB,8BAAYC,MAAZ,CAAmBkB,KAAnB,CAAyB,2EAAzB;;AAEA,eAAOd,KAAP;AACD;;AAED,UAAIC,WAAWC,gBAAKG,WAAL,CAAiBC,QAAhC,EAA0C;AACxC,eAAOJ,gBAAKC,UAAL,CAAgBY,KAAvB;AACD;;AAED,aAAOf,KAAP;;AAEF,SAAKE,gBAAKC,UAAL,CAAgBa,aAArB;AACE,aAAOhB,KAAP;;AAEF,SAAKE,gBAAKC,UAAL,CAAgBI,cAArB;AACE,UAAIN,WAAWC,gBAAKG,WAAL,CAAiBY,SAAhC,EAA2C;AACzC,eAAOf,gBAAKC,UAAL,CAAgBe,UAAvB;AACD;;AAED,aAAOlB,KAAP;;AAEF,SAAKE,gBAAKC,UAAL,CAAgBU,UAArB;AACE,UAAIZ,WAAWC,gBAAKG,WAAL,CAAiBc,KAAhC,EAAuC;AACrC,eAAOjB,gBAAKC,UAAL,CAAgBC,IAAvB;AACD;;AAED,aAAOJ,KAAP;;AAEF,SAAKE,gBAAKC,UAAL,CAAgBe,UAArB;AACE,UAAIjB,WAAWC,gBAAKG,WAAL,CAAiBe,KAAhC,EAAuC;AACrC,eAAOlB,gBAAKC,UAAL,CAAgBC,IAAvB;AACD;;AAED,aAAOJ,KAAP;;AAEF,SAAKE,gBAAKC,UAAL,CAAgBkB,KAArB;AACE;AACA;AACA,aAAOnB,gBAAKC,UAAL,CAAgBC,IAAvB;;AAEF,SAAKF,gBAAKC,UAAL,CAAgBY,KAArB;AACE,aAAOb,gBAAKC,UAAL,CAAgBM,cAAvB;AACF;AACE,aAAOT,KAAP;AAhEJ;AAkED,CAnED;;AAqEA,IAAMsB,mBAAmB;AACvB;;;;;AAKAC,aANuB,yBAMT;AACZ,QAAMC,YAAYC,iCAAaC,OAAb,CAAqB;AACrCC,YAAMzB,gBAAKC,UAAL,CAAgBC,IADe;AAErCwB,mBAAa,CACX;AACEC,cAAM3B,gBAAK4B,gBAAL,CAAsBC,IAD9B;AAEEC,cAAM,GAFR;AAGE;;;;;;;AAOAC,UAVF,cAUKhC,MAVL,EAUahB,OAVb,EAUsBD,IAVtB,EAU4B;AACxB,cAAMgB,QAAQ,KAAKkC,KAAnB;;AAEA,cAAI,CAACnD,WAAWC,IAAX,EAAiBC,OAAjB,CAAL,EAAgC;AAC9B,mBAAOe,KAAP;AACD;;AAED,iBAAOD,iBAAiBC,KAAjB,EAAwBC,MAAxB,EAAgChB,OAAhC,CAAP;AACD;AAlBH,OADW,CAFwB;AAwBrCkD,eAAS;AACP;;;;;AAKAC,mBANO,uBAMKC,UANL,EAMiB;AACtB1C,gCAAYC,MAAZ,CAAmBC,GAAnB,gEAC8DwC,WAAWL,IADzE,gBAEIK,WAAWJ,EAFf,6BAGwBI,WAAWA,UAHnC;AAKD;AAZM;AAxB4B,KAArB,CAAlB;;AAwCA,WAAO,IAAIb,SAAJ,EAAP;AACD;AAhDsB,CAAzB;;kBAmDeF,gB","file":"state.js","sourcesContent":["import StateMachine from 'javascript-state-machine';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {ROAP, _OFFER_, _ANSWER_, _REQUESTED_} from '../constants';\n\nconst shouldStep = (roap, meeting) => {\n  const {messageType} = roap.msg;\n\n  if (meeting) {\n    if (messageType === _OFFER_ && roap.remote && meeting.shareStatus === _REQUESTED_) {\n      // The peer-connection is waiting for answer but got an offer Reset. Try to\n      // send the offer later after you accept the answer\n      return false;\n    }\n    // Assuming the mercury event has come first before the response for the event\n    // we have to wait for the response and trigger the ROAP request later on\n    if (!meeting.mediaProperties.peerConnection && messageType === _ANSWER_) {\n      return false;\n    }\n  }\n  LoggerProxy.logger.log('RoapStateMachine->shouldStep-> PeerConnectionState, ', meeting.mediaProperties.peerConnection.signalingState);\n  LoggerProxy.logger.log('RoapStateMachine->shouldStep-> success save proceeding with transition, ', roap.msg);\n\n  return true;\n};\n\nconst handleTransition = (value, signal, meeting) => {\n  switch (value) {\n    case ROAP.ROAP_STATE.INIT:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_TX_ANSWER;\n      }\n      if (signal === ROAP.ROAP_SIGNAL.TX_OFFER) {\n        return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.RX_ANSWER) {\n        // There is a race condition where the /call response comes after mercury event from the server\n        // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that\n        if (meeting.mediaId) {\n          return ROAP.ROAP_STATE.WAIT_TX_OK;\n        }\n        LoggerProxy.logger.error('RoapStateMachine->handleTransition#Race Condition no mediaId, continuing.');\n\n        return value;\n      }\n\n      if (signal === ROAP.ROAP_SIGNAL.RX_OFFER) {\n        return ROAP.ROAP_STATE.GLARE;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OFFER:\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_ANSWER:\n      if (signal === ROAP.ROAP_SIGNAL.TX_ANSWER) {\n        return ROAP.ROAP_STATE.WAIT_RX_OK;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_TX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.TX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.WAIT_RX_OK:\n      if (signal === ROAP.ROAP_SIGNAL.RX_OK) {\n        return ROAP.ROAP_STATE.INIT;\n      }\n\n      return value;\n\n    case ROAP.ROAP_STATE.ERROR:\n      // eslint-disable-next-line no-warning-comments\n      // TODO: resolve error state. Add a signal constant and handle the cleanup\n      return ROAP.ROAP_STATE.INIT;\n\n    case ROAP.ROAP_STATE.GLARE:\n      return ROAP.ROAP_STATE.WAIT_RX_ANSWER;\n    default:\n      return value;\n  }\n};\n\nconst RoapStateMachine = {\n  /**\n   * @param {Roap} roapRef\n   * initializes the state machine\n   * @returns {StateMachine} an instance of a state machine\n   */\n  createState() {\n    const RoapState = StateMachine.factory({\n      init: ROAP.ROAP_STATE.INIT,\n      transitions: [\n        {\n          name: ROAP.ROAP_TRANSITIONS.STEP,\n          from: '*',\n          /**\n           * Method to handle the transitions between states\n           * @param {String} signal\n           * @param {Meeting} meeting instance of a Meeting\n           * @param {Object} roap\n           * @returns {String} new state value\n           */\n          to(signal, meeting, roap) {\n            const value = this.state;\n\n            if (!shouldStep(roap, meeting)) {\n              return value;\n            }\n\n            return handleTransition(value, signal, meeting);\n          }\n        }\n      ],\n      methods: {\n        /**\n         * Event that fires after we've transitioned to a new state\n         * @param {Object} transition\n         * @returns {null}\n         */\n        onAfterStep(transition) {\n          LoggerProxy.logger.log(\n            `RoapStateMachine->onAfterStep#fired! State changed from '${transition.from}' to '${\n              transition.to\n            }' with transition '${transition.transition}''.`\n          );\n        }\n      }\n    });\n\n    return new RoapState();\n  }\n};\n\nexport default RoapStateMachine;\n"]}