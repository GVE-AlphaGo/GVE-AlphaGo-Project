'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _webexCore = require('@webex/webex-core');

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

var _util = require('../roap/util');

var _util2 = _interopRequireDefault(_util);

var _collection = require('../roap/collection');

var _collection2 = _interopRequireDefault(_collection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var checkForAndHandleErrors = function checkForAndHandleErrors(action, meeting, correlationId) {
  if (action && action.type) {
    if (action.msg && action.msg.messageType && action.msg.errorType) {
      if (_util2.default.findError(action.msg.messageType, action.msg.errorType, action.type)) {
        _util2.default.handleError(meeting.mediaProperties.peerConnection).then(function (res) {
          if (res) {
            _collection2.default.deleteSessionSequence(correlationId, action.msg.seq);
          }
        }).catch(function (err) {
          _loggerProxy2.default.logger.warn('RoapHandler->checkForAndHandleErrors#Cannot reset the peer connection with error: ' + err);
        });

        return true;
      }
    }
    if (!_util2.default.ensureMeeting(meeting, action.type)) {
      return true;
    }
  }

  return false;
}; /* no-param-reassign */


var handleSessionStep = function handleSessionStep(roap, session) {
  var _roap$msg = roap.msg,
      sequenceId = _roap$msg.seq,
      messageType = _roap$msg.messageType;


  if (session.OFFER && messageType === _constants._OFFER_) {
    session.GLARE_OFFER = roap.msg;
    session.GLARE_OFFER.remote = !!roap.remote;
    _loggerProxy2.default.logger.warn('RoapHandler->handleSessionStep#Glare condition occurred with new mercury event, sequenceId: ' + sequenceId);
  } else {
    _loggerProxy2.default.logger.info('RoapHandler->handleSessionStep#Save OFFER/ANSWER seq:' + sequenceId + ' new mercury event ' + messageType + 'local state: ' + (0, _stringify2.default)(session.state.state, null, 2));
    session[messageType] = roap.msg;
    session[messageType].remote = !!roap.remote;
  }
};

/**
 * @class RoapHandler
 */

var RoapHandler = function (_StatelessWebexPlugin) {
  (0, _inherits3.default)(RoapHandler, _StatelessWebexPlugin);

  function RoapHandler(attrs, options, roapOk, roapAnswer) {
    (0, _classCallCheck3.default)(this, RoapHandler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (RoapHandler.__proto__ || (0, _getPrototypeOf2.default)(RoapHandler)).call(this, {}, options));

    _this.attrs = attrs;
    _this.options = options;
    _this.roapOk = roapOk;
    _this.roapAnswer = roapAnswer;
    return _this;
  }

  /**
   *
   * @param {Object} session
   * @param {Meeting} meeting
   * @param {Object} action
   * @returns {null}
   */


  (0, _createClass3.default)(RoapHandler, [{
    key: 'perform',
    value: function perform(session, meeting, action) {
      var _this2 = this;

      switch (session.state.state) {
        // case ROAP.ROAP_STATE.INIT:
        // case ROAP.ROAP_STATE.WAIT_RX_OFFER:
        // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
        // case ROAP.ROAP_STATE.WAIT_RX_OK:
        case _constants.ROAP.ROAP_STATE.WAIT_TX_ANSWER:
          // eslint-disable-next-line no-warning-comments
          // TODO: sometime the you get an answer while you are creating an offer so SKIP
          // Server will send the mercury event comes back
          if (_util2.default.shouldHandleMedia(meeting)) {
            _util2.default.updatePeerConnection(meeting, session).then(function (answerSdps) {
              _this2.roapAnswer({
                locusId: meeting.locusId,
                locusSelfId: meeting.locusInfo.self.id,
                mediaId: meeting.mediaId,
                sdps: answerSdps,
                seq: session.OFFER.seq,
                correlationId: meeting.correlationId,
                audioMuted: meeting.isAudioMuted(),
                videoMuted: meeting.isVideoMuted()
              });
            }).catch(function (err) {
              _loggerProxy2.default.logger.error('RoapHandler->perform#Error occured during wait receive answer, continuing, ' + err);
            });
          }
          break;
        case _constants.ROAP.ROAP_STATE.WAIT_TX_OK:
          if (!_util2.default.shouldHandleMedia(meeting)) {
            _util2.default.setRemoteDescription(meeting, session).then(function (res) {
              _this2.roapOk(res);
            });
          }
          break;
        // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:
        case _constants.ROAP.ROAP_STATE.ERROR:
          _loggerProxy2.default.logger.error('RoapHandler->perform#Roap State ERROR for session: ' + session);
          break;
        case _constants.ROAP.ROAP_STATE.GLARE:
          session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
          session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
          _loggerProxy2.default.logger.warn('RoapHandler->perform#Roap State resolved the GLARE condition.');
          if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
            // 2
            _loggerProxy2.default.logger.log('RoapHandler->perform#Roap State local offer won after GLARE.');
          } else {
            _loggerProxy2.default.logger.log('RoapHandler->perform#Roap State remote offer won after GLARE.');
          }
          session.state.step(_constants.ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, action);
          this.perform(session, meeting);
          break;
        default:
          break;
      }
    }

    /**
     *
     * @param {String} signal
     * @param {Object} session
     * @param {Object} action
     * @param {Meeting} meeting
     * @param {String} prefix
     * @returns {null}
     */

  }, {
    key: 'execute',
    value: function execute(signal, session, action, meeting, prefix) {
      if (session && session.state) {
        handleSessionStep(action, session);
        signal = _constants.ROAP.ROAP_SIGNAL['' + prefix + action.msg.messageType];
        session.state.step(signal, meeting, action);
        this.perform(session, meeting, action);
      }
    }

    /**
     *
     * @param {Object} session
     * @param {Object} action
     * @param {Meeting} meeting
     * @param {String} correlationId
     * @returns {Boolean}
     */

  }, {
    key: 'handleAction',
    value: function handleAction(session, action, meeting, correlationId) {
      var signal = void 0;

      switch (action.type) {
        case _constants.ROAP.RECEIVE_ROAP_MSG:
          action.remote = true;
          this.execute(signal, session, action, meeting, _constants.ROAP.RX_);
          break;
        case _constants.ROAP.SEND_ROAP_MSG:
          action.local = true;
          this.execute(signal, session, action, meeting, _constants.ROAP.TX_);
          break;
        case _constants.ROAP.SEND_ROAP_MSG_SUCCESS:
          // This means we got and answer and waiting for 200 ok for /participants
          if (_collection2.default.getSessionSequence(correlationId, action.seq).ANSWER) {
            signal = _constants.ROAP.ROAP_SIGNAL.RX_ANSWER;
            // NOTE: When server send back an answer via mercury the
            // remote SDP is already saved sent and ok message is sent back
            // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
            // RoapHandler.transition(signal, session, meeting);
          }
          break;
        case _constants.ROAP.RECEIVE_CALL_LEAVE:
          _collection2.default.deleteSession(correlationId);
          _loggerProxy2.default.logger.log('RoapHandler->handleAction#RECEIVE_CALL_LEAVE event captured, cleaning up the RoapHandler for correlationId: ' + correlationId);break;
        case _constants.ROAP.RESET_ROAP_STATE:
          _collection2.default.deleteSessionSequence(correlationId, action.msg.seq);
          _loggerProxy2.default.logger.log('RoapHandler->handleAction#RESET_ROAP_STATE event captured, resetting the RoapHandler state based on sequenceId: ' + action.msg.seq);break;
        default:
          return true;
      }

      return true;
    }

    /**
     *
     * @param {Object} action
     * @returns {Boolean}
     */

  }, {
    key: 'submit',
    value: function submit(action) {
      var correlationId = action.correlationId;
      var seq = action.seq;


      if (!seq && action.msg) {
        seq = action.msg.seq;
      }
      var session = _collection2.default.getSessionSequence(correlationId, seq);
      var meeting = this.webex.meetings.meetingCollection.get(correlationId);

      if (checkForAndHandleErrors(action, meeting, correlationId)) {
        return true;
      }

      return this.handleAction(session, action, meeting, correlationId);
    }
  }]);
  return RoapHandler;
}(_webexCore.StatelessWebexPlugin);

exports.default = RoapHandler;
//# sourceMappingURL=handler.js.map
