{"version":3,"sources":["events.js"],"names":["operateEvent","operate","type","keys","stat","kind","foundMatch","found","some","key","match","data","StatsEvents","series","callback","namespace","MEETINGS","first","sendRemainStopped","recvRemainStopped","getData","operator","EVENT_TYPES","LOCAL","DEFAULT_EVENT_AUDIO_SEND_KEYS","EVENT_STATS_MAP","BYTES_SENT","AUDIO","DEFAULT_EVENT_VIDEO_SEND_KEYS","VIDEO","REMOTE","DEFAULT_EVENT_VIDEO_RECEIVE_KEYS","BYTES_RECEIVED","DEFAULT_EVENT_AUDIO_RECEIVE_KEYS","somethingMatched","find","element","get","length","fiveSecondsData","getSlice","prop","rtpOutAudio","rtpInAudio","rtpInVideo","rtpOutVideo","sendAnalysis","StatsAnalyzer","analyze","analysisKeys","check","ANALYSIS_CHECKS","INCREASING","receiveAnalysis","valid","bytesSent","reports","ret","stop","bytesReceived","start"],"mappings":"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","file":"events.js","sourcesContent":["import StatsAnalyzer from '../analyzer/analyzer';\nimport {\n  DEFAULT_EVENT_VIDEO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_SEND_KEYS,\n  DEFAULT_EVENT_AUDIO_RECEIVE_KEYS,\n  DEFAULT_EVENT_VIDEO_RECEIVE_KEYS,\n  EVENT_TYPES,\n  EVENT_STATS_MAP,\n  MEETINGS,\n  AUDIO,\n  VIDEO,\n  ANALYSIS_CHECKS\n} from '../constants';\n\n/**\n * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against\n * @param {String} type - local or remote\n * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX\n * @param {String} stat - the accessor to get the actual stat\n * @param {String} kind - audio or video\n * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never\n * @private\n * @memberof StatsEvents\n */\nconst operateEvent = (operate, type, keys, stat, kind) => {\n  const foundMatch = {};\n\n  foundMatch.found = keys.some((key) => {\n    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {\n      foundMatch.match = {\n        type,\n        key,\n        data: operate[key],\n        stat,\n        kind\n      };\n\n      return true;\n    }\n\n    return false;\n  });\n\n  return foundMatch;\n};\n\n/**\n * @export\n * @class StatsEvents\n */\nexport default class StatsEvents {\n  namespace = MEETINGS;\n\n  /**\n   * constructs an instance\n   * @constructor\n   * @param {StatsHistory} series\n   * @param {Function} callback\n   * @memberof StatsEvents\n   */\n  constructor(series = null, callback = () => {}) {\n    /**\n     * @instance\n     * @type {StatsHistory}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.series = series;\n    /**\n     * @instance\n     * @type {Function}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.callback = callback;\n    /**\n     * @instance\n     * @type {WebRTCData}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.first = null;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.sendRemainStopped = false;\n    /**\n     * @instance\n     * @type {Boolean}\n     * @private\n     * @memberof StatsEvents\n     */\n    this.recvRemainStopped = false;\n  }\n\n  /**\n   * looks for data starting to flow through\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  start(data) {\n    if (data && data.data && data.data.getData()) {\n      const operate = data.data.getData();\n\n      if (operate && !this.first) {\n        const operator = [\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_AUDIO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, AUDIO),\n          operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_VIDEO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO),\n          operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, AUDIO)\n        ];\n        const somethingMatched = operator.find((element) => element && element.found && element.match);\n\n        if (somethingMatched) {\n          this.first = somethingMatched.match;\n          this.callback(this.first);\n\n          return somethingMatched;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Looks for data to stop coming through\n   * @returns {Object}\n   */\n  stop() {\n    if (!this.series || this.series.get().length < 5) {\n      return null;\n    }\n    const fiveSecondsData = this.series.getSlice(5);\n    const prop = fiveSecondsData[0] && fiveSecondsData[0].rtpOutAudio || fiveSecondsData[0].rtpInAudio || fiveSecondsData[0].rtpInVideo || fiveSecondsData[0].rtpOutVideo;\n    const sendAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_SENT, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n    const receiveAnalysis = StatsAnalyzer.analyze(fiveSecondsData, {analysisKeys: [{key: EVENT_STATS_MAP.BYTES_RECEIVED, check: ANALYSIS_CHECKS.INCREASING, prop}]});\n\n    if (!sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      if (!this.sendRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_SENT};\n\n        this.callback(ret);\n        this.sendRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {\n      this.sendRemainStopped = false;\n    }\n    if (!receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      if (!this.recvRemainStopped) {\n        const ret = {stop: true, stat: EVENT_STATS_MAP.BYTES_RECEIVED};\n\n        this.callback(ret);\n        this.recvRemainStopped = true;\n        this.first = null;\n\n        return ret;\n      }\n    }\n    else if (receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {\n      this.recvRemainStopped = false;\n    }\n\n    return null;\n  }\n\n  /**\n   * handles all the types of events that need to be sent when they happen from getStats API\n   * @param {WebRTCData} data\n   * @returns {Object}\n   */\n  event(data) {\n    return {\n      start: this.start(data),\n      stop: this.stop()\n    };\n  }\n}\n"]}