'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _analyzer = require('../analyzer/analyzer');

var _analyzer2 = _interopRequireDefault(_analyzer);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against
 * @param {String} type - local or remote
 * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX
 * @param {String} stat - the accessor to get the actual stat
 * @param {String} kind - audio or video
 * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never
 * @private
 * @memberof StatsEvents
 */
var operateEvent = function operateEvent(operate, type, keys, stat, kind) {
  var foundMatch = {};

  foundMatch.found = keys.some(function (key) {
    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {
      foundMatch.match = {
        type: type,
        key: key,
        data: operate[key],
        stat: stat,
        kind: kind
      };

      return true;
    }

    return false;
  });

  return foundMatch;
};

/**
 * @export
 * @class StatsEvents
 */

var StatsEvents = function () {

  /**
   * constructs an instance
   * @constructor
   * @param {StatsHistory} series
   * @param {Function} callback
   * @memberof StatsEvents
   */
  function StatsEvents() {
    var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    (0, _classCallCheck3.default)(this, StatsEvents);
    this.namespace = _constants.MEETINGS;

    /**
     * @instance
     * @type {StatsHistory}
     * @private
     * @memberof StatsEvents
     */
    this.series = series;
    /**
     * @instance
     * @type {Function}
     * @private
     * @memberof StatsEvents
     */
    this.callback = callback;
    /**
     * @instance
     * @type {WebRTCData}
     * @private
     * @memberof StatsEvents
     */
    this.first = null;
    /**
     * @instance
     * @type {Boolean}
     * @private
     * @memberof StatsEvents
     */
    this.sendRemainStopped = false;
    /**
     * @instance
     * @type {Boolean}
     * @private
     * @memberof StatsEvents
     */
    this.recvRemainStopped = false;
  }

  /**
   * looks for data starting to flow through
   * @param {WebRTCData} data
   * @returns {Object}
   */


  (0, _createClass3.default)(StatsEvents, [{
    key: 'start',
    value: function start(data) {
      if (data && data.data && data.data.getData()) {
        var operate = data.data.getData();

        if (operate && !this.first) {
          var operator = [operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_AUDIO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.AUDIO), operateEvent(operate, _constants.EVENT_TYPES.LOCAL, _constants.DEFAULT_EVENT_VIDEO_SEND_KEYS, _constants.EVENT_STATS_MAP.BYTES_SENT, _constants.VIDEO), operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.VIDEO), operateEvent(operate, _constants.EVENT_TYPES.REMOTE, _constants.DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, _constants.EVENT_STATS_MAP.BYTES_RECEIVED, _constants.AUDIO)];
          var somethingMatched = operator.find(function (element) {
            return element && element.found && element.match;
          });

          if (somethingMatched) {
            this.first = somethingMatched.match;
            this.callback(this.first);

            return somethingMatched;
          }
        }
      }

      return null;
    }

    /**
     * Looks for data to stop coming through
     * @returns {Object}
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (!this.series || this.series.get().length < 5) {
        return null;
      }
      var fiveSecondsData = this.series.getSlice(5);
      var prop = fiveSecondsData[0] && fiveSecondsData[0].rtpOutAudio || fiveSecondsData[0].rtpInAudio || fiveSecondsData[0].rtpInVideo || fiveSecondsData[0].rtpOutVideo;
      var sendAnalysis = _analyzer2.default.analyze(fiveSecondsData, { analysisKeys: [{ key: _constants.EVENT_STATS_MAP.BYTES_SENT, check: _constants.ANALYSIS_CHECKS.INCREASING, prop: prop }] });
      var receiveAnalysis = _analyzer2.default.analyze(fiveSecondsData, { analysisKeys: [{ key: _constants.EVENT_STATS_MAP.BYTES_RECEIVED, check: _constants.ANALYSIS_CHECKS.INCREASING, prop: prop }] });

      if (!sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {
        if (!this.sendRemainStopped) {
          var ret = { stop: true, stat: _constants.EVENT_STATS_MAP.BYTES_SENT };

          this.callback(ret);
          this.sendRemainStopped = true;
          this.first = null;

          return ret;
        }
      } else if (sendAnalysis.valid && sendAnalysis.data.bytesSent.reports.length > 0) {
        this.sendRemainStopped = false;
      }
      if (!receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {
        if (!this.recvRemainStopped) {
          var _ret = { stop: true, stat: _constants.EVENT_STATS_MAP.BYTES_RECEIVED };

          this.callback(_ret);
          this.recvRemainStopped = true;
          this.first = null;

          return _ret;
        }
      } else if (receiveAnalysis.valid && receiveAnalysis.data.bytesReceived.reports.length > 0) {
        this.recvRemainStopped = false;
      }

      return null;
    }

    /**
     * handles all the types of events that need to be sent when they happen from getStats API
     * @param {WebRTCData} data
     * @returns {Object}
     */

  }, {
    key: 'event',
    value: function event(data) {
      return {
        start: this.start(data),
        stop: this.stop()
      };
    }
  }]);
  return StatsEvents;
}();

exports.default = StatsEvents;
//# sourceMappingURL=events.js.map
