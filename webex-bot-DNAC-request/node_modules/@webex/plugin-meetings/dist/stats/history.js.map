{"version":3,"sources":["history.js"],"names":["StatsHistory","max","history","index","length","getAt","previous","getMostRecent","current","exclusiveEnd","slice","data","removed","pop","unshift"],"mappings":";;;;;;;;;;;;;;;;;AAAA;;;AAGA;;;;IAIqBA,Y;AACnB;;;;AAIA,wBAAYC,GAAZ,EAAiB;AAAA;;AACf;;;;;;AAMA,SAAKC,OAAL,GAAe,EAAf;AACA;;;;;;AAMA,SAAKD,GAAL,GAAWA,GAAX;AACD;;AAED;;;;;;;;;0BAKM;AACJ,aAAO,KAAKC,OAAZ;AACD;;AAED;;;;;;;;;4BAMQ;AACN,WAAKA,OAAL,GAAe,EAAf;AACD;;AAED;;;;;;;;;;0BAOMC,K,EAAO;AACX,aAAO,KAAKD,OAAL,CAAaC,KAAb,CAAP;AACD;;AAED;;;;;;;;;oCAMgB;AACd,aAAO,KAAKD,OAAL,CAAaE,MAAb,GAAsB,CAAtB,GAA0B,KAAKC,KAAL,CAAW,CAAX,CAA1B,GAA0C,IAAjD;AACD;;AAED;;;;;;;oCAIgB;AACd,aAAO;AACLC,kBAAU,KAAKC,aAAL,EADL;AAELC,iBAAS,KAAKN,OAAL,CAAaE,MAAb,GAAsB,CAAtB,GAA0B,KAAKC,KAAL,CAAW,CAAX,CAA1B,GAA0C;AAF9C,OAAP;AAID;;AAED;;;;;;;;6BAKSI,Y,EAAc;AACrB,aAAO,KAAKP,OAAL,CAAaQ,KAAb,CAAmB,CAAnB,EAAsBD,YAAtB,CAAP;AACD;;AAED;;;;;;;;;;wBAOIE,I,EAAM;AACR,UAAIC,UAAU,IAAd;;AAEA,UAAI,KAAKV,OAAL,CAAaE,MAAb,IAAuB,KAAKH,GAAhC,EAAqC;AACnCW,kBAAU,KAAKV,OAAL,CAAaW,GAAb,EAAV;AACD;AACD,WAAKX,OAAL,CAAaY,OAAb,CAAqBH,IAArB;;AAEA,aAAOC,OAAP;AACD;;;;;kBAlGkBZ,Y","file":"history.js","sourcesContent":["/**\n * stores the last x filtered stream datas\n */\n/**\n * @export\n * @class StatsHistory\n */\nexport default class StatsHistory {\n  /**\n   * instantiate our wrapped history array\n   * @param {Number} max\n   */\n  constructor(max) {\n    /**\n     * @instance\n     * @type {Array}\n     * @public\n     * @memberof StatsHistory\n     */\n    this.history = [];\n    /**\n     * @instance\n     * @type {Number}\n     * @public\n     * @memberof StatsHistory\n     */\n    this.max = max;\n  }\n\n  /**\n   * @returns {Array} the array of stats reports, read from [0] = most recent to [length - 1] = least recent\n   * @public\n   * @memberof StatsHistory\n   */\n  get() {\n    return this.history;\n  }\n\n  /**\n   * deletes the history array and resets it\n   * @returns {undefined}\n   * @public\n   * @memberof StatsHistory\n   */\n  clear() {\n    this.history = [];\n  }\n\n  /**\n   * gets the stored stat\n   * @param {Number} index the location\n   * @returns {Object} the stat at location index\n   * @public\n   * @memberof StatsHistory\n   */\n  getAt(index) {\n    return this.history[index];\n  }\n\n  /**\n   * gets the most recently stored stat\n   * @returns {Object} the most recently added stat to the history recorder\n   * @public\n   * @memberof StatsHistory\n   */\n  getMostRecent() {\n    return this.history.length > 1 ? this.getAt(0) : null;\n  }\n\n  /**\n   * gets the last two values, that can be used to compare\n   * @returns {Object} {previous: WebRTCData, current: WebRTCData}\n   */\n  getComparable() {\n    return {\n      previous: this.getMostRecent(),\n      current: this.history.length > 2 ? this.getAt(1) : null\n    };\n  }\n\n  /**\n   * gets a cut of the n most recent WebRTC datas stored\n   * @param {Number} exclusiveEnd\n   * @returns {Array}\n   */\n  getSlice(exclusiveEnd) {\n    return this.history.slice(0, exclusiveEnd);\n  }\n\n  /**\n   * adds a history entry into tshe array at the head, removes from the tail\n   * if too large, returns the old tail if removed\n   * @param {WebRTCData} data filtered stats report to add to the history array\n   * @returns {Object} the removed stats report at the end if that had to be removed\n   * to make space for the new stats data report to be added to the front\n   */\n  add(data) {\n    let removed = null;\n\n    if (this.history.length >= this.max) {\n      removed = this.history.pop();\n    }\n    this.history.unshift(data);\n\n    return removed;\n  }\n}\n"]}