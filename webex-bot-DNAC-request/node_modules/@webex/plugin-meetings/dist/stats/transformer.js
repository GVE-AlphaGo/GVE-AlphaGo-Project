'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _bowser = require('bowser');

var _bowser2 = _interopRequireDefault(_bowser);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StatsTransformer = {
  isFF: _bowser2.default.name.toLowerCase() === 'firefox'
};

// convert the ids from the parsed stats objects into understandable keys
StatsTransformer.simplify = function (stat) {
  return (0, _find3.default)((0, _keys3.default)(StatsTransformer.isFF ? _constants.DEFAULT_FF_TRANSFORM_REGEX : _constants.DEFAULT_TRANSFORM_REGEX), function (key) {
    var value = void 0;

    if (StatsTransformer.isFF) {
      // FF stats are formatted poorly so we have to take what we can get
      value = _constants.DEFAULT_FF_TRANSFORM_REGEX[key].regex.test('' + stat.type + (stat.kind ? '_' + stat.kind : '') + '_' + stat.id) ? key : false;
    } else {
      // no other parameters necessary besides id
      value = _constants.DEFAULT_TRANSFORM_REGEX[key].regex.test(stat.id) ? key : false;
    }

    if (value) {
      // others were included but have a value that exclude them from the list because of duplicates that weren't chosen
      if (_constants.DEFAULT_TRANSFORM_REGEX[value].decider) {
        if (stat[_constants.DEFAULT_TRANSFORM_REGEX[value].decider] !== _constants.DEFAULT_TRANSFORM_REGEX[value].selector) {
          value = false;
        }

        return value;
      }
      // // some types need to check against a type field as well
      if (_constants.DEFAULT_TRANSFORM_REGEX[value].profiler) {
        var mapStatToReadableType = stat[_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.type];

        if (!(mapStatToReadableType && mapStatToReadableType.includes(_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.value) && value.toLowerCase().includes(_constants.DEFAULT_TRANSFORM_REGEX[value].profiler.value))) {
          value = false;

          return value;
        }
      }
    }

    return value;
  });
};

// parse the RTCStatsReport, extracting only the data we care about
StatsTransformer.parse = function (report) {
  var target = {};

  // from the stats object
  // get the rtc stats report
  if (report && report.forEach && report.size > 0) {
    report.forEach(function (stat) {
      // each report has internal data
      if (stat && stat.type) {
        // pull only certain types
        if (_constants.DEFAULT_GET_STATS_FILTER.types.includes(stat.type)) {
          // insert into the target the statistic mapped to it's statical id
          target[stat.id] = stat;
        }
      }
    });
  }

  return target;
};

StatsTransformer.convert = function (parsed, options) {
  // supply your own simplification function (rather than id as the key)
  if (options.simplifyFn) {
    return options.simplifyFn(parsed);
  }
  // else use ours that stores things like rtcOutAudio, rtpInVideo, etc
  var target = {};

  (0, _forEach3.default)(parsed, function (stat) {
    var key = StatsTransformer.simplify(stat);

    if (key) {
      target[key] = stat;
    }
  });

  return target;
};

// transform the RTCStatsReport into a much more readable, processable format
StatsTransformer.transform = function (report) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { simplifyFn: undefined };

  var data = void 0;
  // first parse it and cut out not necessary data
  var parsed = StatsTransformer.parse(report);

  // either convert the data or store each stat with it's id mapped as the key to the stat object itself
  if (_constants.DEFAULT_TRANSFORM_REGEX) {
    data = StatsTransformer.convert(parsed, options);
  } else {
    data = parsed;
  }

  return data;
};
exports.default = StatsTransformer;
//# sourceMappingURL=transformer.js.map
