{"version":3,"sources":["stream.js"],"names":["pcsByRTCRtpDirection","emittersByRTCRtpDirection","RTCRtpDirectionByEmitter","emittersByStream","timersByEmitter","schedule","emitter","interval","timer","direction","get","pc","getStats","then","stats","emit","STATS","DATA","signalingState","CLOSED","connectionState","catch","err","ERROR","set","StatsStream","config","objectMode","has","rTCRtpDirection","EventEmitter","peerConnection","once","data","isPaused","push","Readable"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;;AAEA;;;;AAKA,IAAMA,uBAAuB,uBAA7B;AACA,IAAMC,4BAA4B,uBAAlC;AACA,IAAMC,2BAA2B,uBAAjC;AACA,IAAMC,mBAAmB,uBAAzB;AACA,IAAMC,kBAAkB,uBAAxB;;AAEA;;;;;;;;AAQA,IAAMC,WAAW,SAAXA,QAAW,CAACC,OAAD,EAAUC,QAAV,EAAuB;AACtC,MAAMC,QAAQ,kCAAe,YAAM;AACjC,QAAMC,YAAYP,yBAAyBQ,GAAzB,CAA6BJ,OAA7B,CAAlB;AACA,QAAMK,KAAKX,qBAAqBU,GAArB,CAAyBD,SAAzB,CAAX;;AAEA,QAAIA,SAAJ,EAAe;AACbA,gBAAUG,QAAV,GACGC,IADH,CACQ,UAACC,KAAD,EAAW;AACfR,gBAAQS,IAAR,CAAaC,iBAAMC,IAAnB,EAAyBH,KAAzB;AACA;AACA;AACA;AACA;AACA,YAAI,EAAEH,GAAGO,cAAH,KAAsBF,iBAAMG,MAA5B,IAAsCR,GAAGS,eAAH,KAAuBJ,iBAAMG,MAArE,CAAJ,EAAkF;AAChFd,mBAASC,OAAT,EAAkBC,QAAlB;AACD;AACF,OAVH,EAWGc,KAXH,CAWS,UAACC,GAAD,EAAS;AACdhB,gBAAQS,IAAR,CAAaQ,gBAAb,EAAoBD,GAApB;AACD,OAbH;AAcD;AACF,GApBa,EAoBXf,QApBW,CAAd;;AAsBAH,kBAAgBoB,GAAhB,CAAoBlB,OAApB,EAA6BE,KAA7B;AACD,CAxBD;;AA0BA;;;;;IAIqBiB,W;;;AACnB;;;;;;;AAOA,yBAAyB;AAAA,QAAbC,MAAa,uEAAJ,EAAI;AAAA;;AAAA,gJACjB,EAACC,YAAY,IAAb,EADiB;;AAGvB,UAAKpB,QAAL,GAAgBmB,OAAOnB,QAAvB;;AAEA,QAAI,CAACN,0BAA0B2B,GAA1B,CAA8BF,OAAOG,eAArC,CAAL,EAA4D;AAC1D5B,gCAA0BuB,GAA1B,CAA8BE,OAAOG,eAArC,EAAsD,IAAIC,oBAAJ,EAAtD;AACD;AACD,QAAMxB,UAAUL,0BAA0BS,GAA1B,CAA8BgB,OAAOG,eAArC,CAAhB;;AAEA,QAAI,CAAC1B,iBAAiByB,GAAjB,OAAL,EAAiC;AAC/BzB,uBAAiBqB,GAAjB,QAA2BlB,OAA3B;AACD;AACD,QAAI,CAACJ,yBAAyB0B,GAAzB,CAA6BtB,OAA7B,CAAL,EAA4C;AAC1CJ,+BAAyBsB,GAAzB,CAA6BlB,OAA7B,EAAsCoB,OAAOG,eAA7C;AACD;;AAED,QAAI,CAAC7B,qBAAqB4B,GAArB,CAAyBF,OAAOG,eAAhC,CAAL,EAAuD;AACrD7B,2BAAqBwB,GAArB,CAAyBE,OAAOG,eAAhC,EAAiDH,OAAOK,cAAxD;AACD;;AAEDzB,YAAQ0B,IAAR,CAAaT,gBAAb,EAAoB,UAACD,GAAD,EAAS;AAC3B,YAAKP,IAAL,CAAUQ,gBAAV,EAAiBD,GAAjB;AACD,KAFD;AArBuB;AAwBxB;;AAED;;;;;;;;;4BAKQ;AAAA;;AACN,UAAMhB,UAAUH,iBAAiBO,GAAjB,CAAqB,IAArB,CAAhB;;AAEAJ,cAAQ0B,IAAR,CAAahB,iBAAMC,IAAnB,EAAyB,UAACgB,IAAD,EAAU;AACjC,YAAI,CAAC,OAAKC,QAAL,EAAL,EAAsB;AACpB,iBAAKC,IAAL,CAAUF,IAAV;AACD;AACF,OAJD;;AAMA,UAAI,CAAC7B,gBAAgBwB,GAAhB,CAAoBtB,OAApB,CAAL,EAAmC;AACjCD,iBAASC,OAAT,EAAkB,KAAKC,QAAvB;AACD;AACF;;;EAnDsC6B,gB;;kBAApBX,W","file":"stream.js","sourcesContent":["import {Readable} from 'stream';\nimport {EventEmitter} from 'events';\n\nimport {safeSetTimeout} from '@webex/common-timers';\n\nimport {\n  ERROR,\n  STATS\n} from '../constants';\n\nconst pcsByRTCRtpDirection = new WeakMap();\nconst emittersByRTCRtpDirection = new WeakMap();\nconst RTCRtpDirectionByEmitter = new WeakMap();\nconst emittersByStream = new WeakMap();\nconst timersByEmitter = new WeakMap();\n\n/**\n * Helper function that ensures no matter how many stats streams we create, we\n * don't poll the PeerConnection more than once per interval.\n * @param {EventEmitter} emitter\n * @param {Number} interval\n * @private\n * @returns {undefined}\n */\nconst schedule = (emitter, interval) => {\n  const timer = safeSetTimeout(() => {\n    const direction = RTCRtpDirectionByEmitter.get(emitter);\n    const pc = pcsByRTCRtpDirection.get(direction);\n\n    if (direction) {\n      direction.getStats()\n        .then((stats) => {\n          emitter.emit(STATS.DATA, stats);\n          // TODO: Remove on 1.0 spec adoption\n          // \"closed\" is supposed to be part of the {@link RTCPeerConnectionState}\n          // enum according to spec, but at time of writing, was still implemented\n          // in the {@link RTCSignalingState} enum.\n          if (!(pc.signalingState === STATS.CLOSED || pc.connectionState === STATS.CLOSED)) {\n            schedule(emitter, interval);\n          }\n        })\n        .catch((err) => {\n          emitter.emit(ERROR, err);\n        });\n    }\n  }, interval);\n\n  timersByEmitter.set(emitter, timer);\n};\n\n/**\n * Polls an {@link RTCPeerConnection} once per second and emits its {@link RTCStatsReport}\n * {@link RTCStatsReport}\n */\nexport default class StatsStream extends Readable {\n  /**\n   * @private\n   * @param {Object} config\n   * @param {RTCRtpSender|RTCRtpReceiver} config.rTCRtpDirection\n   * @param {RTCPeerConnection} config.peerConnection\n   * @param {Number} config.interval\n   */\n  constructor(config = {}) {\n    super({objectMode: true});\n\n    this.interval = config.interval;\n\n    if (!emittersByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      emittersByRTCRtpDirection.set(config.rTCRtpDirection, new EventEmitter());\n    }\n    const emitter = emittersByRTCRtpDirection.get(config.rTCRtpDirection);\n\n    if (!emittersByStream.has(this)) {\n      emittersByStream.set(this, emitter);\n    }\n    if (!RTCRtpDirectionByEmitter.has(emitter)) {\n      RTCRtpDirectionByEmitter.set(emitter, config.rTCRtpDirection);\n    }\n\n    if (!pcsByRTCRtpDirection.has(config.rTCRtpDirection)) {\n      pcsByRTCRtpDirection.set(config.rTCRtpDirection, config.peerConnection);\n    }\n\n    emitter.once(ERROR, (err) => {\n      this.emit(ERROR, err);\n    });\n  }\n\n  /**\n   * See NodeJS Docs\n   * @private\n   * @returns {undefined}\n   */\n  _read() {\n    const emitter = emittersByStream.get(this);\n\n    emitter.once(STATS.DATA, (data) => {\n      if (!this.isPaused()) {\n        this.push(data);\n      }\n    });\n\n    if (!timersByEmitter.has(emitter)) {\n      schedule(emitter, this.interval);\n    }\n  }\n}\n\n"]}