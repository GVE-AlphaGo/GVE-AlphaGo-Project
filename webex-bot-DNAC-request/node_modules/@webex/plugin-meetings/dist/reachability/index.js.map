{"version":3,"sources":["index.js"],"names":["Reachability","attrs","options","namespace","MEETINGS","setup","processedClusterResults","peerConnectionMap","gatherReachability","window","localStorage","setItem","REACHABILITY","reachabilityRequest","getClusters","then","clusters","performReachabilityCheck","response","catch","error","LoggerProxy","logger","clusterList","length","resolve","localSDPList","getLocalSDPForClusters","localSDPData","peerConnection","info","setRemoteOfferForEachCluster","iceResult","remoteSDPForClusters","remoteSDPResponse","remoteSDPList","answers","cleanUpPeerConnections","forEach","remoteSdp","jsonObj","clusterId","sdp","pc","setIceCallBackHandlers","iceStatsResult","push","start","iceStats","stop","reachabilityResult","parseIceResultToReachabilityResult","peerConnectionManager","setRemoteSessionDetails","ANSWER","reject","cluster","createOffer","MediaUtil","createPeerConnection","localSDP","result","reachability","latency","reachable","latencyInMilliseconds","udp","key","close","timeout","iceComplete","isSuccessful","clearTimeout","undefined","setTimeout","warn","oniceconnectionstatechange","iceConnectionState","ICE_STATE","CHECKING","Date","now","CONNECTED","FAILED","ReachabilityRequest","StatelessWebexPlugin"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;AAEA;;;;AACA;;;;AACA;;;;AACA;;AAEA;;;;;;AAEA;;;;;AAdA;;;;AAIA;IAcqBA,Y;;;AAGnB,wBAAYC,KAAZ,EAAmBC,OAAnB,EAA4B;AAAA;;AAE1B;;;;;;;AAF0B,kJACpB,EADoB,EAChBA,OADgB;;AAAA,UAF5BC,SAE4B,GAFhBC,mBAEgB;;AAAA,UAkB5BC,KAlB4B,GAkBpB,YAAM;AACZ,YAAKC,uBAAL,GAA+B,EAA/B;AACA,YAAKC,iBAAL,GAAyB,EAAzB;AACD,KArB2B;;AAAA,UA6B5BC,kBA7B4B,GA6BP,YAAM;AACzB,YAAKH,KAAL;AACA;AACA,UAAI;AACFI,eAAOC,YAAP,CAAoBC,OAApB,CAA4BC,wBAAaF,YAAzC,EAAuD,yBAAe,EAAf,CAAvD;;AAEA;AACA,eAAO,MAAKG,mBAAL,CAAyBC,WAAzB,GACJC,IADI,CACC,UAACC,QAAD;AAAA;AACJ;AACA,kBAAKC,wBAAL,CAA8BD,QAA9B,EACGD,IADH,CACQ,UAACG,QAAD,EAAc;AAClBT,qBAAOC,YAAP,CAAoBC,OAApB,CAA4BC,wBAAaF,YAAzC,EAAuD,yBAAeQ,QAAf,CAAvD;;AAEA,qBAAOA,QAAP;AACD,aALH;AAFI;AAAA,SADD,EASJC,KATI,CASE,UAACC,KAAD,EAAW;AAChBC,gCAAYC,MAAZ,CAAmBF,KAAnB,uEAA6FA,KAA7F;;AAEA,iBAAO,EAAP;AACD,SAbI,CAAP;AAcD,OAlBD,CAmBA,OAAOA,KAAP,EAAc;AACZC,8BAAYC,MAAZ,CAAmBF,KAAnB,wEAA8FA,KAA9F;;AAEA,eAAO,EAAP;AACD;AACF,KAxD2B;;AAAA,UAiE5BH,wBAjE4B,GAiED,UAACM,WAAD,EAAiB;AAC1C,UAAI,CAACA,WAAD,IAAgB,CAACA,YAAYC,MAAjC,EAAyC;AACvC,eAAO,kBAAQC,OAAR,CAAgB,EAAhB,CAAP;AACD;;AAED,UAAIC,eAAe,EAAnB;;AAEA,aAAO,sBAAa,UAACD,OAAD,EAAa;AAC/B,cAAKE,sBAAL,CAA4BJ,WAA5B,EACGR,IADH,CACQ,UAACa,YAAD,EAAkB;AACtB,cAAI,CAACA,YAAD,IAAiB,CAAC,oBAAYA,YAAZ,EAA0BJ,MAA5C,IAAsD,CAACI,aAAaF,YAApE,IAAoF,CAACE,aAAaC,cAAtG,EAAsH;AACpH;AACAR,kCAAYC,MAAZ,CAAmBQ,IAAnB,CAAwB,8FAAxB;AACAL,oBAAQ,EAAR;AACD;;AAED,gBAAKlB,iBAAL,GAAyBqB,aAAaC,cAAtC;AACEH,sBARoB,GAQJE,YARI,CAQpBF,YARoB;;AAStB,gBAAKK,4BAAL,CAAkCL,YAAlC,EACGX,IADH,CACQ,UAACG,QAAD,EAAc;AAClBO,oBAAQP,QAAR;AACD,WAHH;AAID,SAdH,EAeGC,KAfH,CAeS,UAACC,KAAD,EAAW;AAChBC,gCAAYC,MAAZ,CAAmBF,KAAnB,8EAAoGA,KAApG;AACAK,kBAAQ,EAAR;AACD,SAlBH;AAmBD,OApBM,CAAP;AAqBD,KA7F2B;;AAAA,UAsG5BM,4BAtG4B,GAsGG,UAACL,YAAD,EAAkB;AAC/C,UAAMM,YAAY,EAAlB;;AAEA,aAAO,sBAAY,UAACP,OAAD,EAAa;AAC9B,cAAKZ,mBAAL,CAAyBoB,oBAAzB,CAA8CP,YAA9C,EACGX,IADH,CACQ,UAACmB,iBAAD,EAAuB;AAC3B,cAAMC,gBAAgBD,kBAAkBE,OAAxC;;AAEA,cAAI,CAACD,aAAD,IAAkB,CAACA,cAAcX,MAArC,EAA6C;AAC3CH,kCAAYC,MAAZ,CAAmBQ,IAAnB,CAAwB,iEAAxB;AACA,kBAAKO,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAkB,oBAAQ,EAAR;AACD;AACDU,wBAAcG,OAAd,CAAsB,UAACC,SAAD,EAAe;AACnC,gBAAMC,UAAUD,SAAhB;AADmC,gBAE5BE,SAF4B,GAEfD,OAFe,CAE5BC,SAF4B;;;AAInC,gBAAID,WAAWA,QAAQE,GAAvB,EAA4B;AAC1B,kBAAMC,KAAK,MAAKpC,iBAAL,CAAuBkC,SAAvB,CAAX;;AAEA,oBAAKG,sBAAL,CAA4BD,EAA5B,EACG5B,IADH,CACQ,UAAC8B,cAAD,EAAoB;AACxBA,+BAAeJ,SAAf,GAA2BA,SAA3B;AACA,sBAAKnC,uBAAL,CAA6BwC,IAA7B,CAAkCD,eAAeJ,SAAjD;AACAT,0BAAUa,eAAeJ,SAAzB,IAAsC;AACpCM,yBAAOF,eAAeG,QAAf,CAAwBD,KADK;AAEpCE,wBAAMJ,eAAeG,QAAf,CAAwBC;AAFM,iBAAtC;AAIA,oBAAI,MAAK3C,uBAAL,CAA6BkB,MAA7B,KAAwCW,cAAcX,MAA1D,EAAkE;AAChE,sBAAM0B,qBAAqB,MAAKC,kCAAL,CAAwCnB,SAAxC,CAA3B;;AAEAX,wCAAYC,MAAZ,CAAmBQ,IAAnB,8EAAmG,yBAAeoB,kBAAf,CAAnG;AACAzB,0BAAQyB,kBAAR;AACD;AACF,eAdH,EAeG/B,KAfH,CAeS,UAACC,KAAD,EAAW;AAChBC,sCAAYC,MAAZ,CAAmBF,KAAnB,oFAA0GA,KAA1G;AACA,sBAAKiB,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAkB,wBAAQ,EAAR;AACD,eAnBH;AAoBA2B,8CAAsBC,uBAAtB,CAA8CV,EAA9C,EAAkDW,iBAAlD,EAA0Dd,QAAQE,GAAlE;AACD,aAxBD,MAyBK;AACHrB,oCAAYC,MAAZ,CAAmBF,KAAnB,CAAyB,0EAAzB;AACA,oBAAKd,uBAAL,CAA6BwC,IAA7B,CAAkCL,SAAlC;AACA,kBAAI,MAAKnC,uBAAL,CAA6BkB,MAA7B,KAAwCW,cAAcX,MAA1D,EAAkE;AAChE,sBAAKa,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAkB,wBAAQ,EAAR;AACD;AACF;AACF,WArCD;AAsCD,SA/CH,EAgDGN,KAhDH,CAgDS,UAACC,KAAD,EAAW;AAChBC,gCAAYC,MAAZ,CAAmBF,KAAnB,gFAAsGA,KAAtG;AACA,gBAAKiB,sBAAL,CAA4B,MAAK9B,iBAAjC;AACAkB,kBAAQ,EAAR;AACD,SApDH;AAqDD,OAtDM,CAAP;AAuDD,KAhK2B;;AAAA,UAyK5BE,sBAzK4B,GAyKH,UAACJ,WAAD,EAAiB;AACxC,UAAMK,eAAe,EAArB;AACA,UAAMF,eAAe,EAArB;AACA,UAAMnB,oBAAoB,EAA1B;;AAEA,aAAO,sBAAa,UAACkB,OAAD,EAAU8B,MAAV,EAAqB;AACvChC,oBAAYe,OAAZ,CAAoB,UAACkB,OAAD,EAAa;AAC/B,cAAMf,YAAYe,OAAlB;;AAEAJ,0CAAsBK,WAAtB,CAAkCC,eAAUC,oBAAV,EAAlC,EACG5C,IADH,CACQ,UAACc,cAAD,EAAoB;AACxBtB,8BAAkBkC,SAAlB,IAA+BZ,cAA/B;;AAEA,gBAAM+B,WAAW;AACflB,mBAAKb,eAAea,GADL;AAEfD;AAFe,aAAjB;;AAKAf,yBAAaoB,IAAb,CAAkBc,QAAlB;;AAEA,gBAAIlC,aAAaF,MAAb,KAAwBD,YAAYC,MAAxC,EAAgD;AAC9CI,2BAAaC,cAAb,GAA8BtB,iBAA9B;AACAqB,2BAAaF,YAAb,GAA4BA,YAA5B;AACAD,sBAAQG,YAAR;AACD;AACF,WAhBH,EAiBGT,KAjBH,CAiBS,UAACC,KAAD,EAAW;AAChBC,kCAAYC,MAAZ,CAAmBF,KAAnB,kEAAwFA,KAAxF;AACAmC,mBAAOnC,KAAP;AACD,WApBH;AAqBD,SAxBD;AAyBD,OA1BM,CAAP;AA2BD,KAzM2B;;AAAA,UAkN5B+B,kCAlN4B,GAkNS,UAACnB,SAAD,EAAe;AAClD,UAAI,CAACA,SAAD,IAAc,CAAC,oBAAYA,SAAZ,EAAuBR,MAA1C,EAAkD;AAChD,eAAO,EAAP;AACD;AACD,UAAMqC,SAAS,EAAf;;AAJkD;AAAA;AAAA;;AAAA;AAMlD,wDAAwB,oBAAY7B,SAAZ,CAAxB,4GAAgD;AAAA,cAArCS,SAAqC;;AAC9C,cAAIqB,eAAe,EAAnB;;AAEA,cAAI9B,UAAUS,SAAV,EAAqBM,KAArB,GAA6B,CAA7B,IAAkCf,UAAUS,SAAV,EAAqBQ,IAArB,GAA4B,CAAlE,EAAqE;AACnE,gBAAMc,UAAU/B,UAAUS,SAAV,EAAqBQ,IAArB,GAA4BjB,UAAUS,SAAV,EAAqBM,KAAjE;;AAEAe,2BAAe;AACbE,yBAAW,IADE;AAEbC,qCAAuBF;AAFV,aAAf;AAID,WAPD,MAQK;AACHD,2BAAe,EAACE,WAAW,KAAZ,EAAf;AACD;AACDH,iBAAOpB,SAAP,IAAoB,EAACyB,KAAKJ,YAAN,EAApB;AACD;AArBiD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuBlD,aAAOD,MAAP;AACD,KA1O2B;;AAAA,UAmP5BxB,sBAnP4B,GAmPH,UAAC9B,iBAAD,EAAuB;AAAA;AAAA;AAAA;;AAAA;AAC9C,yDAAkB,oBAAYA,iBAAZ,CAAlB,iHAAkD;AAAA,cAAvC4D,GAAuC;;AAChD,cAAMxB,KAAKpC,kBAAkB4D,GAAlB,CAAX;;AAEA,cAAIxB,EAAJ,EAAQ;AACNtB,kCAAYC,MAAZ,CAAmBQ,IAAnB,6FAAkHqC,GAAlH;AACAxB,eAAGyB,KAAH;AACD;AACF;AAR6C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAS/C,KA5P2B;;AAAA,UAqQ5BxB,sBArQ4B,GAqQH,UAACD,EAAD,EAAQ;AAC/B,UAAI0B,UAAU,IAAd;AACA,UAAMrB,WAAW,EAACD,OAAO,CAAR,EAAWE,MAAM,CAAjB,EAAjB;;AAEA,aAAO,sBAAa,UAACxB,OAAD,EAAa;AAC/B,iBAAS6C,WAAT,CAAqBC,YAArB,EAAmCF,OAAnC,EAA4CrB,QAA5C,EAAsD;AACpD,cAAIuB,YAAJ,EAAkB;AAChB,gBAAIF,OAAJ,EAAa;AACX5D,qBAAO+D,YAAP,CAAoBH,OAApB;AACAA,wBAAUI,SAAV;AACD;AACF;AACD9B,aAAGyB,KAAH;AACA3C,kBAAQ,EAACuB,kBAAD,EAAR;AACD;;AAEDqB,kBAAU5D,OAAOiE,UAAP,CAAkB,YAAM;AAChCrD,gCAAYC,MAAZ,CAAmBqD,IAAnB,uCAA4D,MAAKlC,SAAjE;AACA6B,sBAAY,KAAZ,EAAmBD,OAAnB,EAA4BrB,QAA5B;AACD,SAHS,EAGP,IAHO,CAAV;;AAKAL,WAAGiC,0BAAH,GAAgC,YAAM;AACpC,cAAIjC,EAAJ,EAAQ;AACN,gBAAIA,GAAGkC,kBAAH,KAA0BC,qBAAUC,QAAxC,EAAkD;AAChD/B,uBAASD,KAAT,GAAiBiC,KAAKC,GAAL,EAAjB;AACD;AACD,gBAAItC,GAAGkC,kBAAH,KAA0BC,qBAAUI,SAAxC,EAAmD;AACjDlC,uBAASC,IAAT,GAAgB+B,KAAKC,GAAL,EAAhB;AACAX,0BAAY,IAAZ,EAAkBD,OAAlB,EAA2BrB,QAA3B;AACD;AACD,gBAAIL,GAAGkC,kBAAH,KAA0BC,qBAAUK,MAAxC,EAAgD;AAC9Cb,0BAAY,KAAZ,EAAmBD,OAAnB,EAA4BrB,QAA5B;AACD;AACF;AACF,SAbD;AAcD,OA/BM,CAAP;AAgCD,KAzS2B;;AAAA,UAiT5BlC,WAjT4B,GAiTd;AAAA,aAAM,MAAKD,mBAAL,CAAyBC,WAAzB,EAAN;AAAA,KAjTc;;AAS1B,UAAKD,mBAAL,GAA2B,IAAIuE,iBAAJ,CAAwB,EAAxB,EAA4BlF,OAA5B,CAA3B;AAT0B;AAU3B;;AAED;;;;;;;;AAWA;;;;;;;;AAmCA;;;;;;;;;AAqCA;;;;;;;;;AAmEA;;;;;;;;;AAyCA;;;;;;;;;AAiCA;;;;;;;;;AAkBA;;;;;;;;;AA6CA;;;;;;;;;EA9SwCmF,+B;;kBAArBrF,Y","file":"index.js","sourcesContent":["\n/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* globals window */\nimport {StatelessWebexPlugin} from '@webex/webex-core';\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport peerConnectionManager from '../peer-connection-manager';\nimport MediaUtil from '../media/util';\nimport {ICE_STATE, MEETINGS, REACHABILITY, ANSWER} from '../constants';\n\nimport ReachabilityRequest from './request';\n\n/**\n * @class Reachability\n * @export\n */\nexport default class Reachability extends StatelessWebexPlugin {\n  namespace = MEETINGS;\n\n  constructor(attrs, options) {\n    super({}, options);\n    /**\n     * internal request object for the server\n     * @instance\n     * @type {Array}\n     * @private\n     * @memberof Reachability\n     */\n    this.reachabilityRequest = new ReachabilityRequest({}, options);\n  }\n\n  /**\n   * utility function\n   * @returns {undefined}\n   * @private\n   * @memberof Reachability\n   */\n  setup = () => {\n    this.processedClusterResults = [];\n    this.peerConnectionMap = {};\n  }\n\n  /**\n   * fetches reachability data\n   * @returns {Object} reachability data\n   * @public\n   * @memberof Reachability\n   */\n  gatherReachability = () => {\n    this.setup();\n    // Reset reachability result to empty to ensure no stale data\n    try {\n      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify({}));\n\n      // Get clusters from Orpheus\n      return this.reachabilityRequest.getClusters()\n        .then((clusters) =>\n          // Perform Reachability Check\n          this.performReachabilityCheck(clusters)\n            .then((response) => {\n              window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(response));\n\n              return response;\n            }))\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability->gatherReachability#Error in calling getClusters(): ${error}`);\n\n          return {};\n        });\n    }\n    catch (error) {\n      LoggerProxy.logger.error(`Reachability->gatherReachability#Error in accessing LocalStorage: ${error}`);\n\n      return {};\n    }\n  };\n\n  /**\n   * fetches reachability data\n   * @param {object} clusterList\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  performReachabilityCheck = (clusterList) => {\n    if (!clusterList || !clusterList.length) {\n      return Promise.resolve({});\n    }\n\n    let localSDPList = [];\n\n    return new Promise(((resolve) => {\n      this.getLocalSDPForClusters(clusterList)\n        .then((localSDPData) => {\n          if (!localSDPData || !Object.keys(localSDPData).length || !localSDPData.localSDPList || !localSDPData.peerConnection) {\n            // TODO: handle the error condition properly and try retry\n            LoggerProxy.logger.info('Reachability->performReachabilityCheck#Local SDP is empty or has missing elements..returning');\n            resolve({});\n          }\n\n          this.peerConnectionMap = localSDPData.peerConnection;\n          ({localSDPList} = localSDPData);\n          this.setRemoteOfferForEachCluster(localSDPList)\n            .then((response) => {\n              resolve(response);\n            });\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability->performReachabilityCheck#Error in getLocalSDPForClusters: ${error}`);\n          resolve({});\n        });\n    }));\n  };\n\n  /**\n   * sets remote offer for each clusters\n   * @param {object} localSDPList local SDP generated\n   * @returns {object} reachability check results\n   * @private\n   * @memberof Reachability\n   */\n  setRemoteOfferForEachCluster = (localSDPList) => {\n    const iceResult = {};\n\n    return new Promise((resolve) => {\n      this.reachabilityRequest.remoteSDPForClusters(localSDPList)\n        .then((remoteSDPResponse) => {\n          const remoteSDPList = remoteSDPResponse.answers;\n\n          if (!remoteSDPList || !remoteSDPList.length) {\n            LoggerProxy.logger.info('Reachability->setRemoteOfferForEachCluster#Remote SDP is empty.');\n            this.cleanUpPeerConnections(this.peerConnectionMap);\n            resolve({});\n          }\n          remoteSDPList.forEach((remoteSdp) => {\n            const jsonObj = remoteSdp;\n            const {clusterId} = jsonObj;\n\n            if (jsonObj && jsonObj.sdp) {\n              const pc = this.peerConnectionMap[clusterId];\n\n              this.setIceCallBackHandlers(pc)\n                .then((iceStatsResult) => {\n                  iceStatsResult.clusterId = clusterId;\n                  this.processedClusterResults.push(iceStatsResult.clusterId);\n                  iceResult[iceStatsResult.clusterId] = {\n                    start: iceStatsResult.iceStats.start,\n                    stop: iceStatsResult.iceStats.stop\n                  };\n                  if (this.processedClusterResults.length === remoteSDPList.length) {\n                    const reachabilityResult = this.parseIceResultToReachabilityResult(iceResult);\n\n                    LoggerProxy.logger.info(`Reachability->setRemoteOfferForEachCluster#Returning reachability result${JSON.stringify(reachabilityResult)}`);\n                    resolve(reachabilityResult);\n                  }\n                })\n                .catch((error) => {\n                  LoggerProxy.logger.error(`Reachability->setRemoteOfferForEachCluster#Error in setIceCallBackHandlers(): ${error}`);\n                  this.cleanUpPeerConnections(this.peerConnectionMap);\n                  resolve({});\n                });\n              peerConnectionManager.setRemoteSessionDetails(pc, ANSWER, jsonObj.sdp);\n            }\n            else {\n              LoggerProxy.logger.error('Reachability->setRemoteOfferForEachCluster# Error in getting remote sdp.');\n              this.processedClusterResults.push(clusterId);\n              if (this.processedClusterResults.length === remoteSDPList.length) {\n                this.cleanUpPeerConnections(this.peerConnectionMap);\n                resolve({});\n              }\n            }\n          });\n        })\n        .catch((error) => {\n          LoggerProxy.logger.error(`Reachability->setRemoteOfferForEachCluster#Error in remoteSDPForClusters!:${error}`);\n          this.cleanUpPeerConnections(this.peerConnectionMap);\n          resolve({});\n        });\n    });\n  }\n\n  /**\n   * creates offer and generates localSDP\n   * @param {object} clusterList cluster List\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n  getLocalSDPForClusters = (clusterList) => {\n    const localSDPData = {};\n    const localSDPList = [];\n    const peerConnectionMap = {};\n\n    return new Promise(((resolve, reject) => {\n      clusterList.forEach((cluster) => {\n        const clusterId = cluster;\n\n        peerConnectionManager.createOffer(MediaUtil.createPeerConnection())\n          .then((peerConnection) => {\n            peerConnectionMap[clusterId] = peerConnection;\n\n            const localSDP = {\n              sdp: peerConnection.sdp,\n              clusterId\n            };\n\n            localSDPList.push(localSDP);\n\n            if (localSDPList.length === clusterList.length) {\n              localSDPData.peerConnection = peerConnectionMap;\n              localSDPData.localSDPList = localSDPList;\n              resolve(localSDPData);\n            }\n          })\n          .catch((error) => {\n            LoggerProxy.logger.error(`Reachability->getLocalSDPForClusters#Error in getLocalSDP : ${error}`);\n            reject(error);\n          });\n      });\n    }));\n  };\n\n  /**\n   * Calculates time to establish connection\n   * @param {object} iceResult iceResults\n   * @returns {object} result\n   * @private\n   * @memberof Reachability\n   */\n  parseIceResultToReachabilityResult = (iceResult) => {\n    if (!iceResult || !Object.keys(iceResult).length) {\n      return {};\n    }\n    const result = {};\n\n    for (const clusterId of Object.keys(iceResult)) {\n      let reachability = {};\n\n      if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {\n        const latency = iceResult[clusterId].stop - iceResult[clusterId].start;\n\n        reachability = {\n          reachable: true,\n          latencyInMilliseconds: latency\n        };\n      }\n      else {\n        reachability = {reachable: false};\n      }\n      result[clusterId] = {udp: reachability};\n    }\n\n    return result;\n  };\n\n  /**\n   * cleans all the peerconnection\n   * @param {object} peerConnectionMap peerconnectionList\n   * @returns {object} localSDPData\n   * @private\n   * @memberof Reachability\n   */\n  cleanUpPeerConnections = (peerConnectionMap) => {\n    for (const key of Object.keys(peerConnectionMap)) {\n      const pc = peerConnectionMap[key];\n\n      if (pc) {\n        LoggerProxy.logger.info(`Reachability->cleanUpPeerConnections#Cleaning up peer connection created for cluster : ${key}`);\n        pc.close();\n      }\n    }\n  };\n\n  /**\n   * sets the success callback for peerconnection\n   * @param {object} pc peerconnection\n   * @returns {object} iceState\n   * @private\n   * @memberof Reachability\n   */\n  setIceCallBackHandlers = (pc) => {\n    let timeout = null;\n    const iceStats = {start: 0, stop: 0};\n\n    return new Promise(((resolve) => {\n      function iceComplete(isSuccessful, timeout, iceStats) {\n        if (isSuccessful) {\n          if (timeout) {\n            window.clearTimeout(timeout);\n            timeout = undefined;\n          }\n        }\n        pc.close();\n        resolve({iceStats});\n      }\n\n      timeout = window.setTimeout(() => {\n        LoggerProxy.logger.warn(`Reachability->iceCallBackHandler#${this.clusterId} ice handler timed out.`);\n        iceComplete(false, timeout, iceStats);\n      }, 5000);\n\n      pc.oniceconnectionstatechange = () => {\n        if (pc) {\n          if (pc.iceConnectionState === ICE_STATE.CHECKING) {\n            iceStats.start = Date.now();\n          }\n          if (pc.iceConnectionState === ICE_STATE.CONNECTED) {\n            iceStats.stop = Date.now();\n            iceComplete(true, timeout, iceStats);\n          }\n          if (pc.iceConnectionState === ICE_STATE.FAILED) {\n            iceComplete(false, timeout, iceStats);\n          }\n        }\n      };\n    }));\n  };\n\n  /**\n   * proxy to the server request for clusters\n   * @returns {Promise}\n   * @private\n   * @memberof Reachability\n   */\n  getClusters = () => this.reachabilityRequest.getClusters()\n}\n"]}