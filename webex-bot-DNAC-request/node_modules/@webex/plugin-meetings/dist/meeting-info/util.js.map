{"version":3,"sources":["util.js"],"names":["MeetingInfoUtil","getParsedUrl","link","parsedUrl","url","parse","protocol","HTTPS_PROTOCOL","error","LoggerProxy","logger","warn","isMeetingLink","value","hostNameBool","hostname","includes","WEBEX_DOT_COM","pathNameBool","pathname","MEET","MEET_M","JOIN","isConversationUrl","webex","clusterId","internal","services","getClusterId","endsWith","CONVERSATION_SERVICE","convertLinkToSip","user","userIndex","lastIndexOf","substring","company","companyIndex","replace","WWW_DOT","isSipUri","sipString","sipUri","DIALER_REGEX","SIP_ADDRESS","exec","isPhoneNumber","phoneNumber","isValidNumber","PHONE_NUMBER","test","getHydraId","destination","decodedDestination","UUID_REG","id","type","_ROOM_","room","_PEOPLE_","people","getSipUriFromHydraPersonId","get","then","res","emails","length","ParameterError","catch","err","generateOptions","from","options","hydraId","_MEETING_LINK_","_SIP_URI_","_CONVERSATION_URL_","resolve","waitForCatalog","convoUrl","CONVERSATIONS","getResourceUrl","resource","LOCI","MEETINGINFO","method","HTTP_VERBS","GET","_PERSONAL_ROOM_","_MEETING_ID_","TYPE","USE_URI_LOOKUP_FALSE","PUT","_LOCUS_ID_","getRequestParams","resourceOptions","api","requestParams","concat","ALTERNATE_REDIRECT_TRUE","body","lookupType","getMeetingInfoAPIFormat"],"mappings":"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","file":"util.js","sourcesContent":["import url from 'url';\n\nimport btoa from 'btoa';\nimport {\n  deconstructHydraId\n} from '@webex/common';\n\nimport ParameterError from '../common/errors/parameter';\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport {\n  _SIP_URI_,\n  _PERSONAL_ROOM_,\n  _MEETING_ID_,\n  _CONVERSATION_URL_,\n  _LOCUS_ID_,\n  _MEETING_LINK_,\n  _PEOPLE_,\n  _ROOM_,\n  HTTP_VERBS,\n  USE_URI_LOOKUP_FALSE,\n  TYPE,\n  LOCI,\n  MEETINGINFO,\n  ALTERNATE_REDIRECT_TRUE,\n  DIALER_REGEX,\n  WEBEX_DOT_COM,\n  CONVERSATION_SERVICE,\n  WWW_DOT,\n  JOIN,\n  MEET,\n  MEET_M,\n  HTTPS_PROTOCOL,\n  CONVERSATIONS,\n  UUID_REG\n} from '../constants';\n\nconst MeetingInfoUtil = {};\n\nMeetingInfoUtil.getParsedUrl = (link) => {\n  try {\n    let parsedUrl = url.parse(link);\n\n    if (!parsedUrl) {\n      return false;\n    }\n    // hack for links such as <company>.webex.com/meet/<user> without a protocol\n    if (!parsedUrl.protocol) {\n      parsedUrl = url.parse(`${HTTPS_PROTOCOL}${link}`);\n    }\n\n    return parsedUrl;\n  }\n  catch (error) {\n    LoggerProxy.logger.warn(`MeetingInfoUtil->getParsedUrl#unable to parse the URL, error: ${error}`);\n\n    return null;\n  }\n};\n\n/**\n * Helper function to check if a string matches a known meeting link pattern\n * @param {String} value  string to parse and see if it matches a meeting link\n * @returns {Boolean}\n */\nMeetingInfoUtil.isMeetingLink = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n  const hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(WEBEX_DOT_COM);\n  const pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes(`/${MEET}`) || parsedUrl.pathname.includes(`/${MEET_M}`) || parsedUrl.pathname.includes(`/${JOIN}`));\n\n  return hostNameBool && pathNameBool;\n};\n\nMeetingInfoUtil.isConversationUrl = (value, webex) => {\n  const clusterId = webex.internal.services.getClusterId(value);\n\n  if (clusterId) {\n    return clusterId.endsWith(CONVERSATION_SERVICE);\n  }\n\n  return false;\n};\n\nMeetingInfoUtil.convertLinkToSip = (value) => {\n  const parsedUrl = MeetingInfoUtil.getParsedUrl(value);\n\n  if (!parsedUrl) {\n    return null;\n  }\n  let user;\n\n  if (parsedUrl.pathname) {\n    const userIndex = parsedUrl.pathname.lastIndexOf('/');\n\n    user = parsedUrl.pathname.substring(userIndex + 1);\n  }\n  if (!user) {\n    return null;\n  }\n  let company;\n\n  if (parsedUrl.hostname) {\n    const companyIndex = parsedUrl.hostname.lastIndexOf(`.${WEBEX_DOT_COM}`);\n\n    company = parsedUrl.hostname.substring(0, companyIndex).replace(WWW_DOT, '');\n  }\n  if (!company) {\n    return null;\n  }\n\n  return `${user}@${company}.${WEBEX_DOT_COM}`;\n};\n\n\nMeetingInfoUtil.isSipUri = (sipString) => {\n  // TODO: lets remove regex from this equation and user URI matchers and such\n  // have not found a great sip uri parser library as of now\n  const sipUri = DIALER_REGEX.SIP_ADDRESS.exec(sipString);\n\n  return sipUri;\n};\n\nMeetingInfoUtil.isPhoneNumber = (phoneNumber) => {\n  const isValidNumber = DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);\n\n  return isValidNumber;\n};\n\nMeetingInfoUtil.getHydraId = (destination) => {\n  const decodedDestination = deconstructHydraId(destination);\n\n  if (decodedDestination && UUID_REG.test(decodedDestination.id)) {\n    if (decodedDestination.type === _ROOM_) {\n      return {room: true, destination: decodedDestination.id};\n    }\n    if (decodedDestination.type === _PEOPLE_) {\n      return {people: true, destination: decodedDestination.id};\n    }\n\n    return {};\n  }\n\n  return {};\n};\n\nMeetingInfoUtil.getSipUriFromHydraPersonId = (destination, webex) => webex.people.get(destination).then((res) => {\n  if (res.emails && res.emails.length) {\n    return res.emails[0];\n  }\n  throw new ParameterError('Hydra Id Lookup was an invalid hydra person id.');\n}).catch((err) => {\n  throw err;\n});\n\nMeetingInfoUtil.generateOptions = async (from) => {\n  const {destination, type, webex} = from;\n\n  if (type) {\n    return {\n      destination,\n      type\n    };\n  }\n  const options = {};\n  const hydraId = MeetingInfoUtil.getHydraId(destination);\n\n  if (MeetingInfoUtil.isMeetingLink(destination)) {\n    options.type = _MEETING_LINK_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isSipUri(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isPhoneNumber(destination)) {\n    options.type = _SIP_URI_;\n    options.destination = destination;\n  }\n  else if (MeetingInfoUtil.isConversationUrl(destination, webex)) {\n    options.type = _CONVERSATION_URL_;\n    options.destination = destination;\n  }\n  else if (hydraId.people) {\n    options.type = _SIP_URI_;\n\n    return MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then((res) => {\n      options.destination = res;\n\n      return Promise.resolve(options);\n    });\n  }\n  else if (hydraId.room) {\n    options.type = _CONVERSATION_URL_;\n    await webex.internal.services.waitForCatalog('postauth');\n    const convoUrl = `${webex.internal.services.get('conversation')}/${CONVERSATIONS}/${hydraId.destination}`;\n\n    options.destination = convoUrl;\n  }\n  else {\n    throw new ParameterError('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');\n  }\n\n  return Promise.resolve(options);\n};\n\n/**\n * Helper function to build up a correct locus url depending on the value passed\n * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]\n * @param {Object} value ?? value.value\n * @returns {Object} returns an object with {resource, method}\n */\nMeetingInfoUtil.getResourceUrl = (type, value) => {\n  let resource = `/${LOCI}/${MEETINGINFO}`;\n  let method = HTTP_VERBS.GET;\n\n  switch (type) {\n    case _SIP_URI_:\n    case _PERSONAL_ROOM_:\n    case _MEETING_ID_:\n      resource = `/${LOCI}/${MEETINGINFO}/${value}?${TYPE}=${type}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    case _CONVERSATION_URL_:\n      method = HTTP_VERBS.PUT;\n      break;\n    case _LOCUS_ID_:\n      resource = `/${LOCI}/${value}/${MEETINGINFO}`;\n      method = HTTP_VERBS.PUT;\n      break;\n    case _MEETING_LINK_:\n      resource = `$/${LOCI}/${MEETINGINFO}/${btoa(value)}?${TYPE}=${_MEETING_LINK_}&${USE_URI_LOOKUP_FALSE}`;\n      break;\n    default:\n  }\n\n  return {\n    resource,\n    method\n  };\n};\n\nMeetingInfoUtil.getRequestParams = (resourceOptions, type, value, api) => {\n  const requestParams = {\n    method: resourceOptions.method,\n    api,\n    resource: resourceOptions.resource\n  };\n\n  if (resourceOptions.method === HTTP_VERBS.GET) {\n    // for handling URL redirections\n    requestParams.resource = requestParams.resource.concat(`&${ALTERNATE_REDIRECT_TRUE}`);\n  }\n  else\n  if (type !== _LOCUS_ID_) {\n    // locus id check is a PUT not sure why\n    requestParams.resource = requestParams.resource.concat(`?${ALTERNATE_REDIRECT_TRUE}`);\n    requestParams.body = {\n      value,\n      lookupType: type\n    };\n  }\n\n  return requestParams;\n};\n\nMeetingInfoUtil.getMeetingInfoAPIFormat = (options) => ({\n  type: options.type,\n  value: options.destination\n});\n\nexport default MeetingInfoUtil;\n"]}