'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _btoa = require('btoa');

var _btoa2 = _interopRequireDefault(_btoa);

var _common = require('@webex/common');

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MeetingInfoUtil = {};

MeetingInfoUtil.getParsedUrl = function (link) {
  try {
    var parsedUrl = _url2.default.parse(link);

    if (!parsedUrl) {
      return false;
    }
    // hack for links such as <company>.webex.com/meet/<user> without a protocol
    if (!parsedUrl.protocol) {
      parsedUrl = _url2.default.parse('' + _constants.HTTPS_PROTOCOL + link);
    }

    return parsedUrl;
  } catch (error) {
    _loggerProxy2.default.logger.warn('MeetingInfoUtil->getParsedUrl#unable to parse the URL, error: ' + error);

    return null;
  }
};

/**
 * Helper function to check if a string matches a known meeting link pattern
 * @param {String} value  string to parse and see if it matches a meeting link
 * @returns {Boolean}
 */
MeetingInfoUtil.isMeetingLink = function (value) {
  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);
  var hostNameBool = parsedUrl.hostname && parsedUrl.hostname.includes(_constants.WEBEX_DOT_COM);
  var pathNameBool = parsedUrl.pathname && (parsedUrl.pathname.includes('/' + _constants.MEET) || parsedUrl.pathname.includes('/' + _constants.MEET_M) || parsedUrl.pathname.includes('/' + _constants.JOIN));

  return hostNameBool && pathNameBool;
};

MeetingInfoUtil.isConversationUrl = function (value, webex) {
  var clusterId = webex.internal.services.getClusterId(value);

  if (clusterId) {
    return clusterId.endsWith(_constants.CONVERSATION_SERVICE);
  }

  return false;
};

MeetingInfoUtil.convertLinkToSip = function (value) {
  var parsedUrl = MeetingInfoUtil.getParsedUrl(value);

  if (!parsedUrl) {
    return null;
  }
  var user = void 0;

  if (parsedUrl.pathname) {
    var userIndex = parsedUrl.pathname.lastIndexOf('/');

    user = parsedUrl.pathname.substring(userIndex + 1);
  }
  if (!user) {
    return null;
  }
  var company = void 0;

  if (parsedUrl.hostname) {
    var companyIndex = parsedUrl.hostname.lastIndexOf('.' + _constants.WEBEX_DOT_COM);

    company = parsedUrl.hostname.substring(0, companyIndex).replace(_constants.WWW_DOT, '');
  }
  if (!company) {
    return null;
  }

  return user + '@' + company + '.' + _constants.WEBEX_DOT_COM;
};

MeetingInfoUtil.isSipUri = function (sipString) {
  // TODO: lets remove regex from this equation and user URI matchers and such
  // have not found a great sip uri parser library as of now
  var sipUri = _constants.DIALER_REGEX.SIP_ADDRESS.exec(sipString);

  return sipUri;
};

MeetingInfoUtil.isPhoneNumber = function (phoneNumber) {
  var isValidNumber = _constants.DIALER_REGEX.PHONE_NUMBER.test(phoneNumber);

  return isValidNumber;
};

MeetingInfoUtil.getHydraId = function (destination) {
  var decodedDestination = (0, _common.deconstructHydraId)(destination);

  if (decodedDestination && _constants.UUID_REG.test(decodedDestination.id)) {
    if (decodedDestination.type === _constants._ROOM_) {
      return { room: true, destination: decodedDestination.id };
    }
    if (decodedDestination.type === _constants._PEOPLE_) {
      return { people: true, destination: decodedDestination.id };
    }

    return {};
  }

  return {};
};

MeetingInfoUtil.getSipUriFromHydraPersonId = function (destination, webex) {
  return webex.people.get(destination).then(function (res) {
    if (res.emails && res.emails.length) {
      return res.emails[0];
    }
    throw new _parameter2.default('Hydra Id Lookup was an invalid hydra person id.');
  }).catch(function (err) {
    throw err;
  });
};

MeetingInfoUtil.generateOptions = function () {
  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(from) {
    var destination, type, webex, options, hydraId, convoUrl;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            destination = from.destination, type = from.type, webex = from.webex;

            if (!type) {
              _context.next = 3;
              break;
            }

            return _context.abrupt('return', {
              destination: destination,
              type: type
            });

          case 3:
            options = {};
            hydraId = MeetingInfoUtil.getHydraId(destination);

            if (!MeetingInfoUtil.isMeetingLink(destination)) {
              _context.next = 10;
              break;
            }

            options.type = _constants._MEETING_LINK_;
            options.destination = destination;
            _context.next = 39;
            break;

          case 10:
            if (!MeetingInfoUtil.isSipUri(destination)) {
              _context.next = 15;
              break;
            }

            options.type = _constants._SIP_URI_;
            options.destination = destination;
            _context.next = 39;
            break;

          case 15:
            if (!MeetingInfoUtil.isPhoneNumber(destination)) {
              _context.next = 20;
              break;
            }

            options.type = _constants._SIP_URI_;
            options.destination = destination;
            _context.next = 39;
            break;

          case 20:
            if (!MeetingInfoUtil.isConversationUrl(destination, webex)) {
              _context.next = 25;
              break;
            }

            options.type = _constants._CONVERSATION_URL_;
            options.destination = destination;
            _context.next = 39;
            break;

          case 25:
            if (!hydraId.people) {
              _context.next = 30;
              break;
            }

            options.type = _constants._SIP_URI_;

            return _context.abrupt('return', MeetingInfoUtil.getSipUriFromHydraPersonId(hydraId.destination, webex).then(function (res) {
              options.destination = res;

              return _promise2.default.resolve(options);
            }));

          case 30:
            if (!hydraId.room) {
              _context.next = 38;
              break;
            }

            options.type = _constants._CONVERSATION_URL_;
            _context.next = 34;
            return webex.internal.services.waitForCatalog('postauth');

          case 34:
            convoUrl = webex.internal.services.get('conversation') + '/' + _constants.CONVERSATIONS + '/' + hydraId.destination;


            options.destination = convoUrl;
            _context.next = 39;
            break;

          case 38:
            throw new _parameter2.default('MeetingInfo is fetched with meeting link, sip uri, phone number, hydra room id, hydra people id, or a conversation url.');

          case 39:
            return _context.abrupt('return', _promise2.default.resolve(options));

          case 40:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Helper function to build up a correct locus url depending on the value passed
 * @param {String} type One of [SIP_URI, PERSONAL_ROOM, MEETING_ID, CONVERSATION_URL, LOCUS_ID, MEETING_LINK]
 * @param {Object} value ?? value.value
 * @returns {Object} returns an object with {resource, method}
 */
MeetingInfoUtil.getResourceUrl = function (type, value) {
  var resource = '/' + _constants.LOCI + '/' + _constants.MEETINGINFO;
  var method = _constants.HTTP_VERBS.GET;

  switch (type) {
    case _constants._SIP_URI_:
    case _constants._PERSONAL_ROOM_:
    case _constants._MEETING_ID_:
      resource = '/' + _constants.LOCI + '/' + _constants.MEETINGINFO + '/' + value + '?' + _constants.TYPE + '=' + type + '&' + _constants.USE_URI_LOOKUP_FALSE;
      break;
    case _constants._CONVERSATION_URL_:
      method = _constants.HTTP_VERBS.PUT;
      break;
    case _constants._LOCUS_ID_:
      resource = '/' + _constants.LOCI + '/' + value + '/' + _constants.MEETINGINFO;
      method = _constants.HTTP_VERBS.PUT;
      break;
    case _constants._MEETING_LINK_:
      resource = '$/' + _constants.LOCI + '/' + _constants.MEETINGINFO + '/' + (0, _btoa2.default)(value) + '?' + _constants.TYPE + '=' + _constants._MEETING_LINK_ + '&' + _constants.USE_URI_LOOKUP_FALSE;
      break;
    default:
  }

  return {
    resource: resource,
    method: method
  };
};

MeetingInfoUtil.getRequestParams = function (resourceOptions, type, value, api) {
  var requestParams = {
    method: resourceOptions.method,
    api: api,
    resource: resourceOptions.resource
  };

  if (resourceOptions.method === _constants.HTTP_VERBS.GET) {
    // for handling URL redirections
    requestParams.resource = requestParams.resource.concat('&' + _constants.ALTERNATE_REDIRECT_TRUE);
  } else if (type !== _constants._LOCUS_ID_) {
    // locus id check is a PUT not sure why
    requestParams.resource = requestParams.resource.concat('?' + _constants.ALTERNATE_REDIRECT_TRUE);
    requestParams.body = {
      value: value,
      lookupType: type
    };
  }

  return requestParams;
};

MeetingInfoUtil.getMeetingInfoAPIFormat = function (options) {
  return {
    type: options.type,
    value: options.destination
  };
};

exports.default = MeetingInfoUtil;
//# sourceMappingURL=util.js.map
