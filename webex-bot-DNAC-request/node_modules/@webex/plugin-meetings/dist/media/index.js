'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _bowser = require('bowser');

var _bowser2 = _interopRequireDefault(_bowser);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

var _reconnection = require('../common/errors/reconnection');

var _reconnection2 = _interopRequireDefault(_reconnection);

var _media = require('../common/errors/media');

var _media2 = _interopRequireDefault(_media);

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * MediaDirection
 * @typedef {Object} MediaDirection
 * @property {boolean} sendAudio
 * @property {boolean} receiveAudio
 * @property {boolean} sendVideo
 * @property {boolean} receiveVideo
 * @property {boolean} sendShare
 * @property {boolean} receiveShare
 */

/**
 * SendOptions
 * @typedef {Object} SendOptions
 * @property sendAudio
 * @property sendVideo
 * @property sendShare
 * @property {Object} sharePreferences
 */
/**
 *
 * @public
 * @export
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 */
var Media = {};

/**
 * @param {boolean} enabled
 * @param {MediaStreamTrack} track
 * @returns {Boolean}
 * @public
 */
/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */
/* globals navigator */
Media.setLocalTrack = function (enabled, track) {
  if (track) {
    track.enabled = !enabled;

    return true;
  }

  return false;
};

/**
 * @param {RTCPeerConnection} peerConnection
 * @param {String} meetingId
 * @returns {Promise}
 */
Media.reconnectMedia = function (peerConnection, meetingId) {
  if (peerConnection.connectionState === _constants.PEER_CONNECTION_STATE.CLOSED || peerConnection.connectionState === _constants.PEER_CONNECTION_STATE.FAILED) {
    return _promise2.default.reject(new _reconnection2.default('Reinitiate peerconnection'));
  }

  return _peerConnectionManager2.default.createOffer(peerConnection, meetingId);
};

/**
 * format the media array for send
 * @param {String} mediaId
 * @param {Boolean} audioMuted
 * @param {Boolean} videoMuted
 * @returns {Array} medias
 */
Media.generateLocalMedias = function (mediaId, audioMuted, videoMuted) {
  if (mediaId) {
    return [{
      localSdp: (0, _stringify2.default)({
        audioMuted: audioMuted,
        videoMuted: videoMuted
      }),
      mediaId: mediaId
    }];
  }

  return [];
};

/**
 * make a browser call to get the media
 * @param {SendOptions} options
 * @returns {Promise}
 */
Media.getLocalMedia = function (options) {
  var sendAudio = options.sendAudio,
      sendVideo = options.sendVideo,
      sendShare = options.sendShare,
      sharePreferences = options.sharePreferences;


  if (sendAudio || sendVideo) {
    return Media.getMedia(sendAudio, sendVideo);
  }

  if (sendShare) {
    return Media.getDisplayMedia({
      sendAudio: false,
      sendShare: true,
      sharePreferences: sharePreferences
    });
  }

  return _promise2.default.resolve(undefined);
};
/**
 * Returns the direction and tracks
 * @param {string} trackType type of track (audio/video)
 * @param {object}  track  tracks passed
 * @param {boolean} receiveTracks do you want to receive tracks from the remote side
 * @returns {Object} returns direction tracks to be added in transceiver
 */
Media.checkTracks = function (trackType, track, receiveTracks) {
  var getDirection = function getDirection(sendTracks, receiveTracks) {
    if (sendTracks && receiveTracks) {
      return 'sendrecv';
    }if (sendTracks && !receiveTracks) {
      return 'sendonly';
    }if (!sendTracks && receiveTracks) {
      return 'recvonly';
    }if (sendTracks && receiveTracks) {
      return 'inactive';
    }

    return 'inactive';
  };

  if (track) {
    return { track: track, direction: getDirection(!!track, receiveTracks) };
  }

  return { track: trackType, direction: getDirection(!!track, receiveTracks) };
};
/**
 * creates peerconnection and attaches streams
 * @param {MediaDirection} mediaProperties
 * @param {Object} meetingId call flow id
 * @returns {Array} [peerConnection, ]
 */
Media.attachMedia = function (mediaProperties, meetingId) {
  var mediaDirection = mediaProperties.mediaDirection,
      audioTrack = mediaProperties.audioTrack,
      videoTrack = mediaProperties.videoTrack,
      shareTrack = mediaProperties.shareTrack,
      peerConnection = mediaProperties.peerConnection;


  var result = null;

  // Add Transceiver for audio
  result = Media.checkTracks('audio', mediaDirection.sendAudio && audioTrack, mediaDirection.receiveAudio);
  peerConnection.audioTransceiver = peerConnection.addTransceiver(result.track, { direction: result.direction });

  // Add Transceiver for video
  result = Media.checkTracks('video', mediaDirection.sendVideo && videoTrack, mediaDirection.receiveVideo);
  peerConnection.videoTransceiver = peerConnection.addTransceiver(result.track, { direction: result.direction });

  // Add Transceiver for share
  result = Media.checkTracks('video', mediaDirection.sendShare && shareTrack, mediaDirection.receiveShare);
  peerConnection.shareTransceiver = peerConnection.addTransceiver(result.track, { direction: result.direction });

  peerConnection.onnegotiationneeded = function (event) {
    _loggerProxy2.default.logger.info('Media->attachMedia/onnegotiationneeded#PeerConnection: ' + event);
  };

  return _peerConnectionManager2.default.createOffer(peerConnection, meetingId);
};

/**
 * updates all the media streams and creates a new media offer
 * @param {MediaDirection} mediaProperties
 * @param {String} meetingId
 * @returns {Promise}
 */
Media.updateMedia = function (mediaProperties, meetingId) {
  var mediaDirection = mediaProperties.mediaDirection,
      audioTrack = mediaProperties.audioTrack,
      videoTrack = mediaProperties.videoTrack,
      shareTrack = mediaProperties.shareTrack,
      peerConnection = mediaProperties.peerConnection;

  // update audio transceiver

  Media.setTrackOnTransceiver(peerConnection.audioTransceiver, {
    type: 'audio',
    track: audioTrack,
    sendTrack: mediaDirection.sendAudio && audioTrack,
    receiveTrack: mediaDirection.receiveAudio
  });

  // update video transceiver
  Media.setTrackOnTransceiver(peerConnection.videoTransceiver, {
    type: 'video',
    track: videoTrack,
    sendTrack: mediaDirection.sendVideo && videoTrack,
    receiveTrack: mediaDirection.receiveVideo
  });

  // update content transceiver
  Media.setTrackOnTransceiver(peerConnection.shareTransceiver, {
    type: 'video',
    track: shareTrack,
    sendTrack: mediaDirection.sendShare && shareTrack,
    receiveTrack: mediaDirection.receiveShare
  });
  peerConnection.onnegotiationneeded = function (event) {
    _loggerProxy2.default.logger.info('Media->attachMedia/onnegotiationneeded#PeerConnection: ' + event);
  };

  return _peerConnectionManager2.default.createOffer(peerConnection, meetingId);
};

/**
 * @param {RTCRtpTransceiver} transceiver
 * @param {Object} options
 * @param {MediaStreamTrack} options.track
 * @returns {undefined}
 */
Media.setTrackOnTransceiver = function (transceiver, options) {
  var type = options.type,
      track = options.track,
      sendTrack = options.sendTrack,
      receiveTrack = options.receiveTrack;


  try {
    var result = Media.checkTracks(type, sendTrack && track, receiveTrack);

    transceiver.direction = result.direction;
    if (options.track) {
      transceiver.sender.replaceTrack(track);
    }
  } catch (e) {
    throw e;
  }
};

/**
 * creates a new offer
 * @param {String} meetingId
 * @param {RTCPeerConnection} peerConnection
 * @param {RTCRtpTransceiver} transceiver
 * @param {Object} options see #Media.setTrackOnTransceiver
 * @returns {Promise}
 */
Media.updateTransceiver = function (meetingId, peerConnection, transceiver, options) {
  Media.setTrackOnTransceiver(transceiver, options);

  return _peerConnectionManager2.default.createOffer(peerConnection, meetingId);
};

/**
 * generates share streams
 * @param {object} options parameter
 * @param {Object} options.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} options.sendShare sendShare: {Boolean} sendShare constraints
 * @param {Object} options.sharePreferences sharePreferences: {Object} Share constraints and share constraints
 * @returns {Object} {streams}
 */
Media.getDisplayMedia = function (options) {
  var shareConstraints = options.sharePreferences && options.sharePreferences.shareConstraints || {
    cursor: 'always',
    frameRate: options.sharePreferences && options.sharePreferences.highFrameRate ? _config2.default.meetings.videoShareFrameRate : _config2.default.meetings.screenFrameRate,
    aspectRatio: _config2.default.meetings.aspectRatio,
    width: options.sharePreferences && options.sharePreferences.highFrameRate ? _config2.default.meetings.resolution.idealWidth : _config2.default.meetings.screenResolution.idealWidth,
    height: options.sharePreferences && options.sharePreferences.highFrameRate ? _config2.default.meetings.resolution.idealHeight : _config2.default.meetings.screenResolution.idealHeight
  };
  // chrome and webkit based browsers (edge, safari) automatically adjust everything
  // and we have noticed higher quality with those browser types
  // firefox specifically has some issues with resolution and frame rate decision making
  // so we are making it optional and configurable (with defaults) for firefox
  // to have higher quality, and for developers to control the values
  // eventually we may have to add the same functionality to chrome, OR conversely, get to with firefox


  if (_bowser2.default.name.toLowerCase() === 'firefox') {
    var mediaConfig = {
      audio: options.sendAudio,
      video: options.sendShare
    };

    return navigator.mediaDevices.getDisplayMedia({ audio: options.sendAudio, video: mediaConfig }).then(function (stream) {
      if (options.sendShare && stream.getVideoTracks().length > 0) {
        // Firefox has a bug with the spec where changing in the height and width only happens
        // after we get the inital tracks
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1321221
        stream.getVideoTracks()[0].applyConstraints(shareConstraints);
      }

      return stream;
    });
  }

  return navigator.mediaDevices.getDisplayMedia({ audio: options.sendAudio, video: options.sendShare ? shareConstraints : false });
};

/**
 * generates audio and video using constraints (often called after getSupportedDevices)
 * @param {Object} audio audio: {Boolean} gum constraints
 * @param {Object} video video: {Boolean} gum constraints
 * @returns {Object} {streams}
 */
Media.getMedia = function (audio, video) {
  var mediaConfig = {
    audio: audio,
    video: video ? {
      deviceId: video.deviceId ? video.deviceId : undefined,
      width: { ideal: _config2.default.meetings.resolution.idealWidth, max: _config2.default.meetings.resolution.maxWidth },
      height: { ideal: _config2.default.meetings.resolution.idealHeight, max: _config2.default.meetings.resolution.maxHeight }
    } : false,
    fake: process.env.NODE_ENV === 'test' // Special case to get fake media for Firefox browser for testing
  };

  return new _promise2.default(function (resolve, reject) {
    navigator.mediaDevices.getUserMedia(mediaConfig).then(function (stream) {
      resolve(stream);
    }).catch(function (err) {
      reject(new _media2.default(new Error({
        name: err.name,
        localMediaFailed: true,
        cameraFailed: err === mediaConfig.permissionDenied
      }), 'Local Get User Media failed'));
    });
  });
};

/**
 * Checks if the machine has at least one audio or video device (Dont use this for screen share)
 * @param {object} [options]
 * {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 * }
 * @returns {Object} {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 *}
 */
Media.getSupportedDevice = function (_ref) {
  var sendAudio = _ref.sendAudio,
      sendVideo = _ref.sendVideo;
  return _promise2.default.resolve().then(function () {
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return {
        sendAudio: true,
        sendVideo: true
      };
    }

    return navigator.mediaDevices.enumerateDevices().then(function (devices) {
      var supported = {
        audio: devices.filter(function (device) {
          return device.kind === _constants.AUDIO_INPUT;
        }).length > 0,
        video: devices.filter(function (device) {
          return device.kind === _constants.VIDEO_INPUT;
        }).length > 0
      };

      return {
        sendAudio: supported.audio && sendAudio || true,
        sendVideo: supported.video && sendVideo || true
      };
    });
  });
};

/**
 * proxy to browser navigator.mediaDevices.enumerateDevices()
 * @returns {Promise}
 */
Media.getDevices = function () {
  if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
    return navigator.mediaDevices.enumerateDevices();
  }

  return _promise2.default.reject(new _media2.default('enumerateDevices not supported.'));
};

/**
 *
 * Toggle a specific stream
 * noop as of now, does nothing
 * @returns {null}
 */
Media.toggleStream = function () {};

/**
 * Stop input stream
 * @param {MediaTrack} track A media stream
 * @returns {null}
 */
Media.stopTracks = function (track) {
  if (!track) {
    return _promise2.default.resolve();
  }

  return _promise2.default.resolve().then(function () {
    if (track && track.stop) {
      try {
        track.stop();
      } catch (e) {
        _loggerProxy2.default.logger.error('media/index->stopTracks#Unable to stop the track with state ' + track.readyState + ', error: ' + e);
      }
    }
  });
};

/**
 *
 * Stop input stream
 * @param {Stream} stream A media stream
 * @returns {null}
 */
Media.stopStream = function (stream) {
  if (!stream) {
    return _promise2.default.resolve();
  }

  /*
   * To release local media
   * 1) Chrome requires all tracks to be stopped (stream.stop got deprecated)
   * 2) Firefox requires the stream to be stopped
   */
  return _promise2.default.resolve().then(function () {
    if (stream.getTracks) {
      stream.getTracks().forEach(function (track) {
        track.stop();
      });
    } else if (stream.stop) {
      stream.stop();
    }
  });
};

/**
 * generates streams for audio video and share
 * @param {object} mediaSetting parameter
 * @param {Object} mediaSetting.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} mediaSetting.sendVideo sendVideo: {Boolean} sendVideo constraints
 * @param {Object} mediaSetting.sendShare sendShare: {Boolean} sendShare constraints
 * @param {Object} audioVideo parameter
 * @param {Object} audioVideo.audio {deviceId: {String}}
 * @param {Object} audioVideo.video {deviceId: {String}}
 * @param {Object} sharePreferences parameter
 * @param {Object} sharePreferences.shareConstraints parameter
 * @param {Boolean} sharePreferences.highFrameRate parameter
 * @returns {Array} [localStream, shareStream]
 */
Media.getUserMedia = function (mediaSetting, audioVideo, sharePreferences) {
  return Media.getLocalMedia({
    sendAudio: mediaSetting.sendAudio ? audioVideo.audio || mediaSetting.sendAudio : false,
    sendVideo: mediaSetting.sendVideo ? audioVideo.video || mediaSetting.sendVideo : false
  }).then(function (localStream) {
    return Media.getLocalMedia({
      sendShare: mediaSetting.sendShare,
      sharePreferences: sharePreferences
    }).then(function (shareStream) {
      return [localStream, shareStream];
    });
  });
};

exports.default = Media;
//# sourceMappingURL=index.js.map
