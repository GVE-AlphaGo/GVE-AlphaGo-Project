'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isFinite2 = require('lodash/isFinite');

var _isFinite3 = _interopRequireDefault(_isFinite2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StatsCalculator = {};

/**
 * Calculate an interval of values between 2 data points, using updated as the "latest" so updated - previous = interval
 * @param {WebRTCData} previous
 * @param {WebRTCData} updated
 * @returns {Object} interval: {StringKey: IntervalValue, ..., n}
 * @public
 */
StatsCalculator.difference = function (previous, updated) {
  // if there was no previous, just take the updated
  if (!previous || !previous.data || !previous.data.getData || (0, _keys3.default)(previous.data.getData()).length === 0) {
    return updated;
  }
  var interval = {};

  // get inside the data from the filtered report
  (0, _keys3.default)(updated.data.getData()).forEach(function (key) {
    interval[key] = interval[key] ? interval[key] : {};
    (0, _keys3.default)(updated.data.getData()[key]).forEach(function (stat) {
      var value = updated.data.getData()[key][stat];

      // only use some simple data points that are numbers and aren't silly things like timestamp
      if ((0, _isFinite3.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {
        // if there was nothing there before, just return the updated data
        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {
          interval[key][stat] = value;
        }
        // subract and store
        else {
            value -= previous.data.getData()[key][stat];
            interval[key][stat] = value;
          }
      }
    });
  });

  return interval;
};

/**
 * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data
 * @param {WebRTCData} data
 * @param {Object} summary
 * @returns {Object} aggregate {StringKey: SummedValue, ..., n}
 * @public
 */
StatsCalculator.sum = function (data, summary) {
  var aggregate = summary;

  // get inside the data from the filtered report
  (0, _keys3.default)(data.data.getData()).forEach(function (key) {
    (0, _keys3.default)(data.data.getData()[key]).forEach(function (stat) {
      var value = data.data.getData()[key][stat];

      // only use some simple data points that are numbers and aren't silly things like timestamp
      if ((0, _isFinite3.default)(value) && !(_constants.DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {
        // if there was something there before, add to that value
        if (aggregate[key][stat]) {
          aggregate[key][stat] += value;
        }
        // set up the value as the new data point
        else {
            aggregate[key][stat] = value;
          }
      }
    });
  });

  return aggregate;
};

exports.default = StatsCalculator;
//# sourceMappingURL=calculator.js.map
