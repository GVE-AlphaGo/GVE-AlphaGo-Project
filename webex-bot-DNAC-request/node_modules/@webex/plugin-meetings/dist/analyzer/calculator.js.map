{"version":3,"sources":["calculator.js"],"names":["StatsCalculator","difference","previous","updated","data","getData","length","interval","forEach","key","stat","value","DEFAULT_EXCLUDED_STATS","includes","sum","summary","aggregate"],"mappings":";;;;;;;;;;;;;;AAEA;;;;AAEA,IAAMA,kBAAkB,EAAxB;;AAEA;;;;;;;AAOAA,gBAAgBC,UAAhB,GAA6B,UAACC,QAAD,EAAWC,OAAX,EAAuB;AAClD;AACA,MAAI,CAACD,QAAD,IAAa,CAACA,SAASE,IAAvB,IAA+B,CAACF,SAASE,IAAT,CAAcC,OAA9C,IAAyD,oBAAKH,SAASE,IAAT,CAAcC,OAAd,EAAL,EAA8BC,MAA9B,KAAyC,CAAtG,EAAyG;AACvG,WAAOH,OAAP;AACD;AACD,MAAMI,WAAW,EAAjB;;AAEA;AACA,sBAAKJ,QAAQC,IAAR,CAAaC,OAAb,EAAL,EAA6BG,OAA7B,CAAqC,UAACC,GAAD,EAAS;AAC5CF,aAASE,GAAT,IAAgBF,SAASE,GAAT,IAAgBF,SAASE,GAAT,CAAhB,GAAgC,EAAhD;AACA,wBAAKN,QAAQC,IAAR,CAAaC,OAAb,GAAuBI,GAAvB,CAAL,EAAkCD,OAAlC,CAA0C,UAACE,IAAD,EAAU;AAClD,UAAIC,QAAQR,QAAQC,IAAR,CAAaC,OAAb,GAAuBI,GAAvB,EAA4BC,IAA5B,CAAZ;;AAEA;AACA,UAAI,wBAASC,KAAT,KAAmB,EAAEC,kCAAuBC,QAAvB,CAAgCH,IAAhC,KAAyCC,UAAU,CAArD,CAAvB,EAAgF;AAC9E;AACA,YAAI,CAACT,SAASE,IAAT,CAAcC,OAAd,GAAwBI,GAAxB,CAAD,IAAiC,CAACP,SAASE,IAAT,CAAcC,OAAd,GAAwBI,GAAxB,EAA6BC,IAA7B,CAAtC,EAA0E;AACxEH,mBAASE,GAAT,EAAcC,IAAd,IAAsBC,KAAtB;AACD;AACD;AAHA,aAIK;AACHA,qBAAST,SAASE,IAAT,CAAcC,OAAd,GAAwBI,GAAxB,EAA6BC,IAA7B,CAAT;AACAH,qBAASE,GAAT,EAAcC,IAAd,IAAsBC,KAAtB;AACD;AACF;AACF,KAfD;AAgBD,GAlBD;;AAoBA,SAAOJ,QAAP;AACD,CA7BD;;AA+BA;;;;;;;AAOAP,gBAAgBc,GAAhB,GAAsB,UAACV,IAAD,EAAOW,OAAP,EAAmB;AACvC,MAAMC,YAAYD,OAAlB;;AAEA;AACA,sBAAKX,KAAKA,IAAL,CAAUC,OAAV,EAAL,EAA0BG,OAA1B,CAAkC,UAACC,GAAD,EAAS;AACzC,wBAAKL,KAAKA,IAAL,CAAUC,OAAV,GAAoBI,GAApB,CAAL,EAA+BD,OAA/B,CAAuC,UAACE,IAAD,EAAU;AAC/C,UAAMC,QAAQP,KAAKA,IAAL,CAAUC,OAAV,GAAoBI,GAApB,EAAyBC,IAAzB,CAAd;;AAEA;AACA,UAAI,wBAASC,KAAT,KAAmB,EAAEC,kCAAuBC,QAAvB,CAAgCH,IAAhC,KAAyCC,UAAU,CAArD,CAAvB,EAAgF;AAC9E;AACA,YAAIK,UAAUP,GAAV,EAAeC,IAAf,CAAJ,EAA0B;AACxBM,oBAAUP,GAAV,EAAeC,IAAf,KAAwBC,KAAxB;AACD;AACD;AAHA,aAIK;AACHK,sBAAUP,GAAV,EAAeC,IAAf,IAAuBC,KAAvB;AACD;AACF;AACF,KAdD;AAeD,GAhBD;;AAkBA,SAAOK,SAAP;AACD,CAvBD;;kBAyBehB,e","file":"calculator.js","sourcesContent":["import {keys, isFinite} from 'lodash';\n\nimport {DEFAULT_EXCLUDED_STATS} from '../constants';\n\nconst StatsCalculator = {};\n\n/**\n * Calculate an interval of values between 2 data points, using updated as the \"latest\" so updated - previous = interval\n * @param {WebRTCData} previous\n * @param {WebRTCData} updated\n * @returns {Object} interval: {StringKey: IntervalValue, ..., n}\n * @public\n */\nStatsCalculator.difference = (previous, updated) => {\n  // if there was no previous, just take the updated\n  if (!previous || !previous.data || !previous.data.getData || keys(previous.data.getData()).length === 0) {\n    return updated;\n  }\n  const interval = {};\n\n  // get inside the data from the filtered report\n  keys(updated.data.getData()).forEach((key) => {\n    interval[key] = interval[key] ? interval[key] : {};\n    keys(updated.data.getData()[key]).forEach((stat) => {\n      let value = updated.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was nothing there before, just return the updated data\n        if (!previous.data.getData()[key] || !previous.data.getData()[key][stat]) {\n          interval[key][stat] = value;\n        }\n        // subract and store\n        else {\n          value -= previous.data.getData()[key][stat];\n          interval[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return interval;\n};\n\n/**\n * Calculate an aggregate of values between an old summary and a new data point, using summary as the base to add to so aggregate = summary + data\n * @param {WebRTCData} data\n * @param {Object} summary\n * @returns {Object} aggregate {StringKey: SummedValue, ..., n}\n * @public\n */\nStatsCalculator.sum = (data, summary) => {\n  const aggregate = summary;\n\n  // get inside the data from the filtered report\n  keys(data.data.getData()).forEach((key) => {\n    keys(data.data.getData()[key]).forEach((stat) => {\n      const value = data.data.getData()[key][stat];\n\n      // only use some simple data points that are numbers and aren't silly things like timestamp\n      if (isFinite(value) && !(DEFAULT_EXCLUDED_STATS.includes(stat) && value !== 0)) {\n        // if there was something there before, add to that value\n        if (aggregate[key][stat]) {\n          aggregate[key][stat] += value;\n        }\n        // set up the value as the new data point\n        else {\n          aggregate[key][stat] = value;\n        }\n      }\n    });\n  });\n\n  return aggregate;\n};\n\nexport default StatsCalculator;\n"]}