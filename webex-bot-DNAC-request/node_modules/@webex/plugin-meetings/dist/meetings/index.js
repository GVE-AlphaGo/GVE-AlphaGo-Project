'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

require('@webex/internal-plugin-mercury');

var _webexCore = require('@webex/webex-core');

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

var _config = require('../metrics/config');

var _loggerConfig = require('../common/logs/logger-config');

var _loggerConfig2 = _interopRequireDefault(_loggerConfig);

var _config2 = require('../common/config');

var _config3 = _interopRequireDefault(_config2);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _triggerProxy = require('../common/events/trigger-proxy');

var _triggerProxy2 = _interopRequireDefault(_triggerProxy);

var _constants = require('../constants');

var _meetingInfo = require('../meeting-info');

var _meetingInfo2 = _interopRequireDefault(_meetingInfo);

var _meeting = require('../meeting');

var _meeting2 = _interopRequireDefault(_meeting);

var _personalMeetingRoom = require('../personal-meeting-room');

var _personalMeetingRoom2 = _interopRequireDefault(_personalMeetingRoom);

var _reachability = require('../reachability');

var _reachability2 = _interopRequireDefault(_reachability);

var _request = require('../meetings/request');

var _request2 = _interopRequireDefault(_request);

var _analyzer = require('../analyzer/analyzer');

var _analyzer2 = _interopRequireDefault(_analyzer);

var _calculator = require('../analyzer/calculator');

var _calculator2 = _interopRequireDefault(_calculator);

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
   * Meetings Ready Event
   * Emitted when the meetings instance on webex is ready
   * @event meetings:ready
   * @instance
   * @memberof Meetings
   */

/**
 * Meetings Registered Event
 * Emitted when the meetings instance has been registered and listening
 * @event meetings:registered
 * @instance
 * @memberof Meetings
 */

/**
    * Meeting Removed Event
    * Emitted when a meeting was removed from the cache of meetings
    * @event meeting:removed
    * @instance
    * @type {Object}
    * @property {String} meetingId the removed meeting
    * @property {Object} response the server response
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
    * Meeting Added Event
    * Emitted when a meeting was added to the cache of meetings
    * @event meeting:added
    * @instance
    * @type {Object}
    * @property {String} meetingId the added meeting
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
   * Maintain a cache of meetings and sync with services.
   * @class
   */
/*!
  * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
*/

var Meetings = function (_WebexPlugin) {
  (0, _inherits3.default)(Meetings, _WebexPlugin);

  /**
   * Initializes the Meetings Plugin
   * @constructor
   * @public
   * @memberof Meetings
   */
  function Meetings() {
    var _ref;

    (0, _classCallCheck3.default)(this, Meetings);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /**
     * The MeetingInfo object to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = Meetings.__proto__ || (0, _getPrototypeOf2.default)(Meetings)).call.apply(_ref, [this].concat(args)));

    _this.namespace = _constants.MEETINGS;
    _this.meetingInfo = new _meetingInfo2.default({}, { parent: _this.webex });
    /**
     * The Meetings request to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    _this.request = new _request2.default({}, { parent: _this.webex });
    _this.meetingCollection = new _collection2.default();
    /**
     * The PersonalMeetingRoom object to interact with server
     * @instance
     * @type {Object}
     * @public
     * @memberof Meetings
     */
    _this.personalMeetingRoom = new _personalMeetingRoom2.default({}, { parent: _this.webex });
    /**
     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called
     * starts as null
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    _this.reachability = null;

    /**
     * If the meetings plugin has been registered and listening via {@link Meetings#register}
     * @instance
     * @type {Boolean}
     * @public
     * @memberof Meetings
     */
    _this.registered = false;

    _this.onReady();
    _metrics2.default.initialSetup(_this.meetingCollection, _this.webex.version);
    return _this;
  }

  /**
   * handle locus events and takes meeting actions with them as they come in
   * @param {Object} data a locus event
   * @param {String} data.locusUrl
   * @param {Object} data.locus
   * @param {String} data.eventType
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */


  (0, _createClass3.default)(Meetings, [{
    key: 'handleLocusEvent',
    value: function handleLocusEvent(data) {
      var _this2 = this;

      var meeting = null;

      // getting meeting by correlationId. This will happen for the new event
      // Either the locus
      // TODO : Add check for the callBack Address
      meeting = this.meetingCollection.getByKey(_constants.LOCUS_URL, data.locusUrl) || this.meetingCollection.getByKey(_constants.CORRELATION_ID, _util2.default.checkForCorrelationId(this.webex.internal.device.url, data.locus)) || this.meetingCollection.getByKey(_constants.SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress);

      if (!meeting) {
        // TODO: create meeting when we get a meeting object
        // const checkForEnded = (locus) => {
        // TODO: you already ended the meeting but you got an event later
        // Mainly for 1:1 Callsor meeting
        // Happens mainly after refresh

        // 1:1 Meeting
        // 1)  You ended a call before but you got a mercury event
        // Make sure end the call and cleanup the meeting only if the mercury
        // event says so
        // 2) Maintain lastSync time in the meetings object which helps to compare
        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid

        // For space Meeting
        // Check the locus object and see who has joined

        // };
        // rather then locus object change to locus url

        if (data.locus && data.locus.fullState && data.locus.fullState.state === _constants.LOCUS.STATE.INACTIVE) {
          // just ignore the event as its already ended and not active
          _loggerProxy2.default.logger.warn('Meetings->handleLocusEvent#Locus event received for meeting, after it was ended.');

          return;
        }

        // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object
        // Any future events will be neglected

        if (data.locus && data.locus.self && data.locus.self.state === _constants._LEFT_ && data.locus.self.removed === true) {
          // just ignore the event as its already ended and not active
          _loggerProxy2.default.logger.warn('Meetings->handleLocusEvent#Locus event received for meeting, after it was ended.');

          return;
        }

        this.create(data.locus, _constants._LOCUS_ID_).then(function (newMeeting) {
          meeting = newMeeting;

          if (data.eventType === _constants.LOCUSEVENT.DIFFERENCE) {
            // its a delta object and we have a new meeting
            meeting.locusInfo.initialSetup(data.locus, meeting);
          } else {
            // Its a new meeting and have a fresh locus object
            meeting.locusInfo.initialSetup(data.locus);
          }
        }).finally(function () {
          // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted
          // because the other user left so before sending 'added' event make sure it exists in the collection

          if (_this2.getMeetingByType(_constants._ID_, meeting.id)) {
            // Had to put `meeting:added here as the parsing of the locus object is done here
            _metrics2.default.postEvent({ event: _config.eventType.NOTIFICATION_RECEIVED, meeting: meeting, data: { trigger: _config.trigger.MERCURY_EVENT } });

            _metrics2.default.postEvent({ event: _config.eventType.REMOTE_STARTED, meeting: meeting, data: { trigger: _config.trigger.MERCURY_EVENT } });
            _triggerProxy2.default.trigger(_this2, {
              file: 'meetings',
              function: 'handleLocusEvent'
            }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
              meeting: meeting,
              type: meeting.type === _constants._MEETING_ ? _constants._JOIN_ : _constants._INCOMING_
            });
          } else {
            // Meeting got added but was not found in the collection. It might have got destroyed
            _loggerProxy2.default.logger.warn('Meetings->handleLocusEvent#Created and destroyed meeting object before sending an event');
          }
        });
      } else {
        _metrics2.default.postEvent({ event: _config.eventType.NOTIFICATION_RECEIVED, meeting: meeting, data: { trigger: _config.trigger.MERCURY_EVENT } });
        meeting.locusInfo.parse(meeting, data);
      }
    }

    /**
     * handles locus events through mercury that are not roap
     * @param {Object} envelope
     * @param {Object} envelope.data
     * @param {String} envelope.data.eventType
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'handleLocusMercury',
    value: function handleLocusMercury(envelope) {
      var data = envelope.data;
      var eventType = data.eventType;


      if (eventType && eventType !== _constants.LOCUSEVENT.MESSAGE_ROAP) {
        this.handleLocusEvent(data);
      }
    }

    /**
     * registers for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'listenForEvents',
    value: function listenForEvents() {
      var _this3 = this;

      this.webex.internal.mercury.on(_constants.LOCUSEVENT.LOCUS_MERCURY, function (envelope) {
        _this3.handleLocusMercury(envelope);
      });
      this.webex.internal.mercury.on(_constants.ROAP.ROAP_MERCURY, function (envelope) {
        _util2.default.handleRoapMercury(envelope, _this3.meetingCollection);
      });
    }

    /**
     * stops listening for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'stopListeningForEvents',
    value: function stopListeningForEvents() {
      this.webex.internal.mercury.off(_constants.LOCUSEVENT.LOCUS_MERCURY);
      this.webex.internal.mercury.off(_constants.ROAP.ROAP_MERCURY);
    }

    /**
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'onReady',
    value: function onReady() {
      var _this4 = this;

      this.webex.once(_constants.READY, function () {
        _config3.default.set(_this4.config);
        _loggerConfig2.default.set(_this4.config.logging);
        _loggerProxy2.default.set(_this4.webex.logger);
        _triggerProxy2.default.trigger(_this4, {
          file: 'meetings',
          function: 'onReady'
        }, _constants.EVENT_TRIGGERS.MEETINGS_READY);
      });
    }

    /**
     * Explicitly sets up the meetings plugin by registering
     * the device, connecting to mercury, and listening for locus events.
     *
     * @returns {Promise}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'register',
    value: function register() {
      var _this5 = this;

      if (!this.webex.canAuthorize) {
        _loggerProxy2.default.logger.error('meetings->register#ERROR, Unable to register, SDK cannot authorize');

        return _promise2.default.reject(new Error('SDK cannot authorize'));
      }

      if (this.registered) {
        _loggerProxy2.default.logger.info('meetings->register#INFO, Meetings plugin already registered');

        return _promise2.default.resolve();
      }

      return this.webex.internal.device.register().then(function () {
        return _this5.webex.internal.mercury.connect();
      }).then(function () {
        _this5.listenForEvents();
        _triggerProxy2.default.trigger(_this5, {
          file: 'meetings',
          function: 'register'
        }, _constants.EVENT_TRIGGERS.MEETINGS_REGISTERED);
        _this5.registered = true;
      }).catch(function (error) {
        _loggerProxy2.default.logger.error('meetings->register#ERROR, Unable to register, ' + error.message);

        return _promise2.default.reject(error);
      });
    }

    /**
     * Explicitly tears down the meetings plugin by deregistering
     * the device, disconnecting from mercury, and stops listening to locus events
     *
     * @returns {Promise}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'unregister',
    value: function unregister() {
      var _this6 = this;

      if (!this.registered) {
        _loggerProxy2.default.logger.info('meetings->unregister#INFO, Meetings plugin already unregistered');

        return _promise2.default.resolve();
      }

      this.stopListeningForEvents();

      return this.webex.internal.mercury.disconnect().then(function () {
        return _this6.webex.internal.device.unregister();
      }).then(function () {
        _triggerProxy2.default.trigger(_this6, {
          file: 'meetings',
          function: 'unregister'
        }, _constants.EVENT_TRIGGERS.MEETINGS_UNREGISTERED);
        _this6.registered = false;
      });
    }

    /**
     * initializes the reachability instance for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'setReachability',
    value: function setReachability() {
      this.reachability = new _reachability2.default({}, { parent: this.webex });
    }

    /**
     * gets the reachability instance for Meetings
     * @returns {Reachability}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getReachability',
    value: function getReachability() {
      return this.reachability;
    }

    /**
     * initializes and starts gathering reachability for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'startReachability',
    value: function startReachability() {
      if (!this.reachability) {
        this.setReachability();
      }
      this.getReachability().gatherReachability();
    }

    /**
     * gets the personal meeting room instance, for saved PMR values for this user
     * @returns {PersonalMeetingRoom}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getPersonalMeetingRoom',
    value: function getPersonalMeetingRoom() {
      return this.personalMeetingRoom;
    }

    /**
     * @param {String} meetingId
     * @param {Object} reason
     * @param {String} type
     * @returns {Undefined}
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'destroy',
    value: function destroy(meetingId, reason) {
      this.meetingCollection.delete(meetingId);
      _triggerProxy2.default.trigger(this, {
        file: 'meetings',
        function: 'destroy'
      }, _constants.EVENT_TRIGGERS.MEETING_REMOVED, {
        meetingId: meetingId,
        reason: reason
      });
    }

    /**
     * Create a meeting.
     * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}
     * @param {string} [type] - the optional specified type, such as locusId
     * @returns {Promise} A new Meeting.
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'create',
    value: function create(destination) {
      var _this7 = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // TODO: type should be from a dictionary
      // Check if there is already meeting
      var meeting = this.meetingCollection.getByKey(_constants.SIP_URI, destination);

      if (!meeting) {
        return this.createMeeting(destination, type).then(function (meeting) {
          if (meeting && meeting.on) {
            meeting.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {
              _this7.destroy(payload.meetingId, payload.reason);
            });
          } else {
            _loggerProxy2.default.logger.error('meetings->create#ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ' + meeting);
          }

          return _promise2.default.resolve(meeting);
        });
      }

      return _promise2.default.resolve(meeting);
    }

    /**
     * @param {String} destination see create()
     * @param {String} type see create()
     * @returns {Promise} a new meeting instance complete with meeting info and destination
     * @private
     * @memberof Meetings
     */

  }, {
    key: 'createMeeting',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(destination) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var meeting, info, meetingAddedType;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                meeting = new _meeting2.default({
                  userId: this.webex.internal.device.userId,
                  deviceUrl: this.webex.internal.device.url,
                  roapSeq: 0,
                  locus: type === _constants._LOCUS_ID_ ? destination : null // pass the locus object if present
                }, {
                  parent: this.webex
                });


                this.meetingCollection.set(meeting);

                _context.prev = 2;
                _context.next = 5;
                return this.meetingInfo.fetchMeetingInfo(_util2.default.extractDestination(destination, type), type);

              case 5:
                info = _context.sent;


                meeting.parseMeetingInfo(info);
                meeting.meetingInfo = info ? info.body : null;
                _context.next = 15;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context['catch'](2);

                // if there is no meeting info we assume its a 1:1 call or wireless share
                _loggerProxy2.default.logger.info('Meetings->createMeeting#Error ' + _context.t0 + ' fetching /meetingInfo for creation.');
                _loggerProxy2.default.logger.info('Meetings->createMeeting#Info assuming this destination is a 1:1 or wireless share');
                // We need to save this info for future reference
                meeting.destination = destination;

              case 15:
                _context.prev = 15;

                // For type LOCUS_ID we need to parse the locus object to get the information
                // about the caller and callee
                // Meeting Added event will be created in `handleLocusEvent`
                if (type !== _constants._LOCUS_ID_) {
                  if (!meeting.sipUri) {
                    meeting.setSipUri(destination);
                  }

                  // TODO: check if we have to move this to parser
                  meetingAddedType = _util2.default.getMeetingAddedType(type);

                  // We typically shouldn't need to trigger both and event and return a promise.
                  // Is this a special case? We want to make the public API usage as simple as possible.

                  _triggerProxy2.default.trigger(this, {
                    file: 'meetings',
                    function: 'createMeeting'
                  }, _constants.EVENT_TRIGGERS.MEETING_ADDED, {
                    meeting: meeting,
                    type: meetingAddedType
                  });
                }
                return _context.finish(15);

              case 18:
                return _context.abrupt('return', meeting);

              case 19:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 10, 15, 18]]);
      }));

      function createMeeting(_x3) {
        return _ref2.apply(this, arguments);
      }

      return createMeeting;
    }()

    /**
     * get a specifc meeting given it's type matched to the value, i.e., locus url
     * @param {String} type
     * @param {Object} value
     * @returns {Meeting}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getMeetingByType',
    value: function getMeetingByType(type, value) {
      return this.meetingCollection.getByKey(type, value);
    }

    /**
     * Get all meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All active and scheduled meetings.
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getAllMeetings',
    value: function getAllMeetings() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // Options may include other parameters to filter this collection
      // of meetings.
      return this.meetingCollection.getAll(options);
    }

    /**
     * syncs all the meeting from server
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'syncMeetings',
    value: function syncMeetings() {
      var _this8 = this;

      return this.request.getActiveMeetings().then(function (locus) {
        if (locus.loci && locus.loci.length > 0) {
          locus.loci.forEach(function (locus) {
            _this8.handleLocusEvent({
              locus: locus,
              locusUrl: locus.url
            });
          });
        }
      });
    }

    /**
     * Get all scheduled meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All scheduled meetings.
     * @memberof Meetings
     */

  }, {
    key: 'getScheduledMeetings',
    value: function getScheduledMeetings() {
      return this.meetingCollection.getAll({ scheduled: true });
    }

    /**
     * Get the logger instance for plugin-meetings
     * @returns {Logger}
     */

  }, {
    key: 'getLogger',
    value: function getLogger() {
      return _loggerProxy2.default.get();
    }

    /**
     * Get the Stats Analyzer singleton
     * @returns {StatsAnalyzer}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getAnalyzer',
    value: function getAnalyzer() {
      return _analyzer2.default;
    }

    /**
     * Get the Stats Calculator singleton
     * @returns {StatsCalculator}
     * @public
     * @memberof Meetings
     */

  }, {
    key: 'getCalculator',
    value: function getCalculator() {
      return _calculator2.default;
    }
  }]);
  return Meetings;
}(_webexCore.WebexPlugin);

exports.default = Meetings;
//# sourceMappingURL=index.js.map
