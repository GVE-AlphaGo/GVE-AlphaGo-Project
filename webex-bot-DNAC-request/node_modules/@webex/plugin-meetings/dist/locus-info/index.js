'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _isEqual2 = require('lodash/isEqual');

var _isEqual3 = _interopRequireDefault(_isEqual2);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _eventsScope = require('../common/events/events-scope');

var _eventsScope2 = _interopRequireDefault(_eventsScope);

var _constants = require('../constants');

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

var _config = require('../metrics/config');

var _infoUtils = require('../locus-info/infoUtils');

var _infoUtils2 = _interopRequireDefault(_infoUtils);

var _fullState = require('../locus-info/fullState');

var _fullState2 = _interopRequireDefault(_fullState);

var _selfUtils = require('../locus-info/selfUtils');

var _selfUtils2 = _interopRequireDefault(_selfUtils);

var _hostUtils = require('../locus-info/hostUtils');

var _hostUtils2 = _interopRequireDefault(_hostUtils);

var _controlsUtils = require('../locus-info/controlsUtils');

var _controlsUtils2 = _interopRequireDefault(_controlsUtils);

var _mediaSharesUtils = require('../locus-info/mediaSharesUtils');

var _mediaSharesUtils2 = _interopRequireDefault(_mediaSharesUtils);

var _parser = require('../locus-info/parser');

var _parser2 = _interopRequireDefault(_parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @description LocusInfo extends ChildEmitter to convert locusInfo info a private emitter to parent object
 * @export
 * @private
 * @class LocusInfo
 */
var LocusInfo = function (_EventsScope) {
  (0, _inherits3.default)(LocusInfo, _EventsScope);

  function LocusInfo(updateMeeting) {
    var locus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var webex = arguments[2];
    var meetingId = arguments[3];
    (0, _classCallCheck3.default)(this, LocusInfo);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LocusInfo.__proto__ || (0, _getPrototypeOf2.default)(LocusInfo)).call(this));

    _this.parsedLocus = {
      states: []
    };
    _this.webex = webex;
    _this.emitChange = false;
    _this.compareAndUpdateFlags = {};
    _this.meetingId = meetingId;
    _this.updateMeeting = updateMeeting;
    _this.created = locus.created || null;
    _this.mediaShares = locus.mediaShares || null;
    _this.scheduledMeeting = locus.meeting || null;
    _this.participantsUrl = locus.participantsUrl || null;
    _this.replaces = locus.replaces || null;
    _this.aclUrl = locus.aclUrl || null;
    _this.baseSequence = locus.baseSequence || null;
    _this.sequence = locus.sequence || null;
    _this.membership = locus.membership || null;
    _this.identities = locus.identities || null;
    _this.participants = locus.participants || null;
    // above section only updates the locusInfo object
    // The below section makes sure it updates the locusInfo as well as updates the meeting object
    _this.updateParticipants(locus.participants);
    // For 1:1 space meeting the conversation Url does not exist in locus.conversation
    _this.updateConversationUrl(locus.conversationUrl, locus.info);
    _this.updateControls(locus.controls);
    _this.updateLocusUrl(locus.url);
    _this.updateFullState(locus.fullState);
    _this.updateMeetingInfo(locus.info);
    // self and participants generate sipUrl for 1:1 meeting
    _this.updateSelf(locus.self, locus.participants);
    _this.updateHostInfo(locus.host);
    return _this;
  }

  /**
   * @param {Object} locus
   * @param {Meeting} meeting
   * @returns {undefined}
   * @memberof LocusInfo
   */


  (0, _createClass3.default)(LocusInfo, [{
    key: 'initialSetup',
    value: function initialSetup(locus, meeting) {
      // meeting already exisits just do an update
      if (meeting) {
        // Its a new delta event fetch the whole meeting object
        _parser2.default.updateWithDeltaLocus(locus, meeting);
      } else {
        this.onFullLocus(locus);
      }

      // Change it to true after it recives it first locus object
      this.emitChange = true;
    }

    /**
     * @param {Meeting} meeting
     * @param {Object} data
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'parse',
    value: function parse(meeting, data) {
      var eventType = data.eventType;


      _loggerProxy2.default.logger.info('locusInfo->parse#received locus data: ' + eventType);

      switch (eventType) {
        case _constants.LOCUSEVENT.PARTICIPANT_JOIN:
        case _constants.LOCUSEVENT.PARTICIPANT_LEFT:
        case _constants.LOCUSEVENT.CONTROLS_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_AUDIO_MUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_AUDIO_UNMUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_VIDEO_MUTED:
        case _constants.LOCUSEVENT.PARTICIPANT_VIDEO_UNMUTED:
        case _constants.LOCUSEVENT.SELF_CHANGED:
        case _constants.LOCUSEVENT.PARTICIPANT_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_CONTROLS_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_ROLES_UPDATED:
        case _constants.LOCUSEVENT.PARTICIPANT_DECLINED:
        case _constants.LOCUSEVENT.FLOOR_GRANTED:
        case _constants.LOCUSEVENT.FLOOR_RELEASED:
          this.onFullLocus(data.locus, eventType);
          break;
        case _constants.LOCUSEVENT.DIFFERENCE:
          _parser2.default.updateWithDeltaLocus(data.locus, meeting);
          break;

        default:
          // Why will there be a event with no eventType ????
          // we may not need this, we can get full locus
          _parser2.default.updateWithDeltaLocus(data.locus, meeting);
      }
    }

    /**
     * @param {String} scope
     * @param {String} eventName
     * @param {Array} args
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'emitScoped',
    value: function emitScoped(scope, eventName, args) {
      return this.emit(scope, eventName, args);
    }

    /**
     * updates the locus with full locus object
     * @param {object} locus locus object
     * @param {sting} eventType particulat locus event
     * @returns {object} null
     * @memberof LocusInfo
     */

  }, {
    key: 'onFullLocus',
    value: function onFullLocus(locus, eventType) {
      if (!locus) {
        _loggerProxy2.default.logger.error('LocusInfo->onFullLocus#Locus object passed as argument was invalid, continuing.');
      }
      this.participants = locus.participants;
      this.updateLocusInfo(locus);
      this.updateParticipants(locus.participants);
      this.isMeetingActive();
      this.handleOneOnOneEvent(eventType);
    }

    // used for ringing stops on one on one
    /**
     * @param {String} eventType
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'handleOneOnOneEvent',
    value: function handleOneOnOneEvent(eventType) {
      if (this.parsedLocus.info.type === _constants._CALL_) {
        // for 1:1 bob calls alice and alice declines, notify the meeting state
        if (eventType === _constants.LOCUSEVENT.PARTICIPANT_DECLINED) {
          // trigger the event for stop ringing
          this.emitScoped({
            file: 'locus-info',
            function: 'handleOneonOneEvent'
          }, _constants.EVENTS.REMOTE_ANSWERED_DECLINED, {
            remoteDeclined: true,
            remoteAnswered: false
          });
        }
        // for 1:1 bob calls alice and alice answers, notify the meeting state
        if (eventType === _constants.LOCUSEVENT.PARTICIPANT_JOIN) {
          // trigger the event for stop ringing
          this.emitScoped({
            file: 'locus-info',
            function: 'handleOneonOneEvent'
          }, _constants.EVENTS.REMOTE_ANSWERED_DECLINED, {
            remoteDeclined: false,
            remoteAnswered: true
          });
        }
      }
    }

    /**
     * @param {Object} locus
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'onDeltaLocus',
    value: function onDeltaLocus(locus) {
      this.updateLocusInfo(locus);
      this.updateParticipants(locus.participants);
      this.isMeetingActive();
    }

    /**
     * @param {Object} locus
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateLocusInfo',
    value: function updateLocusInfo(locus) {
      this.updateControls(locus.controls);
      this.updateConversationUrl(locus.conversationUrl, locus.info);
      this.updateCreated(locus.created);
      this.updateFullState(locus.fullState);
      this.updateHostInfo(locus.host);
      this.updateMeetingInfo(locus.info, locus.self);
      this.updateMediaShares(locus.mediaShares);
      this.updateParticipantsUrl(locus.participantsUrl);
      this.updateReplace(locus.replace);
      this.updateSelf(locus.self, locus.participants);
      this.updateLocusUrl(locus.url);
      this.updateAclUrl(locus.aclUrl);
      this.updateBasequence(locus.baseSequence);
      this.updateSequence(locus.sequence);
      this.updateMemberShip(locus.membership);
      this.updateIdentifiers(locus.identities);
      this.compareAndUpdate();
      // update which required to compare different objects from locus
    }

    /**
     * @param {Array} participants
     * @param {Object} self
     * @returns {Array}
     * @memberof LocusInfo
     */

  }, {
    key: 'getLocusPartner',
    value: function getLocusPartner(participants, self) {
      if (!participants || participants.length === 0) {
        return null;
      }

      return participants.find(function (participant) {
        return self && participant.identity !== self.identity && (participants.length <= 2 || participant.type === _constants._USER_ && !participant.removed);
      }) || this.partner;
    }

    // TODO: all the leave states need to be checked
    /**
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'isMeetingActive',
    value: function isMeetingActive() {
      if (this.parsedLocus.fullState.type === _constants._CALL_) {
        var partner = this.getLocusPartner(this.participants, this.self);

        this.updateMeeting({ partner: partner });

        // Check if guest user needs to be checked here

        // 1) when bob declines call from bob, (bob='DECLINED')
        // 2) When alice rejects call to bob , (bob='NOTIFIED')

        // When we dont add MEDIA for condition 2. The state of bob='IDLE'

        if (this.fullState && this.fullState.state === _constants.LOCUS.STATE.INACTIVE) {
          // TODO: update the meeting state
          _loggerProxy2.default.logger.warn('LocusInfo#isMeetingActive-> Call Ended, locus state is inactive.');
          _metrics2.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });
          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.CALL_REMOVED_REASON.CALL_INACTIVE,
            shouldLeave: false
          });
        } else if (partner.state === _constants.MEETING_STATE.STATES.LEFT && this.parsedLocus.self && (this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.DECLINED || this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.NOTIFIED || this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.JOINED)) {
          _metrics2.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });
          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.CALL_REMOVED_REASON.PARTNER_LEFT,
            shouldLeave: this.parsedLocus.self.joinedWith && this.parsedLocus.self.joinedWith.state !== _constants._LEFT_
          });
        } else if (this.parsedLocus.self && this.parsedLocus.self.state === _constants.MEETING_STATE.STATES.LEFT && (partner.state === _constants.MEETING_STATE.STATES.LEFT || partner.state === _constants.MEETING_STATE.STATES.DECLINED || partner.state === _constants.MEETING_STATE.STATES.NOTIFIED || partner.state === _constants.MEETING_STATE.STATES.IDLE) // Happens when user just joins and adds no Media
        ) {
            _metrics2.default.postEvent({
              event: _config.eventType.REMOTE_ENDED,
              meetingId: this.meetingId
            });
            this.emitScoped({
              file: 'locus-info',
              function: 'isMeetingActive'
            }, _constants.EVENTS.DESTROY_MEETING, {
              reason: _constants.CALL_REMOVED_REASON.SELF_LEFT,
              shouldLeave: false
            });
          }
      } else if (this.parsedLocus.fullState.type === _constants._MEETING_) {
        if (this.fullState && (this.fullState.state === _constants.LOCUS.STATE.INACTIVE || this.fullState.state === _constants.LOCUS.STATE.TERMINATING)) {
          _metrics2.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });
          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.MEETING_REMOVED_REASON.MEETING_INACTIVE_TERMINATING,
            shouldLeave: false
          });
        } else if (this.fullState.removed) {
          // user has been dropped from a meeting
          _metrics2.default.postEvent({
            event: _config.eventType.REMOTE_ENDED,
            meetingId: this.meetingId
          });
          this.emitScoped({
            file: 'locus-info',
            function: 'isMeetingActive'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: _constants.MEETING_REMOVED_REASON.FULLSTATE_REMOVED,
            shouldLeave: false
          });
        }
        // If you are  guest and you are removed from the meeting
        // You wont get any further events
        else if (this.parsedLocus.self.removed) {
            // Check if we need to send an event
            this.emitScoped({
              file: 'locus-info',
              function: 'isMeetingActive'
            }, _constants.EVENTS.DESTROY_MEETING, {
              reason: _constants.MEETING_REMOVED_REASON.SELF_REMOVED,
              shouldLeave: false
            });
          }
      } else {
        _loggerProxy2.default.logger.warn('LocusInfo#isMeetingActive-> Meeting Type is unknown.');
      }
    }

    /**
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'compareAndUpdate',
    value: function compareAndUpdate() {
      if (this.compareAndUpdateFlags.compareSelfAndHost || this.compareAndUpdateFlags.compareHostAndSelf) {
        this.compareSelfAndHost();
      }
    }

    /**
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'compareSelfAndHost',
    value: function compareSelfAndHost() {
      if (this.parsedLocus.self.selfIdentity === this.parsedLocus.host.hostId && this.parsedLocus.self.moderator) {
        this.emitScoped({
          file: 'locus-info',
          function: 'compareSelfAndHost'
        }, _constants.EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, {
          canAssignHost: true
        });
      } else {
        this.emitScoped({
          file: 'locus-info',
          function: 'compareSelfAndHost'
        }, _constants.EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, {
          canAssignHost: false
        });
      }
    }

    /**
     *
     * @param {Object} participants new participants object
     * @param {boolen} deltaParticpantFlag  delta event
     * @returns {Array} updatedParticipants
     * @memberof LocusInfo
     */

  }, {
    key: 'updateParticipants',
    value: function updateParticipants(participants) {
      this.emitScoped({
        file: 'locus-info',
        function: 'updateParticipants'
      }, _constants.EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, {
        participants: participants,
        recordingId: this.parsedLocus.controls && this.parsedLocus.controls.recordingId,
        selfIdentity: this.parsedLocus.self && this.parsedLocus.self.selfIdentity,
        selfId: this.parsedLocus.self && this.parsedLocus.self.selfId,
        hostId: this.parsedLocus.host && this.parsedLocus.host.hostId
      });
    }

    /**
     * @param {Object} controls
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateControls',
    value: function updateControls(controls) {
      if (controls && !(0, _isEqual3.default)(this.controls, controls)) {
        this.controls = controls;
        this.parsedLocus.controls = _controlsUtils2.default.parse(controls);
      }
    }

    /**
     * @param {String} conversationUrl
     * @param {Object} info
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateConversationUrl',
    value: function updateConversationUrl(conversationUrl, info) {
      if (conversationUrl && !(0, _isEqual3.default)(this.conversationUrl, conversationUrl)) {
        this.conversationUrl = conversationUrl;
        this.updateMeeting({ convoUrl: conversationUrl });
      } else if (info && info.conversationUrl && !(0, _isEqual3.default)(this.conversationUrl, info.conversationUrl)) {
        this.conversationUrl = info.conversationUrl;
        this.updateMeeting({ convoUrl: info.conversationUrl });
      }
    }

    /**
     * @param {Object} created
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateCreated',
    value: function updateCreated(created) {
      if (created && !(0, _isEqual3.default)(this.created, created)) {
        this.created = created;
      }
    }

    /**
     * @param {Object} fullState
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateFullState',
    value: function updateFullState(fullState) {
      if (fullState && !(0, _isEqual3.default)(this.fullState, fullState)) {
        var result = _fullState2.default.getFullState(this.fullState, fullState);

        this.updateMeeting(result.current);

        if (result.updates.meetingStateChangedTo) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateFullState'
          }, _constants.LOCUSINFO.EVENTS.FULL_STATE_MEETING_STATE_CHANGE, {
            previousState: result.previous && result.previous.meetingState,
            currentState: result.current.meetingState
          });
        }

        if (result.updates.meetingTypeChangedTo) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateFullState'
          }, _constants.LOCUSINFO.EVENTS.FULL_STATE_TYPE_UPDATE, {
            type: result.current.type
          });
        }
        this.parsedLocus.fullState = result.current;
        this.fullState = fullState;
      }
    }

    /**
     * handles when the locus.host is updated
     * @param {Object} host the locus.host property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal event locus_info_update_host
     */

  }, {
    key: 'updateHostInfo',
    value: function updateHostInfo(host) {
      if (host && !(0, _isEqual3.default)(this.host, host)) {
        var parsedHosts = _hostUtils2.default.getHosts(this.host, host);

        this.updateMeeting(parsedHosts.current);
        this.parsedLocus.host = parsedHosts.current;
        if (parsedHosts.updates.isNewHost) {
          this.compareAndUpdateFlags.compareSelfAndHost = true;
          this.emitScoped({
            file: 'locus-info',
            function: 'updateHostInfo'
          }, _constants.EVENTS.LOCUS_INFO_UPDATE_HOST, {
            newHost: parsedHosts.current,
            oldHost: parsedHosts.previous
          });
        }
        this.host = host;
      } else {
        this.compareAndUpdateFlags.compareSelfAndHost = false;
      }
    }

    /**
     * @param {Object} info
     * @param {Object} self
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateMeetingInfo',
    value: function updateMeetingInfo(info, self) {
      if (info && (!(0, _isEqual3.default)(this.info, info) || !(0, _isEqual3.default)(_infoUtils2.default.parsePolicy(info), _infoUtils2.default.parsePolicy(this.info)) || !(0, _isEqual3.default)(_infoUtils2.default.parseModerator(info) || _infoUtils2.default.parseModerator(info)))) {
        var parsedInfo = _infoUtils2.default.getInfos(this.parsedLocus.info, info);

        this.emitScoped({
          file: 'locus-info',
          function: 'updateMeetingInfo'
        }, _constants.LOCUSINFO.EVENTS.MEETING_INFO_UPDATED, { info: parsedInfo.current, self: self });

        if (parsedInfo.updates.isLocked) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateMeetingInfo'
          }, _constants.LOCUSINFO.EVENTS.MEETING_LOCKED, info);
        }
        if (parsedInfo.updates.isUnlocked) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateMeetingInfo'
          }, _constants.LOCUSINFO.EVENTS.MEETING_UNLOCKED, info);
        }

        this.info = info;
        this.parsedLocus.info = parsedInfo.current;
        // Parses the info and adds necessary values
        this.updateMeeting(parsedInfo.current);
      }
    }

    /**
     * handles when the locus.mediaShares is updated
     * @param {Object} mediaShares the locus.mediaShares property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal event locus_info_update_media_shares
     */

  }, {
    key: 'updateMediaShares',
    value: function updateMediaShares(mediaShares) {
      if (mediaShares && !(0, _isEqual3.default)(this.mediaShares, mediaShares)) {
        var parsedMediaShares = _mediaSharesUtils2.default.getMediaShares(this.mediaShares, mediaShares);

        this.updateMeeting(parsedMediaShares.current);
        this.emitScoped({
          file: 'locus-info',
          function: 'updateMediaShares'
        }, _constants.EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, {
          current: parsedMediaShares.current,
          previous: parsedMediaShares.previous
        });
        this.parsedLocus.mediaShares = parsedMediaShares.current;
        this.mediaShares = mediaShares;
      }
    }

    /**
     * @param {String} participantsUrl
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateParticipantsUrl',
    value: function updateParticipantsUrl(participantsUrl) {
      if (participantsUrl && !(0, _isEqual3.default)(this.participantsUrl, participantsUrl)) {
        this.participantsUrl = participantsUrl;
      }
    }

    /**
     * @param {Object} replace
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateReplace',
    value: function updateReplace(replace) {
      if (replace && !(0, _isEqual3.default)(this.replace, replace)) {
        this.replace = replace;
      }
    }

    /**
     * handles when the locus.self is updated
     * @param {Object} self the locus.mediaShares property
     * @param {Array} participants the locus.participants property
     * @returns {undefined}
     * @memberof LocusInfo
     * emits internal events self_admitted_guest, self_unadmitted_guest, locus_info_update_self
     */

  }, {
    key: 'updateSelf',
    value: function updateSelf(self, participants) {
      if (self && !(0, _isEqual3.default)(this.self, self)) {
        var parsedSelves = _selfUtils2.default.getSelves(this.self, self, this.webex.internal.device.url);

        this.updateMeeting(parsedSelves.current);
        this.parsedLocus.self = parsedSelves.current;

        var element = this.parsedLocus.states[this.parsedLocus.states.length - 1];

        if (element !== parsedSelves.current.state) {
          this.parsedLocus.states.push(parsedSelves.current.state);
        }

        // TODO: check if we need to save the sipUri here as well
        // this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, SelfUtils.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri));
        var result = _selfUtils2.default.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri);

        if (result.sipUri) {
          this.updateMeeting(result);
        }
        if (parsedSelves.updates.moderatorChanged) {
          this.compareAndUpdateFlags.compareHostAndSelf = true;
        } else {
          this.compareAndUpdateFlags.compareHostAndSelf = false;
        }

        if (parsedSelves.updates.moderatorChanged) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_MODERATOR_CHANGED, self);
        }
        if (parsedSelves.updates.mutedByOthers) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_MUTED_BY_OTHERS, self);
        }
        if (parsedSelves.updates.isUnadmittedGuest) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, self);
        }
        if (parsedSelves.updates.isAdmittedGuest) {
          this.emitScoped({
            file: 'locus-info',
            function: 'updateSelf'
          }, _constants.LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, self);
        }
        this.emitScoped({
          file: 'locus-info',
          function: 'updateSelf'
        }, _constants.EVENTS.LOCUS_INFO_UPDATE_SELF, {
          oldSelf: parsedSelves.previous,
          newSelf: parsedSelves.current
        });
        this.parsedLocus.self = parsedSelves.current;
        this.self = self;
      } else {
        this.compareAndUpdateFlags.compareHostAndSelf = false;
      }
    }

    /**
     * handles when the locus.url is updated
     * @param {String} url
     * @returns {undefined}
     * emits internal event locus_info_update_url
     */

  }, {
    key: 'updateLocusUrl',
    value: function updateLocusUrl(url) {
      if (url && this.url !== url) {
        this.url = url;
        this.updateMeeting({ locusUrl: url });
        this.emitScoped({
          file: 'locus-info',
          function: 'updateLocusUrl'
        }, _constants.EVENTS.LOCUS_INFO_UPDATE_URL, url);
      }
    }

    /**
     * @param {String} aclUrl
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateAclUrl',
    value: function updateAclUrl(aclUrl) {
      if (aclUrl && !(0, _isEqual3.default)(this.aclUrl, aclUrl)) {
        this.aclUrl = aclUrl;
      }
    }

    /**
     * @param {Number} baseSequence
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateBasequence',
    value: function updateBasequence(baseSequence) {
      if (baseSequence && !(0, _isEqual3.default)(this.baseSequence, baseSequence)) {
        this.baseSequence = baseSequence;
      }
    }

    /**
     * @param {Number} sequence
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateSequence',
    value: function updateSequence(sequence) {
      if (sequence && !(0, _isEqual3.default)(this.sequence, sequence)) {
        this.sequence = sequence;
      }
    }

    /**
     * @param {Object} membership
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateMemberShip',
    value: function updateMemberShip(membership) {
      if (membership && !(0, _isEqual3.default)(this.membership, membership)) {
        this.membership = membership;
      }
    }

    /**
     * @param {Array} identities
     * @returns {undefined}
     * @memberof LocusInfo
     */

  }, {
    key: 'updateIdentifiers',
    value: function updateIdentifiers(identities) {
      if (identities && !(0, _isEqual3.default)(this.identities, identities)) {
        this.identities = identities;
      }
    }
  }]);
  return LocusInfo;
}(_eventsScope2.default);

exports.default = LocusInfo;
//# sourceMappingURL=index.js.map
