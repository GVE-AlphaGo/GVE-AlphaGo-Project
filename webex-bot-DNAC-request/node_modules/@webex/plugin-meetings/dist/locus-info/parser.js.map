{"version":3,"sources":["parser.js"],"names":["Parser","updateWithDeltaLocus","deltaLocus","meeting","sequence","rangeStart","rangeEnd","entries","locusInfo","baseSequence","meetingRequest","getFullLocus","desync","locusUrl","then","res","body","onFullLocus","DELTAEVENT","EQ","resBase","LocusUtil","compareLocus","GT","syncUrl","LT","CF","fullState","state","LOCUS","STATE","INITIALIZING","length","locusDesync","needToGetFullLocus","generateSyncDebugFlag","syncMeeting","onDeltaLocus","INACTIVE"],"mappings":";;;;;;;;;;AAEA;;;;AACA;;;;AAEA,IAAMA,SAAS,EAAf;;AAEA;AACAA,OAAOC,oBAAP,GAA8B,UAACC,UAAD,EAAaC,OAAb,EAAyB;AACrD,MAAI,EAAED,WAAWE,QAAX,IAAwBF,WAAWE,QAAX,CAAoBC,UAApB,IAAkCH,WAAWE,QAAX,CAAoBE,QAA9E,IAA4FJ,WAAWE,QAAX,CAAoBE,QAApB,IAAgC,mBAAIJ,WAAWE,QAAX,CAAoBG,OAAxB,CAA9H,CAAJ,EAAsK;AACpK,WAAO,IAAP;AACD;;AAED;AACA,MAAI,CAACJ,QAAQK,SAAR,CAAkBC,YAAvB,EAAqC;AACnC,WAAON,QAAQO,cAAR,CAAuBC,YAAvB,CAAoC;AACzCC,cAAQ,IADiC;AAEzCC,gBAAUV,QAAQU;AAFuB,KAApC,EAGJC,IAHI,CAGC,UAACC,GAAD,EAAS;AACf,UAAIA,OAAOA,IAAIC,IAAf,EAAqB;AACnBD,YAAIC,IAAJ,CAASP,YAAT,GAAwBP,WAAWO,YAAnC,CADmB,CAC8B;AACjDN,gBAAQK,SAAR,CAAkBS,WAAlB,CAA8BF,IAAIC,IAAlC;AACD;;AAED;AACA,aAAOE,sBAAWC,EAAlB;AACD,KAXM,CAAP;AAYD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAI,CAACjB,WAAWE,QAAhB,EAA0B,CAEzB;AADC;;;AAGF;AACA;;AAEA,MAAIW,YAAJ;AACA,MAAIK,gBAAJ;;AAEAL,QAAMM,gBAAUC,YAAV,CAAuBpB,WAAWE,QAAlC,EAA4CD,QAAQK,SAAR,CAAkBJ,QAA9D,CAAN;AACA;AACA;AACA,MAAIW,QAAQG,sBAAWK,EAAnB,IAAyBrB,WAAWO,YAApC,IAAoDN,QAAQK,SAAR,CAAkBgB,OAA1E,EAAmF;AACjFJ,cAAUC,gBAAUC,YAAV,CAAuBpB,WAAWO,YAAlC,EAAgDN,QAAQK,SAAR,CAAkBJ,QAAlE,CAAV;AACA,QAAIgB,YAAYF,sBAAWO,EAAvB,IAA6BL,YAAYF,sBAAWQ,EAAxD,EAA4D;AAC1DX,YAAMG,sBAAWQ,EAAjB;AACD;AACF;AACD;AACA;AACA,MAAI,CAACxB,WAAWO,YAAZ,IAA4BM,QAAQG,sBAAWC,EAA/C,IAAqDjB,WAAWyB,SAAX,CAAqBC,KAArB,KAA+BC,iBAAMC,KAAN,CAAYC,YAAhG,IACE7B,WAAWE,QAAX,CAAoBC,UAApB,KAAmC,CADrC,IAC0CH,WAAWE,QAAX,CAAoBE,QAApB,KAAiC,CAD3E,IAEEJ,WAAWE,QAAX,CAAoBG,OAApB,CAA4ByB,MAA5B,KAAuC,CAF7C,EAEgD;AAC9CjB,UAAMG,sBAAWK,EAAjB;AACD;AACD,UAAQR,GAAR;AACE,SAAKG,sBAAWO,EAAhB;AACA,SAAKP,sBAAWC,EAAhB;AACEhB,cAAQ8B,WAAR,GAAsB,KAAtB;AACA9B,cAAQ+B,kBAAR,GAA6B,KAA7B;AACA;AACF,SAAKhB,sBAAWQ,EAAhB;AACEL,sBAAUc,qBAAV,CAAgChC,OAAhC,EAAyCD,UAAzC;AACA,UAAIC,QAAQ8B,WAAZ,EAAyB;AACvB9B,gBAAQO,cAAR,CAAuBC,YAAvB,CAAoC;AAClCC,kBAAQ,IAD0B;AAElCC,oBAAUV,QAAQU;AAFgB,SAApC,EAGGC,IAHH,CAGQ,UAACC,GAAD,EAAS;AACfZ,kBAAQK,SAAR,CAAkBS,WAAlB,CAA8BF,IAAIC,IAAlC;AACD,SALD;AAMD,OAPD,MAQK;AACHb,gBAAQ8B,WAAR,GAAsB,IAAtB;AACAjC,eAAOoC,WAAP,CAAmBjC,OAAnB,EAA4BD,UAA5B;AACD;AACD;AACF,SAAKgB,sBAAWK,EAAhB;AACEpB,cAAQK,SAAR,CAAkB6B,YAAlB,CAA+BnC,UAA/B;AACA;AACAC,cAAQ8B,WAAR,GAAsB,KAAtB;AACA9B,cAAQ+B,kBAAR,GAA6B,KAA7B;AACA;AACF;AA3BF;;AA8BA,SAAOnB,GAAP;AACD,CAvFD;;AA0FAf,OAAOoC,WAAP,GAAqB,UAACjC,OAAD,EAAUD,UAAV,EAAyB;AAC5C,MAAIC,WACEA,QAAQK,SADV,IAEEL,QAAQK,SAAR,CAAkBgB,OAFpB,IAGErB,QAAQK,SAAR,CAAkBmB,SAHpB,IAIExB,QAAQK,SAAR,CAAkBmB,SAAlB,CAA4BC,KAA5B,KAAsCC,iBAAMC,KAAN,CAAYQ,QAJxD,EAIkE;AAChE;AACA;AACA;AACAnC,YAAQO,cAAR,CAAuB0B,WAAvB,CAAmC;AACjCZ,eAAStB,WAAWsB,OADa;AAEjCZ,cAAQT,QAAQS;AAFiB,KAAnC,EAIGE,IAJH,CAIQ,UAACC,GAAD,EAAS;AACbZ,cAAQK,SAAR,CAAkB6B,YAAlB,CAA+BtB,IAAIC,IAAnC;AACD,KANH;AAOD;AACF,CAjBD;;kBAmBehB,M","file":"parser.js","sourcesContent":["import {min} from 'lodash';\n\nimport LocusUtil from '../locus-info/utils';\nimport {DELTAEVENT, LOCUS} from '../constants';\n\nconst Parser = {};\n\n// https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events\nParser.updateWithDeltaLocus = (deltaLocus, meeting) => {\n  if (!(deltaLocus.sequence && (deltaLocus.sequence.rangeStart <= deltaLocus.sequence.rangeEnd) && (deltaLocus.sequence.rangeEnd <= min(deltaLocus.sequence.entries)))) {\n    return null;\n  }\n\n  // Its a new meeting and has incomplete information\n  if (!meeting.locusInfo.baseSequence) {\n    return meeting.meetingRequest.getFullLocus({\n      desync: true,\n      locusUrl: meeting.locusUrl\n    }).then((res) => {\n      if (res && res.body) {\n        res.body.baseSequence = deltaLocus.baseSequence; // TODO: verify baseSequence age and update as necessary\n        meeting.locusInfo.onFullLocus(res.body);\n      }\n\n      // Sending EQ if there is an error as next request will fixe it\n      return DELTAEVENT.EQ;\n    });\n  }\n\n  // THIS IS A NEW MEETING OBJECT\n  // // If meeting has no sequence, it means just initialized and will apply whatever in locus DTO\n  // if (isNewMeeting || !this.locus.sequence) {\n  //   meeting._updateWithDeltaLocus(deltaLocus, emitter);\n  //   meeting.locusDesync = false;\n  //   meeting.needToGetFullLocus = false;\n  //   return DELTAEVENT.GT;\n  // }\n\n  if (!deltaLocus.sequence) {\n    // TODO: force update\n  }\n\n  // TODO: If this was the first event, the client will not have a syncURL\n  // in its working copy to do a GET on. In this case clients should do a GET on locusUrl contained in the DTO\n\n  let res;\n  let resBase;\n\n  res = LocusUtil.compareLocus(deltaLocus.sequence, meeting.locusInfo.sequence);\n  // In-coming locus is greater than working copy, need to compare with base if there\n  // is base sequence except the first delta locus event\n  if (res === DELTAEVENT.GT && deltaLocus.baseSequence && meeting.locusInfo.syncUrl) {\n    resBase = LocusUtil.compareLocus(deltaLocus.baseSequence, meeting.locusInfo.sequence);\n    if (resBase === DELTAEVENT.LT || resBase === DELTAEVENT.CF) {\n      res = DELTAEVENT.CF;\n    }\n  }\n  // Special case for OBTP with meeting size equal or over 5. Locus might change this later\n  // This is a temporary fix. I will find a better solution later.\n  if (!deltaLocus.baseSequence && res === DELTAEVENT.EQ && deltaLocus.fullState.state === LOCUS.STATE.INITIALIZING &&\n        deltaLocus.sequence.rangeStart === 0 && deltaLocus.sequence.rangeEnd === 0 &&\n        deltaLocus.sequence.entries.length === 0) {\n    res = DELTAEVENT.GT;\n  }\n  switch (res) {\n    case DELTAEVENT.LT:\n    case DELTAEVENT.EQ:\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n    case DELTAEVENT.CF:\n      LocusUtil.generateSyncDebugFlag(meeting, deltaLocus);\n      if (meeting.locusDesync) {\n        meeting.meetingRequest.getFullLocus({\n          desync: true,\n          locusUrl: meeting.locusUrl\n        }).then((res) => {\n          meeting.locusInfo.onFullLocus(res.body);\n        });\n      }\n      else {\n        meeting.locusDesync = true;\n        Parser.syncMeeting(meeting, deltaLocus);\n      }\n      break;\n    case DELTAEVENT.GT:\n      meeting.locusInfo.onDeltaLocus(deltaLocus);\n      // Turn off desync in case this delta locus comes from a sync request\n      meeting.locusDesync = false;\n      meeting.needToGetFullLocus = false;\n      break;\n    default:\n  }\n\n  return res;\n};\n\n\nParser.syncMeeting = (meeting, deltaLocus) => {\n  if (meeting &&\n        meeting.locusInfo &&\n        meeting.locusInfo.syncUrl &&\n        meeting.locusInfo.fullState &&\n        meeting.locusInfo.fullState.state !== LOCUS.STATE.INACTIVE) {\n    // found that the locus syncs were happening even after 4 hrs of meeting\n    // completion, resulting in 403 errors. This check ensures we call\n    // syncing only if the locus state is not INACTIVE.\n    meeting.meetingRequest.syncMeeting({\n      syncUrl: deltaLocus.syncUrl,\n      desync: meeting.desync\n    })\n      .then((res) => {\n        meeting.locusInfo.onDeltaLocus(res.body);\n      });\n  }\n};\n\nexport default Parser;\n"]}