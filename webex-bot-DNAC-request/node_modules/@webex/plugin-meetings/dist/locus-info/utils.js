'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _max2 = require('lodash/max');

var _max3 = _interopRequireDefault(_max2);

var _min2 = require('lodash/min');

var _min3 = _interopRequireDefault(_min2);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ParseUtils = {};

// https://sqbu-github.cisco.com/WebExSquared/cloud-apps/wiki/Locus-Delta-Events
ParseUtils.compareLocus = function (newSequence, currentSequence) {
  var newMin = Math.min(newSequence.rangeStart, (0, _min3.default)(newSequence.entries));
  var newMax = Math.max(newSequence.rangeEnd, (0, _max3.default)(newSequence.entries));
  var curMin = Math.min(currentSequence.rangeStart, (0, _min3.default)(currentSequence.entries));
  var curMax = Math.max(currentSequence.rangeEnd, (0, _max3.default)(currentSequence.entries));

  var newUniqueCurrent = ParseUtils.calculateUnique(newSequence, currentSequence);
  var currentUniqueNew = ParseUtils.calculateUnique(currentSequence, newSequence);

  var newHasRange = !(newSequence.rangeStart === 0 && newSequence.rangeEnd === 0);
  var curHasRange = !(currentSequence.rangeStart === 0 && currentSequence.rangeEnd === 0);

  if (newMin > curMax) {
    return _constants.DELTAEVENT.GT;
  }
  if (newMax < curMin) {
    return _constants.DELTAEVENT.LT;
  }
  if (!newUniqueCurrent.length && !currentUniqueNew.length) {
    if (newSequence.rangeEnd - newMin > currentSequence.rangeEnd - curMin) {
      return _constants.DELTAEVENT.GT;
    }
    if (newSequence.rangeEnd - newMin < currentSequence.rangeEnd - curMin) {
      return _constants.DELTAEVENT.LT;
    }

    return _constants.DELTAEVENT.EQ;
  }
  if (newUniqueCurrent.length && !currentUniqueNew.length) {
    return _constants.DELTAEVENT.GT;
  }
  if (currentUniqueNew.length && !newUniqueCurrent.length) {
    return _constants.DELTAEVENT.LT;
  }

  if (!newHasRange && !curHasRange || ParseUtils.hasUniqueButInRange(newUniqueCurrent, curMin, curMax) || ParseUtils.hasUniqueButInRange(currentUniqueNew, newMin, newMax)) {
    return _constants.DELTAEVENT.CF;
  }
  if ((0, _min3.default)(newUniqueCurrent) > (0, _min3.default)(currentUniqueNew)) {
    return _constants.DELTAEVENT.GT;
  }

  return _constants.DELTAEVENT.LT;
};

ParseUtils.generateSyncDebugFlag = function (meeting, deltaLocus) {
  var baseSequence = deltaLocus.baseSequence;

  var workingSequence = meeting.locusInfo.sequence;
  var targetSequence = deltaLocus.sequence;
  var flags = ['', '', '', '', '', ''];

  var setFlag = function setFlag(sequence) {
    if (!sequence) {
      return _constants.LOCUS.SEQUENCE.UN_DEF;
    }

    return ParseUtils.isEmptySequence(sequence) ? _constants.LOCUS.SEQUENCE.EMPTY : _constants.LOCUS.SEQUENCE.DEF;
  };

  flags[0] = setFlag(baseSequence);
  flags[1] = setFlag(workingSequence);
  flags[2] = setFlag(targetSequence);

  flags[3] = baseSequence && workingSequence ? ParseUtils.compareLocus(baseSequence, workingSequence).toLowerCase() : _constants.LOCUS.SEQUENCE.NA;
  flags[4] = workingSequence && targetSequence ? ParseUtils.compareLocus(workingSequence, targetSequence).toLowerCase() : _constants.LOCUS.SEQUENCE.NA;
  flags[5] = baseSequence && targetSequence ? ParseUtils.compareLocus(baseSequence, targetSequence).toLowerCase() : _constants.LOCUS.SEQUENCE.NA;

  // TODO: check where it is used
  meeting.desync = flags.toString();
};

ParseUtils.calculateUnique = function (s1, s2) {
  var res = [];

  s1.entries.forEach(function (entry) {
    /* istanbul ignore else */
    if ((entry < s2.rangeStart || entry > s2.rangeEnd) && s2.entries.indexOf(entry) === -1) {
      res.push(entry);
    }
  });

  return res;
};

ParseUtils.isEmptySequence = function (sequence) {
  if (Object.prototype.hasOwnProperty.call(sequence, _constants.LOCUS.SEQUENCE.RANGE_START) && sequence.rangeStart === 0 && Object.prototype.hasOwnProperty.call(sequence, _constants.LOCUS.SEQUENCE.RANGE_END) && sequence.rangeEnd === 0 && sequence.entries && sequence.entries.length === 0) {
    return true;
  }

  return false;
};

ParseUtils.hasUniqueButInRange = function (uniqueEntries, minimum, maximum) {
  return uniqueEntries.some(function (entry) {
    return entry > minimum && entry < maximum;
  });
};

exports.default = ParseUtils;
//# sourceMappingURL=utils.js.map
