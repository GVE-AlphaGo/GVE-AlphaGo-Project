'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _webexCore = require('@webex/webex-core');

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _triggerProxy = require('../common/events/trigger-proxy');

var _triggerProxy2 = _interopRequireDefault(_triggerProxy);

var _index = require('../roap/index');

var _index2 = _interopRequireDefault(_index);

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

var _properties = require('../media/properties');

var _properties2 = _interopRequireDefault(_properties);

var _state = require('../meeting/state');

var _state2 = _interopRequireDefault(_state);

var _audio = require('../meeting/audio');

var _audio2 = _interopRequireDefault(_audio);

var _video = require('../meeting/video');

var _video2 = _interopRequireDefault(_video);

var _locusInfo = require('../locus-info');

var _locusInfo2 = _interopRequireDefault(_locusInfo);

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

var _config = require('../metrics/config');

var _reconnectionManager = require('../reconnection-manager');

var _reconnectionManager2 = _interopRequireDefault(_reconnectionManager);

var _request = require('../meeting/request');

var _request2 = _interopRequireDefault(_request);

var _index3 = require('../members/index');

var _index4 = _interopRequireDefault(_index3);

var _util = require('../meeting/util');

var _util2 = _interopRequireDefault(_util);

var _util3 = require('../media/util');

var _util4 = _interopRequireDefault(_util3);

var _index5 = require('../stats/index');

var _index6 = _interopRequireDefault(_index5);

var _metrics3 = require('../stats/metrics');

var _metrics4 = _interopRequireDefault(_metrics3);

var _util5 = require('../stats/util');

var _util6 = _interopRequireDefault(_util5);

var _reconnection = require('../common/errors/reconnection');

var _reconnection2 = _interopRequireDefault(_reconnection);

var _constants = require('../constants');

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

var _media3 = require('../common/errors/media');

var _media4 = _interopRequireDefault(_media3);

var _mqaProcessor = require('../metrics/mqa-processor');

var _mqaProcessor2 = _interopRequireDefault(_mqaProcessor);

var _inMeetingActions = require('./in-meeting-actions');

var _inMeetingActions2 = _interopRequireDefault(_inMeetingActions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * MediaDirection
 * @typedef {Object} MediaDirection
 * @property {boolean} sendAudio
 * @property {boolean} receiveAudio
 * @property {boolean} sendVideo
 * @property {boolean} receiveVideo
 * @property {boolean} sendShare
 * @property {boolean} receiveShare
 */

/**
  * AudioVideo
  * @typedef {Object} AudioVideo
  * @property {Object} audio
  * @property {String} audio.deviceId
  * @property {Object} video
  * @property {String} video.deviceId
  */

/**
   * SharePreferences
   * @typedef {Object} SharePreferences
   * @property {Object} [shareConstraints]
   * @property {Boolean} [highFrameRate]
   */

/**
 * JoinOptions
 * @typedef {Object} JoinOptions
 * @property {String} [resourceId]
 * @property {String} [hostPin]
 * @property {Boolean} [moderator]
 */

/**
 * SendOptions
 * @typedef {Object} SendOptions
 * @property {Boolean} sendAudio
 * @property {Boolean} sendVideo
 * @property {Boolean} sendShare
 */

/**
  * Meeting State Change Event
  * Emitted when ever there is a meeting state change
  * @event meeting:stateChange
  * @instance
  * @type {Object}
  * @property {String} currentState current state of the meeting
  * @property {String} previousState previous state of the meeting
  * @memberof Meeting
  */

/**
  * Media Ready Event
  * Emitted when a stream is ready to be rendered
  * @event media:ready
  * @instance
  * @type {Object}
  * @property {MediaStream} stream the media stream
  * @property {String} type what type of stream, remote, local
  * @memberof Meeting
  */

/**
  * Media Stopped Event
  * Emitted when a stream has stopped sending
  * @event media:stopped
  * @instance
  * @type {Object}
  * @property {String} type what type of stream, remote, local
  * @memberof Meeting
  */

/**
 * Meeting Ringing Event
 * Emitted when this client should play a ringing sound, because this member is getting an incoming meeting
 * or sending out an incoming meeting
 * @event meeting:ringing
 * @instance
 * @type {Object}
 * @property {String} type // INCOMING or JOIN
 * @property {String} id
 * @memberof Meeting
 */

/**
 * Meeting Ringing Stop Event
 * Emitted when this client should stop playing a ringing sound
 * @event meeting:ringingStop
 * @instance
 * @type {Object}
 * @property {Object} type
 * @property {Boolean} type.remoteAnswered
 * @property {Boolean} type.remoteDeclined
 * @property {String} id
 * @memberof Meeting
 */

/**
 * Meeting Started Sharing Local Event
 * Emitted when this member starts sharing
 * @event meeting:startedSharingLocal
 * @instance
 * @type {Object}
 * @memberof Meeting
 */

/**
 * Meeting Stopped Sharing Local Event
 * Emitted when this member stops sharing
 * @event meeting:stoppedSharingLocal
 * @instance
 * @type {Object}
 * @memberof Meeting
 */

/**
 * Meeting Locked Event
 * Emitted when a meeting is locked
 * @event meeting:locked
 * @instance
 * @type {Object}
 * @property {Object} info
 * @memberof Meeting
 */

/**
 * Meeting Unlocked Event
 * Emitted when a meeting is unlocked
 * @event meeting:unlocked
 * @instance
 * @type {Object}
 * @property {Object} info
 * @memberof Meeting
 */

/**
 * Meeting Actions Update Event
 * Emitted when a user can take actions on a meeting such as lock, unlock, assign host
 * @event meeting:actionsUpdate
 * @instance
 * @type {Object}
 * @property {Boolean} canLock
 * @property {Boolean} canUnlock
 * @property {Boolean} canAssignHost
 * @memberof Meeting
 */

/**
 * Meeting Muted By Others Event
 * Emitted when a member is muted by another member
 * @event meeting:self:mutedByOthers
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */

/**
 * Meeting Self Guest Admitted Event
 * Emitted when a member admitted to the meeting by another member
 * @event meeting:self:guestAdmitted
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */

/**
 * Meeting Self Lobby Waiting Event
 * Emitted when this member enters the lobby and is waiting for the webex meeting to begin
 * @event meeting:self:lobbyWaiting
 * @instance
 * @type {Object}
 * @property {Object} payload
 * @memberof Meeting
 */

/**
  * Reconnection Starting Event
  * Emitted when reconnection of media to the active meeting was successful
  * @event meeting:reconnectionStarting
  * @instance
  * @memberof Meeting
  */

/**
  * Reconnection Success Event
  * Emitted when reconnection of media to the active meeting was successful
  * @event meeting:reconnectionSuccess
  * @instance
  * @type {Object}
  * @property {Object} reconnect
  * @memberof Meeting
  */

/**
  * Reconnection Failure Event
  * Emitted when reconnection of media to the active meeting was successful
  * @event meeting:reconnectionFailure
  * @instance
  * @type {Object}
  * @property {Error} error
  * @memberof Meeting
  */

/**
 * @description Meeting is the crux of the plugin
 * @export
 * @class Meeting
 */
var Meeting = function (_StatelessWebexPlugin) {
  (0, _inherits3.default)(Meeting, _StatelessWebexPlugin);

  /**
   * @param {Object} attrs
   * @param {Object} options
   * @constructor
   * @memberof Meeting
  */
  function Meeting(attrs, options) {
    (0, _classCallCheck3.default)(this, Meeting);

    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Meeting.__proto__ || (0, _getPrototypeOf2.default)(Meeting)).call(this, {}, options));

    _this.namespace = _constants.MEETINGS;

    _this.getMediaStreams = function (mediaDirection) {
      var audioVideo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var sharePreferences = arguments[2];

      if (mediaDirection && (mediaDirection.sendAudio || mediaDirection.sendVideo || mediaDirection.sendShare)) {
        return _media2.default.getUserMedia(mediaDirection, audioVideo, sharePreferences).then(function (response) {
          if (!response[0] && !response[1]) {
            return _promise2.default.reject(new _media4.default('Was not able to retrive media Stream'));
          }

          return _promise2.default.resolve(response);
        });
      }

      return _promise2.default.reject(new _media4.default('Atleaset one of the mediaDirection value should be true'));
    };

    _this.getDevices = function () {
      return _media2.default.getDevices();
    };

    _this.attrs = attrs;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.options = options;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.id = _uuid2.default.v4();
    _this.correlationId = _this.id;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.userId = attrs.userId;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.resource = attrs.resource;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.deviceUrl = attrs.deviceUrl;
    /**
     * @description set you -1 as default values is 0 (used to idenfify if 1st roap request was sent)
     * @instance
     * @type {Number}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.roapSeq = _constants.ROAP_SEQ_PRE;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @public
     * @memberof Meeting
     */
    // TODO: needs to be defined as a class
    _this.meetingInfo = {};
    /**
     * @instance
     * @type {Members}
     * @public
     * @memberof Meeting
     */
    _this.members = new _index4.default({ locusUrl: attrs.locus && attrs.locus.url }, { parent: _this.webex });
    /**
     * @instance
     * @type {Roap}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.roap = new _index2.default({}, { parent: _this.webex });
    /**
     * created later
     * @instance
     * @type {ReconnectionManager}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.reconnectionManager = new _reconnectionManager2.default(_this);
    /**
     * created later
     * @instance
     * @type {AudioStateMachine}
     * @public
     * @memberof Meeting
     */
    _this.audio = null;
    /**
     * created later
     * @instance
     * @type {VideoStateMachine}
     * @public
     * @memberof Meeting
     */
    _this.video = null;
    /**
     * @instance
     * @type {MeetingStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.meetingFiniteStateMachine = _state2.default.create(_this);
    /**
     * @instance
     * @type {WebRTCStats}
     * @public
     * @memberof Meeting
     */
    _this.stats = null;
    /**
     * @instance
     * @type {WebRTCStats}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.internalStats = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.convoUrl = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.locusUrl = attrs.locus && attrs.locus.url || null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.sipUri = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.partner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.type = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.owner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.hostId = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.policy = null;
    /**
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    _this.meetingRequest = new _request2.default({}, options);
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    _this.locusInfo = new _locusInfo2.default(_this.updateMeetingObject.bind(_this), attrs.locus ? attrs.locus : {}, _this.webex, _this.id);
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MediaProperties}
     * @public
     * @memberof Meeting
     */
    _this.mediaProperties = new _properties2.default();
    /**
     * @instance
     * @type {InMeetingActions}
     * @public
     * @memberof Meeting
    */
    _this.inMeetingActions = new _inMeetingActions2.default();
    /**
     * @instance
     * @type {Boolean}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.isSharing = false;
    /**
     * @instance
     * @type {Array}
     * @readonly
     * @public
     * @memberof Meeting
     */
    _this.callEvents = [];
    /**
     * There is a pending floor requested by the user
     * @instance
     * @type {floorGrantPending}
     * @private
     * @memberof Meeting
     */
    _this.floorGrantPending = false;
    /**
     * @instance
     * @type {MediaMetrics}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.mediaQualityMetrics = null;
    /**
     * @instance
     * @type {MQAProcessor}
     * @readonly
     * @private
     * @memberof Meeting
     */
    _this.mqaProcessor = null;
    _this.setUpLocusInfoListeners();
    return _this;
  }

  /**
   * Proxy function for all the listener set ups
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */


  (0, _createClass3.default)(Meeting, [{
    key: 'setUpLocusInfoListeners',
    value: function setUpLocusInfoListeners() {
      // meeting update listeners
      this.setUpLocusInfoSelfListener();
      this.setUpLocusInfoMeetingListener();
      // members update listeners
      this.setUpLocusFullStateListener();
      this.setUpLocusUrlListener();
      this.setUpLocusHostListener();
      this.setUpLocusSelfListener();
      this.setUpLocusParticipantsListener();
      this.setUpLocusMediaSharesListener();
      this.setUpLocusInfoMeetingInfoListener();
      this.setUpLocusInfoAssignHostListener();
    }

    /**
     * Set up the locus info listener for assign host permissions on a meeting
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusInfoAssignHostListener',
    value: function setUpLocusInfoAssignHostListener() {
      var _this2 = this;

      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST, function (payload) {
        _triggerProxy2.default.trigger(_this2, {
          file: 'meeting/index',
          function: 'setUpLocusInfoAssignHostListener'
        }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, {
          canAssignHost: payload.canAssignHost,
          canLock: _this2.inMeetingActions.getCanLock(),
          canUnlock: _this2.inMeetingActions.getCanUnlock()
        });
        _this2.inMeetingActions.setCanAssignHost(payload.canAssignHost);
      });
    }

    /**
     * Set up the internal locus info full state object listener
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusFullStateListener',
    value: function setUpLocusFullStateListener() {
      var _this3 = this;

      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.FULL_STATE_MEETING_STATE_CHANGE, function (payload) {
        _triggerProxy2.default.trigger(_this3, {
          file: 'meeting/index',
          function: 'setUpLocusFullStateListener'
        }, _constants.EVENT_TRIGGERS.MEETING_STATE_CHANGE, {
          payload: payload
        });
      });

      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.FULL_STATE_TYPE_UPDATE, function (payload) {
        _this3.members.locusFullStateTypeUpdate(payload);
      });
    }

    /**
     * get the metrics payload pre
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @returns {Object}
     * @memberof Meeting
     */

  }, {
    key: 'getAnalyzerMetricsPrePayload',
    value: function getAnalyzerMetricsPrePayload(options) {
      if (options) {
        var event = options.event,
            trackingId = options.trackingId,
            locus = options.locus;


        if (!event) {
          _loggerProxy2.default.logger.error('Error [Call Analyzer Event', event || '', ']: invalid identifers or event type! ' + this.correlationId);

          return null;
        }

        var identifiers = {
          correlationId: this.correlationId,
          userId: this.userId,
          deviceId: this.deviceUrl
        };

        // If locus is passed take the value from there else use meeting object
        if (locus) {
          identifiers.locusId = locus.url.split('/').pop();
          identifiers.locusStartTime = locus.fullState.lastActive;
        } else if (this.locusUrl && this.locusInfo.fullState) {
          identifiers.locusId = this.locusUrl && this.locusUrl.split('/').pop();
          identifiers.locusStartTime = this.locusInfo.fullState && this.locusInfo.fullState.lastActive;
        }

        if (options.trackingId) {
          identifiers.trackingId = trackingId;
        }

        var payload = {};

        if (options.type === _constants.MQA_STATS.CA_TYPE) {
          payload = _metrics2.default.initMediaPayload(options.event, identifiers, options);
        } else {
          payload = _metrics2.default.initPayload(options.event, identifiers, options);
        }

        return payload;
      }

      return null;
    }

    /**
     * Send the metrics to call-analyzer dashboard
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'sendCallAnalyzerMetrics',
    value: function sendCallAnalyzerMetrics(options) {
      var payload = this.getAnalyzerMetricsPrePayload(options);

      return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);
    }

    /**
     * Send the metrics to Media Quality Analyzer dashboard
     * @param {Object} options
     * @param {String} options.event
     * @param {String} options.trackingId
     * @param {Object} options.locus
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'sendMediaQualityAnalyzerMetrics',
    value: function sendMediaQualityAnalyzerMetrics(options) {
      options.type = _constants.MQA_STATS.CA_TYPE;
      options.clientType = this.config.metrics.clientType;
      var payload = this.getAnalyzerMetricsPrePayload(options);

      return this.webex.internal.metrics.submitCallDiagnosticEvents(payload);
    }

    /**
     * Set up the locus info self listener
     * update self value for members and updates the member
     * notifies consumer with members:self:update {activeSelfId endedSelfId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusSelfListener',
    value: function setUpLocusSelfListener() {
      var _this4 = this;

      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_SELF, function (payload) {
        _this4.members.locusSelfUpdate(payload);

        // If user moved to a JOINED state and there is a pending floor grant trigger it
        if (_this4.floorGrantPending && payload.newSelf.state === _constants.MEETING_STATE.STATES.JOINED) {
          _this4.share().then(function () {
            _this4.floorGrantPending = false;
          });
        }
      });
    }

    /**
     * Set up the locus info host listener
     * update host value for members and updates the member
     * notifies consumer with members:host:update: {activeHostId, endedHostId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusHostListener',
    value: function setUpLocusHostListener() {
      var _this5 = this;

      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_HOST, function (payload) {
        _this5.members.locusHostUpdate(payload);
      });
    }

    /**
     * Set up the locus info participants update listener
     * update members collection value for members
     * notifies consumer with members:update
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusParticipantsListener',
    value: function setUpLocusParticipantsListener() {
      var _this6 = this;

      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, function (payload) {
        _this6.members.locusParticipantsUpdate(payload);
      });
    }

    /**
     * Set up the locus info media shares listener
     * update content sharing id value for members, and updates the member
     * notifies consumer with members:content:update {activeContentSharingId, endedContentSharingId}
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusMediaSharesListener',
    value: function setUpLocusMediaSharesListener() {
      var _this7 = this;

      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, function (payload) {
        _this7.members.locusMediaSharesUpdate(payload);
      });
    }

    /**
     * Set up the locus info url listener
     * update locus_url value for members
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusUrlListener',
    value: function setUpLocusUrlListener() {
      var _this8 = this;

      this.locusInfo.on(_constants.EVENTS.LOCUS_INFO_UPDATE_URL, function (payload) {
        _this8.members.locusUrlUpdate(payload);
      });
    }

    /**
     * Set up the locus info meeting info listener
     * @returns {undefined}
     * @private
     * @memberof meeting
     */

  }, {
    key: 'setUpLocusInfoMeetingInfoListener',
    value: function setUpLocusInfoMeetingInfoListener() {
      var _this9 = this;

      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_LOCKED, function (payload) {
        if (payload) {
          _triggerProxy2.default.trigger(_this9, {
            file: 'meeting/index',
            function: 'setUpLocusInfoMeetingInfoListener'
          }, _constants.EVENT_TRIGGERS.MEETING_LOCKED, {
            payload: payload
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_UNLOCKED, function (payload) {
        if (payload) {
          _triggerProxy2.default.trigger(_this9, {
            file: 'meeting/index',
            function: 'setUpLocusInfoMeetingInfoListener'
          }, _constants.EVENT_TRIGGERS.MEETING_UNLOCKED, {
            payload: payload
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.MEETING_INFO_UPDATED, function (payload) {
        if (payload && payload.info) {
          var newCanLock = void 0;
          var newCanUnlock = void 0;

          if (payload.self && !payload.self.moderator) {
            newCanLock = false;
            newCanUnlock = false;
          } else {
            newCanLock = _util2.default.canUserLock(payload.info.moderator, payload.info.policy);
            newCanUnlock = _util2.default.canUserUnlock(payload.info.moderator, payload.info.policy);
          }

          if (newCanLock && !_this9.inMeetingActions.canLock) {
            _triggerProxy2.default.trigger(_this9, {
              file: 'meeting/index',
              function: 'setUpLocusInfoMeetingInfoListener'
            }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, {
              canLock: true,
              canUnlock: false,
              canAssignHost: _this9.inMeetingActions.getCanAssignHost()
            });
          }
          if (newCanUnlock && !_this9.inMeetingActions.canUnlock || !newCanLock) {
            _triggerProxy2.default.trigger(_this9, {
              file: 'meeting/index',
              function: 'setUpLocusInfoMeetingInfoListener'
            }, _constants.EVENT_TRIGGERS.MEETING_ACTIONS_UPDATE, {
              canLock: false,
              canUnlock: true,
              canAssignHost: _this9.inMeetingActions.getCanAssignHost()
            });
          }
          _this9.inMeetingActions.setCanLock(newCanLock || false);
          _this9.inMeetingActions.setCanUnlock(newCanUnlock || false);
        }
      });
    }

    /**
     * Internal function to listen to the self object changes
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusInfoSelfListener',
    value: function setUpLocusInfoSelfListener() {
      var _this10 = this;

      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_MUTED_BY_OTHERS, function (payload) {
        if (payload) {
          _triggerProxy2.default.trigger(_this10, {
            file: 'meeting/index',
            function: 'setUpLocusInfoSelfListener'
          }, _constants.EVENT_TRIGGERS.MEETING_SELF_MUTED_BY_OTHERS, {
            payload: payload
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, function (payload) {
        if (payload) {
          _triggerProxy2.default.trigger(_this10, {
            file: 'meeting/index',
            function: 'setUpLocusInfoSelfListener'
          }, _constants.EVENT_TRIGGERS.MEETING_SELF_LOBBY_WAITING, {
            payload: payload
          });

          _metrics2.default.postEvent({
            event: _config.eventType.LOBBY_ENTERED,
            meeting: _this10
          });
        }
      });
      this.locusInfo.on(_constants.LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, function (payload) {
        if (payload) {
          _triggerProxy2.default.trigger(_this10, {
            file: 'meeting/index',
            function: 'setUpLocusInfoSelfListener'
          }, _constants.EVENT_TRIGGERS.MEETING_SELF_GUEST_ADMITTED, {
            payload: payload
          });

          _metrics2.default.postEvent({
            event: _config.eventType.LOBBY_EXITED,
            meeting: _this10
          });
        }
      });
    }

    /**
     * Add LocusInfo nested object listeners (from child to parent)
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setUpLocusInfoMeetingListener',
    value: function setUpLocusInfoMeetingListener() {
      var _this11 = this;

      this.locusInfo.on(_constants.EVENTS.REMOTE_ANSWERED_DECLINED, function (payload) {
        _this11.meetingFiniteStateMachine.remote(payload);
      });
      this.locusInfo.on(_constants.EVENTS.DESTROY_MEETING, function (payload) {
        // if self state is NOT left

        // TODO: Handle sharing and wireless sharing when meeting end
        if (_this11.wirelessShare) {
          if (_this11.mediaProperties.shareTrack) {
            _this11.mediaProperties.shareTrack.onended = null;
            _this11.mediaProperties.shareTrack.stop();
          }
        }
        // when multiple WEB deviceType join with same user
        // and some of the devices are joined and some are left
        // when your own device is still connected you want to leave and destroy
        // else you want to just destroy
        // this looks odd because when it leaves it should destroy, but we get a
        // leave response and we should destroy it on the next event loop
        // the leave response gets parsed and we decide if we want to destroy the meeting
        // the first time we just leave it, the second time it comes it destroys it from the collection
        if (payload.shouldLeave) {
          // TODO:  We should do cleaning of meeting object if the shouldLeave: false because there might be meeting object which we are not cleaning

          _this11.leave({ reason: payload.reason }).then(function () {
            _loggerProxy2.default.logger.warn('meeting/index->setUpLocusInfoMeetingListener:DESTROY_MEETING#The meeting has been left, but has not been destroyed, you should see a later event for leave.');
          }).catch(function (error) {
            _loggerProxy2.default.logger.error('meeting/index->setUpLocusInfoMeetingListener:DESTROY_MEETING#Issue with leave for meeting, meeting still in collection: ' + _this11.meeting + ', error: ' + error);
          });
        } else {
          _loggerProxy2.default.logger.info('MEETING_REMOVED_REASON', payload.reason);
          _util2.default.cleanUp(_this11);
          _triggerProxy2.default.trigger(_this11, {
            file: 'meeting/index',
            function: 'setUpLocusInfoMeetingListener'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: payload.reason,
            meetingId: _this11.id
          });
        }
      });
    }

    /**
     * Set meeting values rather than events
     * @param {Object} object
     * @returns {undefined}
     * @private
     * @memberof Meeting
     * // TODO: is this function necessary?
     */

  }, {
    key: 'updateMeetingObject',
    value: function updateMeetingObject(object) {
      var _this12 = this;

      // Validate if these are valid meeting object property
      // TODO: add a check to make sure the value passed in the constructor
      // is not changed by any delta event
      if (object && (0, _keys2.default)(object).length) {
        (0, _keys2.default)(object).forEach(function (key) {
          _this12[key] = object[key];
        });
      }
    }

    /**
     * Invite a guest to the call that isn't normally part of this call
     * @param {Object} invitee
     * @param {String} invitee.emailAddress
     * @param {String} invitee.email
     * @param {Boolean} [alertIfActive]
     * @returns {Promise} see #members.addMember
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'invite',
    value: function invite(invitee) {
      var alertIfActive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.members.addMember(invitee, alertIfActive);
    }

    /**
     * Admit the guest(s) to the call once they are waiting
     * @param {Array} memberIds
     * @returns {Promise} see #members.admitMembers
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'admit',
    value: function admit(memberIds) {
      return this.members.admitMembers(memberIds);
    }

    /**
     * Remove the member from the meeting, boot them
     * @param {String} memberId
     * @returns {Promise} see #members.removeMember
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'remove',
    value: function remove(memberId) {
      return this.members.removeMember(memberId);
    }

    /**
     * Mute another member from the meeting
     * @param {String} memberId
     * @param {Boolean} mute
     * @returns {Promise} see #members.muteMember
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'mute',
    value: function mute(memberId) {
      var _mute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.members.muteMember(memberId, _mute);
    }

    /**
     * Transfer the moderator role to another eligible member
     * @param {String} memberId
     * @param {Boolean} moderator
     * @returns {Promise} see #members.transferHostToMember
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'transfer',
    value: function transfer(memberId) {
      var moderator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.members.transferHostToMember(memberId, moderator);
    }

    /**
     * Reference to the Members object
     * @returns {Members}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'getMembers',
    value: function getMembers() {
      return this.members;
    }

    /**
     * If this gets turned off mid meeting after attaching media, it will shut down the MQA metrics and they will
     * not restart unless the start function is called again
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'cleanMQAInterval',
    value: function cleanMQAInterval() {
      if (this.mqaInterval) {
        clearInterval(this.mqaInterval);
      }
    }

    /**
     * Automatically publishes media metrics data and on a config interval
     * uses the existing getStats data filter, so no new streams are created
     * but it is separate than history, so history will not be available
     * @returns {MediaMetrics}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'startMediaQualityMetrics',
    value: function startMediaQualityMetrics() {
      var _this13 = this;

      var automaticMetrics = new _metrics4.default({ config: this.config });

      var stats = this.getStats(automaticMetrics.initialize(), true);

      this.mediaQualityMetrics = automaticMetrics;

      this.mediaQualityMetrics.setStats(stats);

      this.mqaInterval = setInterval(function () {
        return _this13.processMQAData();
      }, this.config.metrics.mqaMetricsInterval);

      return automaticMetrics;
    }

    /**
     * @private
     * @returns {undefined}
     * @memberof Meeting
     */

  }, {
    key: 'processMQAData',
    value: function processMQAData() {
      var _this14 = this;

      if (!this.mqaProcessor) {
        this.mqaProcessor = new _mqaProcessor2.default();
      }

      _constants.MQA_STATS.DATA_PLACEMENTS.forEach(function (key) {
        if (_this14.mediaQualityMetrics && _this14.mediaQualityMetrics.stats) {
          var sendRecvData = void 0;

          if (key.toLowerCase().endsWith(_constants.STATS.SENDER)) {
            sendRecvData = _this14.mediaQualityMetrics.stats.getSender(key);
          } else if (key.toLowerCase().endsWith(_constants.STATS.RECEIVER)) {
            sendRecvData = _this14.mediaQualityMetrics.stats.getReceiver(key);
          }
          var mqa = void 0;

          if (sendRecvData) {
            mqa = sendRecvData.getMQA();
          }
          if (mqa) {
            var interval = mqa.getSlice(_this14.config.metrics.mqaMetricsInterval / 1000); // milliseconds -> second based intervals

            _this14.mqaProcessor.process(key, interval);
          }
        }
      });
      _metrics2.default.postEvent({ event: _config.eventType.MEDIA_QUALITY, meetingId: this.id, data: { intervalData: this.mqaProcessor.getData() } });
    }

    /**
     * Reference to the stats builder object
     * @param {Object} options - see #createStats
     * @param {Boolean} override - override the previous getStats
     * @returns {WebRTCStats}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'getStats',
    value: function getStats(options, override) {
      if (!this.stats) {
        return this.createStats(options);
      }
      if (override) {
        if (this.stats) {
          _loggerProxy2.default.logger.log('Meeting:index#getStats --> Overriding the previous stats object without destroying first can result in memory leaks.');
        }

        return this.createStats(options);
      }

      return this.stats;
    }

    /**
     * write the stats builder object and assign to meeting property
     * @param {Object} options
     * @returns {WebRTCStats}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'createStats',
    value: function createStats() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _util6.default.generateOptions(options, _constants.STATS.CONFIG, this);

      options.config = _constants.STATS.CONFIG;

      this.stats = new _index6.default(this.attrs, this.options, options);

      return this.stats;
    }

    /**
     * if you have started a stats instance, here's how you can stop it
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'stopStats',
    value: function stopStats() {
      if (this.stats) {
        this.stats.destroySenders();
        this.stats.destroyReceivers();
        this.stats = null;
      }
    }

    /**
     * Convenience function to tell whether a meeting is muted
     * @returns {Boolean} if meeting audio muted or not
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isAudioMuted',
    value: function isAudioMuted() {
      return this.audio && this.audio.isMuted();
    }

    /**
     * Convenience function to tell if the end user last changed the audio state
     * @returns {Boolean} if audio was manipulated by the end user
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isAudioSelf',
    value: function isAudioSelf() {
      return this.audio && this.audio.isSelf();
    }

    /**
     * Convenience function to tell whether video is muted
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isVideoMuted',
    value: function isVideoMuted() {
      return this.video && this.video.isMuted();
    }

    /**
     * Convenience function to tell whether the end user changed the video state
     * @returns {Boolean} if meeting video is muted or not
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'isVideoSelf',
    value: function isVideoSelf() {
      return this.video && this.video.isSelf();
    }

    /**
     * Sets the meeting info on the class instance
     * @param {Object} meetingInfo
     * @param {Object} meetingInfo.body
     * @param {String} meetingInfo.body.conversationUrl
     * @param {String} meetingInfo.body.locusUrl
     * @param {String} meetingInfo.body.sipUri
     * @param {Object} meetingInfo.body.owner
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'parseMeetingInfo',
    value: function parseMeetingInfo(meetingInfo) {
      // MeetingInfo will be undefined for 1:1 calls
      if (meetingInfo && meetingInfo.body && !(meetingInfo.errors && meetingInfo.errors.length > 0)) {
        this.convoUrl = meetingInfo.body.conversationUrl || this.convoUrl;
        this.locusUrl = meetingInfo.body.locusUrl || this.locusUrl;
        this.setSipUri(meetingInfo.body.sipMeetingUri || this.sipUri);
        this.owner = meetingInfo.body.owner || this.owner;
      }
    }

    /**
     * Sets the first locus info on the class instance
     * @param {Object} locus
     * @param {String} locus.url
     * @param {Array} locus.participants
     * @param {Object} locus.self
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'parseLocus',
    value: function parseLocus(locus) {
      if (locus) {
        this.locusUrl = locus.url;
        // TODO: move this to parse participants module
        this.setLocus(locus);

        // check if we can extract this info from partner
        // Parsing of locus object must be finished at this state
        if (locus.participants && locus.self) {
          this.partner = _util2.default.getLocusPartner(locus.participants, locus.self);
        }

        // For webex meeting the sipUrl gets updated in info parser
        if (!this.sipUri && this.partner && this.type === _constants._CALL_) {
          this.setSipUri(this.partner.person.sipUrl || this.partner.person.emailAddress || this.partner.person.email);
        }
      }
    }

    /**
     * Sets the sip uri on the class instance
     * uses meeting info as precedence
     * @param {String} sipUri
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setSipUri',
    value: function setSipUri(sipUri) {
      // This can be tel no, device id or a sip uri, user Id
      this.sipUri = sipUri;
    }

    /**
     * Set the roap seq on the class instance
     * @param {Number} seq
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setRoapSeq',
    value: function setRoapSeq(seq) {
      if (seq >= 0) {
        this.roapSeq = seq;
      }
    }

    /**
     * Set the locus info the class instance
     * @param {Object} locus
     * @param {Array} locus.mediaConnections
     * @param {String} locus.locusUrl
     * @param {String} locus.locusId
     * @param {String} locus.mediaId
     * @param {Object} locus.host
     * @todo change name to genertic parser
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setLocus',
    value: function setLocus(locus) {
      var mtgLocus = locus.locus || locus;

      // LocusInfo object saves the locus object
      // this.locus = mtgLocus;
      this.mediaConnections = locus.mediaConnections;
      this.locusUrl = locus.locusUrl || locus.url;
      this.locusId = locus.locusId;
      this.selfId = locus.selfId;
      this.mediaId = locus.mediaId;
      this.hostId = mtgLocus.host ? mtgLocus.host.id : this.hostId;
      this.locusInfo.initialSetup(mtgLocus);
    }

    /**
     * Sets the remote stream on the class instance and emits and
     * event to developers
     * @param {Object} pc The remote stream peer connection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setRemoteStream',
    value: function setRemoteStream(pc) {
      var _this15 = this;

      if (!pc) {
        return;
      }
      // eslint-disable-next-line no-param-reassign
      pc.ontrack = function (event) {
        // eslint-disable-next-line no-warning-comments
        // TODO: It's possible for media to not be present
        // so we might need to either
        // A) wait until we have media flowing
        // B) trigger a second event when video is flowing
        _loggerProxy2.default.logger.log('Meeting:index->setRemoteStream/ontrack#Event received for peerConnection: ' + event);
        // const {transceiver} = event;
        var streams = event.streams[0];

        _this15.mediaProperties.remoteStream = streams;

        _triggerProxy2.default.trigger(_this15, {
          file: 'meeting/index',
          function: 'setRemoteStream:pc.ontrack'
        }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.REMOTE_AUDIO,
          stream: _util4.default.createMediaStream([_this15.mediaProperties.remoteStream.getAudioTracks()[0]])
        });

        _triggerProxy2.default.trigger(_this15, {
          file: 'meeting/index',
          function: 'setRemoteStream:pc.ontrack'
        }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.REMOTE_VIDEO,
          stream: _util4.default.createMediaStream([_this15.mediaProperties.remoteStream.getVideoTracks()[0]])
        });

        if (_this15.mediaProperties.remoteStream.getVideoTracks()[1]) {
          _triggerProxy2.default.trigger(_this15, {
            file: 'meeting/index',
            function: 'setRemoteStream:pc.ontrack'
          }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
            type: _constants.EVENT_TYPES.REMOTE_SHARE,
            stream: _util4.default.createMediaStream([_this15.mediaProperties.remoteStream.getVideoTracks()[1]])
          });
        }
      };
    }

    /**
     * Removes the remote stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetRemoteStream',
    value: function unsetRemoteStream() {
      this.mediaProperties.unsetRemoteStream();
    }

    /**
     * Removes the remote stream on the class instance and triggers an event
     * to developers
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closeRemoteStream',
    value: function closeRemoteStream() {
      var _this16 = this;

      return _media2.default.stopStream(this.mediaProperties.remoteStream).then(function () {
        _triggerProxy2.default.trigger(_this16, {
          file: 'meeting/index',
          function: 'closeRemoteStream'
        }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: _constants.EVENT_TYPES.REMOTE
        });
      });
    }

    /**
     * Sets the sceen stream on the class instance and triggers and event to developers
     * @param {Object} pc a peer connection instance for the screen
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setShareStream',
    value: function setShareStream(pc) {
      var _this17 = this;

      if (!pc) {
        return;
      }
      // eslint-disable-next-line no-param-reassign
      pc.ontrack = function (event) {
        var _event$streams = (0, _slicedToArray3.default)(event.streams, 1);

        _this17.mediaProperties.remoteShare = _event$streams[0];

        _triggerProxy2.default.trigger(_this17, {
          file: 'meeting/index',
          function: 'setShareStream:pc.ontrack'
        }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.REMOTE_SHARE,
          stream: _this17.mediaProperties.remoteShare
        });
      };
    }

    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {Stream} localStream the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setLocalTracks',
    value: function setLocalTracks(localStream) {
      if (localStream) {
        var _MeetingUtil$getTrack = _util2.default.getTrack(localStream),
            audioTrack = _MeetingUtil$getTrack.audioTrack,
            videoTrack = _MeetingUtil$getTrack.videoTrack;

        var settings = null;

        if (audioTrack) {
          settings = audioTrack.getSettings();
          this.mediaProperties.setMediaSettings('audio', {
            echoCancellation: settings.echoCancellation,
            noiseSuppression: settings.noiseSuppression
          });

          _loggerProxy2.default.logger.log('meeting/setLocalTracks: Audio settings.', (0, _stringify2.default)(this.mediaProperties.mediaSettings.audio));
          this.mediaProperties.setLocalAudioTrack(audioTrack);
        }

        if (videoTrack) {
          settings = videoTrack.getSettings();
          this.mediaProperties.setLocalVideoTrack(videoTrack);
          this.mediaProperties.setMediaSettings('video', {
            aspectRatio: settings.aspectRatio,
            frameRate: settings.frameRate,
            height: settings.height,
            width: settings.width
          });
          _loggerProxy2.default.logger.log('meeting/setLocalTracks: Video settings.', (0, _stringify2.default)(this.mediaProperties.mediaSettings.video));
        }

        _triggerProxy2.default.trigger(this, {
          file: 'meeting/index',
          function: 'setLocalTracks'
        }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.LOCAL,
          stream: _util4.default.createMediaStream([this.mediaProperties.audioTrack, this.mediaProperties.videoTrack])
        });
      }
    }

    /**
     * Sets the local media stream on the class and emits an event to the developer
     * @param {Stream} localShare the local media stream
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'setLocalShareTrack',
    value: function setLocalShareTrack(localShare) {
      var _this18 = this;

      var settings = null;

      if (localShare) {
        this.mediaProperties.setLocalShareTrack(_util2.default.getTrack(localShare).videoTrack);
        var contentTracks = this.mediaProperties.shareTrack;

        if (contentTracks) {
          settings = contentTracks.getSettings();
          this.mediaProperties.setMediaSettings('screen', {
            aspectRatio: settings.aspectRatio,
            frameRate: settings.frameRate,
            height: settings.height,
            width: settings.width,
            displaySurface: settings.displaySurface,
            cursor: settings.cursor
          });
          _loggerProxy2.default.logger.log('meeting/setLocalTracks: Screen settings.', (0, _stringify2.default)(this.mediaProperties.mediaSettings.screen));
        }

        contentTracks.onended = function () {
          if (_this18.wirelessShare) {
            _this18.leave({ reason: _constants.MEETING_REMOVED_REASON.USER_ENDED_SHARE_STREAMS });
          } else {
            _this18.stopShare();
          }
        };

        _triggerProxy2.default.trigger(this, {
          file: 'meeting/index',
          function: 'setLocalShareTrack'
        }, _constants.EVENT_TRIGGERS.MEDIA_READY, {
          type: _constants.EVENT_TYPES.LOCAL_SHARE,
          stream: localShare
        });
      }
    }

    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closeLocalStream',
    value: function closeLocalStream() {
      var _this19 = this;

      return _media2.default.stopTracks(this.mediaProperties.audioTrack).then(function () {
        return _media2.default.stopTracks(_this19.mediaProperties.videoTrack);
      }).then(function () {
        _triggerProxy2.default.trigger(_this19, {
          file: 'meeting/index',
          function: 'closeLocalStream'
        }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: _constants.EVENT_TYPES.LOCAL
        });
      });
    }

    /**
     * Closes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @event media:stopped
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closeLocalShare',
    value: function closeLocalShare() {
      var _this20 = this;

      return _media2.default.stopTracks(this.mediaProperties.shareTrack).then(function () {
        _triggerProxy2.default.trigger(_this20, {
          file: 'meeting/index',
          function: 'closeLocalShare'
        }, _constants.EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: _constants.EVENT_TYPES.LOCAL_SHARE
        });
      });
    }

    /**
     * Removes the local stream from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetLocalVideoTrack',
    value: function unsetLocalVideoTrack() {
      this.mediaProperties.unsetLocalVideoTrack();
    }

    /**
     * Removes the local share from the class and emits an event to the developer
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetLocalShareTrack',
    value: function unsetLocalShareTrack() {
      this.mediaProperties.unsetLocalShareTrack();
    }

    /**
     * Sets the peer connections on the class
     * sets up reconnection logic
     * @returns {undefined}
     * @public
     * @memberof Meeting
     * @todo remove
     * // TODO: remove??
     */

  }, {
    key: 'setPeerConnections',
    value: function setPeerConnections() {
      var _this21 = this;

      // TODO: need to test more with the triggers for reconnect, we also need to add triggers based on getStats reports
      if (this.config.reconnection.detection) {
        // Client will have a socket manager and handle reconnecting to mercury, when we reconnect to mercury
        // if the meeting has active peer connections, it should try to reconnect.
        this.webex.internal.mercury.on(_constants.ONLINE, function () {
          _this21.reconnect();
        });
      }
    }

    /**
     * Close the peer connections and remove them from the class. Triggers an event
     * when each is closed.
     * @returns {Promise} returns a resolved promise with an array of closed peer connections
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'closePeerConnections',
    value: function closePeerConnections() {
      return _peerConnectionManager2.default.close(this.mediaProperties.peerConnection);
    }

    /**
     * Unsets the peer connections on the class
     * warning DO NOT CALL WITHOUT CLOSING PEER CONNECTIONS FIRST
     * @param {PeerConnection} peerConnection
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unsetPeerConnections',
    value: function unsetPeerConnections() {
      this.mediaProperties.unsetPeerConnection();
      if (this.config.reconnection.detection) {
        this.webex.internal.mercury.off(_constants.ONLINE);
      }
    }

    /**
     * Convenience method to set the correlation id for the Meeting
     * @param {String} id correlation id to set on the class
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'setCorrelationId',
    value: function setCorrelationId(id) {
      this.correlationId = id;
    }

    /**
     * Mute the audio for a meeting
     * @returns {Promise} resolves the data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'muteAudio',
    value: function muteAudio() {
      var _this22 = this;

      if (!this.audio || this.audio && !this.audio.toggle) {
        return _promise2.default.reject(new _parameter2.default('no audio control associated to the meeting'));
      }

      return this.audio.toggle({
        mute: true,
        self: true
      }).then(function () {
        _loggerProxy2.default.logger.info('meeting/index->muteAudio#Audio mute successful.');
        _metrics2.default.postEvent({
          event: _config.eventType.MUTED,
          meeting: _this22,
          data: { trigger: _config.trigger.USER_INTERACTION, mediaType: _config.mediaType.AUDIO }
        });

        return _promise2.default.resolve();
      }).catch(function (e) {
        _loggerProxy2.default.logger.error('meeting/index->muteAudio#Audio mute error ' + e);
      });
    }

    /**
     * Unmute meeting audio
     * @returns {Promise} resolves data from muting audio {mute, self} or rejects if there is no audio set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unmuteAudio',
    value: function unmuteAudio() {
      var _this23 = this;

      if (!this.audio || this.audio && !this.audio.toggle) {
        return _promise2.default.reject(new _parameter2.default('no audio control associated to the meeting'));
      }

      return this.audio.toggle({
        mute: false,
        self: true
      }).then(function () {
        _metrics2.default.postEvent({
          event: _config.eventType.UNMUTED,
          meeting: _this23,
          data: { trigger: _config.trigger.USER_INTERACTION, mediaType: _config.mediaType.AUDIO }
        });
      });
    }

    /**
     * Mute the video for a meeting
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'muteVideo',
    value: function muteVideo() {
      var _this24 = this;

      if (!this.video || this.video && !this.video.toggle) {
        return _promise2.default.reject(new _parameter2.default('no video control associated to the meeting'));
      }

      return this.video.toggle({
        mute: true,
        self: true
      }).then(function () {
        _metrics2.default.postEvent({
          event: _config.eventType.MUTED,
          meeting: _this24,
          data: { trigger: _config.trigger.USER_INTERACTION, mediaType: _config.mediaType.VIDEO }
        });
      });
    }

    /**
     * Unmute meeting video
     * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unmuteVideo',
    value: function unmuteVideo() {
      var _this25 = this;

      if (!this.video || this.video && !this.video.toggle) {
        return _promise2.default.reject(new _parameter2.default('no audio control associated to the meeting'));
      }
      var options = {};

      options.mute = false;
      options.self = true;

      return this.video.toggle({
        mute: false,
        self: true
      }).then(function () {
        _metrics2.default.postEvent({
          event: _config.eventType.UNMUTED,
          meeting: _this25,
          data: { trigger: _config.trigger.USER_INTERACTION, mediaType: _config.mediaType.VIDEO }
        });
      });
    }

    /**
     * Shorthand function to join AND set up media
     * @param {Object} options - options to join with media
     * @param {JoinOptions} [options.joinOptions] - see #join()
     * @param {MediaDirection} options.mediaSettings - see #addMedia()
     * @param {AudioVideo} [options.audioVideoOptions] - see #getMediaStreams()
     * @returns {Promise} -- {join: see join(), media: see addMedia(), local: see getMediaStreams()}
     * @public
     * @memberof Meeting
     * @example
     * joinWithMedia({
     *  joinOptions: {resourceId: 'resourceId' },
     *  mediaSettings: {
     *   sendAudio: true,
     *   sendVideo: true,
     *   sendShare: false,
     *   receiveVideo:true,
     *   receiveAudio: true,
     *   receiveShare: true
     * }
     * audioVideoOptions: {
     *   audio: 'audioDeviceId',
     *   video: 'videoDeviceId'
     * }})
     */

  }, {
    key: 'joinWithMedia',
    value: function joinWithMedia() {
      var _this26 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // TODO: add validations for parameters
      var mediaSettings = options.mediaSettings,
          joinOptions = options.joinOptions,
          audioVideoOptions = options.audioVideoOptions;


      return this.join(joinOptions).then(function (joinResponse) {
        return _this26.getMediaStreams(mediaSettings, audioVideoOptions).then(function (_ref) {
          var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
              localStream = _ref2[0],
              localShare = _ref2[1];

          return _this26.addMedia({
            mediaSettings: mediaSettings,
            localShare: localShare,
            localStream: localStream
          }).then(function (mediaResponse) {
            return {
              join: joinResponse,
              media: mediaResponse,
              local: [localStream, localShare]
            };
          });
        });
      }).catch(function (error) {
        return _promise2.default.reject(error);
      });
    }

    /**
     * Initiates the reconnection of the media in the meeting
     * @returns {Promise} resolves with {reconnect} or errors with {error}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'reconnect',
    value: function reconnect() {
      var _this27 = this;

      if (!this.reconnectionManager || !this.reconnectionManager.reconnect) {
        throw new _parameter2.default('Cannot reconnect, ReconnectionManager must first be defined.');
      }
      _triggerProxy2.default.trigger(this, {
        file: 'meeting/index',
        function: 'reconnect'
      }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_STARTING);
      _metrics2.default.postEvent({ event: _config.eventType.MEDIA_RECONNECTING, meeting: this });

      return this.reconnectionManager.reconnect(this).then(function (reconnect) {
        _triggerProxy2.default.trigger(_this27, {
          file: 'meeting/index',
          function: 'reconnect'
        }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_SUCCESS, {
          reconnect: reconnect
        });
        _metrics2.default.postEvent({
          event: _config.eventType.MEDIA_RECOVERED,
          meeting: _this27
        });

        return _promise2.default.resolve(reconnect);
      }).catch(function (error) {
        _triggerProxy2.default.trigger(_this27, {
          file: 'meeting/index',
          function: 'reconnect'
        }, _constants.EVENT_TRIGGERS.MEETING_RECONNECTION_FAILURE, {
          error: new _reconnection2.default('Reconnection failure event', error)
        });
        _metrics2.default.postEvent({
          event: _config.eventType.MEDIA_RECONNECTION_FAILED,
          meeting: _this27
        });

        return _promise2.default.reject(new _reconnection2.default('Reconnection failure event', error));
      }).finally(function (reconnect) {
        _this27.reconnectionManager.reset();

        return _promise2.default.resolve(reconnect);
      });
    }

    /**
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {JoinOptions} options A configurable options object for joining a meeting
     * @returns {Promise} the join response
     * @public
     * @memberof Meeting
     * Scenario A: Joining own claimed personal meeting room, don't pass hostPin, do pass moderator
     * Scenario B: Joining other's claimed personal meeting room, do pass hostPin (if desired to join as host, or nullify), do pass moderator
     * Scenario C: Joining an unclaimed personal meeting room, -do not- pass hostPin or moderator on first try, -do- pass hostPin and moderator
     *             if joining as host on second loop, -do not- pass hostPin do pass moderator if joining as guest on second loop
     * Scenario D: Joining any other way (sip, pstn, convoUrl, link just need to specify resourceId)
     */

  }, {
    key: 'join',
    value: function join() {
      var _this28 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // If Move or PSTN try merging into one
      if (false) {
        _metrics2.default.postEvent({
          event: _config.eventType.CALL_INITIATED,
          meeting: this,
          data: { pstnAudioType: 'DIAL_IN' }
        });
      } else {
        _metrics2.default.postEvent({
          event: _config.eventType.CALL_INITIATED,
          meeting: this,
          data: { trigger: _config.trigger.USER_INTERACTION }
        });
      }

      // Should PIN collection be followed by pin propt ???
      if (options.hostPin) {
        _metrics2.default.pinCollection({ meeting: this });
      }

      if (this.meetingFiniteStateMachine.state === _constants.MEETING_STATE_MACHINE.STATES.ENDED) {
        this.meetingFiniteStateMachine.reset();
      }
      if (this.meetingFiniteStateMachine.state !== _constants.MEETING_STATE_MACHINE.STATES.RINGING) {
        this.meetingFiniteStateMachine.ring(_constants._JOIN_);
      }

      // TODO: does this really need to be here?
      if (options.resourceId && this.destination && options.resourceId === this.destination) {
        this.wirelessShare = true;
      }

      return _util2.default.joinMeetingOptions(this, options).then(function (join) {
        _this28.meetingFiniteStateMachine.join();

        return _promise2.default.resolve(join);
      }).catch(function (error) {
        _this28.meetingFiniteStateMachine.fail(error);

        return _promise2.default.reject(error);
      });
    }

    /**
     * Moves the call to the specified resourceId
     * @param {String} resourceId
     * @returns {Promise} once the move has been completed
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'moveTo',
    value: function moveTo(resourceId) {
      var _this29 = this;

      if (!resourceId) {
        throw new _parameter2.default('Cannot move call without a resourceId.');
      }

      _metrics2.default.mediaCapabilities({
        meeting: this,
        data: {
          mediaCapabilities: {
            rx: {
              audio: false,
              share: false,
              share_audio: false,
              video: false,
              whiteboard: false
            },
            tx: {
              audio: false,
              share: false,
              share_audio: false,
              video: false,
              whiteboard: false
            }
          }
        }
      });
      _metrics2.default.moveMedia({ meeting: this });

      return _util2.default.joinMeetingOptions(this, { resourceId: resourceId, moveToResource: true }).then(function () {
        _this29.meetingFiniteStateMachine.join();

        return _this29.updateMedia({
          mediaSettings: {
            sendVideo: false, receiveVideo: false, sendAudio: false, receiveAudio: false, sendShare: false, receiveShare: false
          }
        }).then(function () {
          return _promise2.default.resolve(_this29);
        });
      }).catch(function (error) {
        _this29.meetingFiniteStateMachine.fail(error);

        return _promise2.default.reject(error);
      });
    }

    /**
     * Moves the call from the specified resourceId, back to computer
     * @param {String} resourceId
     * @returns {Promise} once the move has been completed
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'moveFrom',
    value: function moveFrom(resourceId) {
      var _this30 = this;

      if (!resourceId) {
        throw new _parameter2.default('Cannot move call without a resourceId.');
      }
      var oldCorrelationId = this.correlationId;

      this.id = _uuid2.default.v4();

      this.webex.meetings.meetingCollection.set(this);

      _metrics2.default.mediaCapabilities({
        meeting: this,
        data: {
          mediaCapabilities: {
            rx: {
              audio: true,
              share: true,
              share_audio: true,
              video: true,
              whiteboard: true
            },
            tx: {
              audio: true,
              share: true,
              share_audio: true,
              video: true,
              whiteboard: true
            }
          }
        }
      });
      _metrics2.default.moveMedia({ meeting: this });

      return _util2.default.joinMeetingOptions(this).then(function (join) {
        return _this30.getMediaStreams({ sendAudio: true, sendVideo: true, sendShare: false }).then(function (_ref3) {
          var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
              localStream = _ref4[0],
              localShare = _ref4[1];

          return _this30.updateMedia({
            mediaSettings: {
              sendAudio: true, receiveAudio: true, sendVideo: true, receiveVideo: true, sendShare: false, receiveShare: false
            },
            localStream: localStream,
            localShare: localShare
          }).then(function () {
            return _promise2.default.resolve(join);
          });
        }).then(function () {
          return _util2.default.leaveMeeting(_this30, { resourceId: resourceId, correlationId: oldCorrelationId, moveMeeting: true });
        });
      }).then(function () {
        _this30.webex.meetings.meetingCollection.delete(oldCorrelationId);

        return _promise2.default.resolve();
      });
    }

    /**
     * Get local media streams based on options passed
     * @param {MediaDirection} mediaDirection A configurable options object for joining a meeting
     * @param {AudioVideo} [audioVideo] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia
     * @param {SharePreferences} [sharePreferences] audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia
     * @returns {Promise} see #Media.getUserMedia
     * @public
     * @todo should be static, or moved so can be called outside of a meeting
     * @memberof Meeting
     */


    /**
     * Get the devices from the Media module
     * @returns {Promise} resolves to an array of DeviceInfo
     * @memberof Meetings
     */

  }, {
    key: 'addMedia',


    /**
     * Specify joining via audio (option: pstn), video, screenshare
     * @param {Object} options A configurable options object for joining a meeting
     * @param {Object} options.resourceId pass the deviceId
     * @param {MediaDirection} options.mediaSettings pass media options
     * @param {MediaStream} options.localStream
     * @param {MediaStream} options.localShare
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */
    value: function addMedia() {
      var _this31 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (_util2.default.isGuestUnjoined(this.locusInfo) && !this.wirelessShare) {
        return _promise2.default.reject(new _media4.default('To add media, the ' + (this.guest ? 'guest' : '') + ' user must be ' + (this.guest ? 'admitted. Wait to be admitted' : 'joined to the meeting') + ' to call addMedia'));
      }
      var localStream = options.localStream,
          localShare = options.localShare,
          mediaSettings = options.mediaSettings;


      _metrics2.default.postEvent({
        event: _config.eventType.MEDIA_CAPABILITIES,
        meeting: this,
        data: {
          mediaCapabilities: {
            rx: {
              audio: false,
              share: false,
              share_audio: false,
              video: false,
              whiteboard: false
            },
            tx: {
              audio: false,
              share: false,
              share_audio: false,
              video: false,
              whiteboard: false
            }
          }
        }
      });

      return _util2.default.validateOptions(options).then(function () {
        if (!_this31.mediaProperties.peerConnection) {
          _this31.mediaProperties.setMediaPeerConnection(_util4.default.createPeerConnection());
        }
        _util2.default.setPeerConnectionEvents(_this31);

        return _this31.preMedia(localStream, localShare, mediaSettings);
      }).then(function () {
        return _media2.default.attachMedia(_this31.mediaProperties, _this31.id).then(function (peerConnection) {
          _loggerProxy2.default.logger.log('Meeting:index->addMedia#PeerConnection Received from attachMedia ' + peerConnection);
          _this31.setRemoteStream(peerConnection);
          if (_this31.config.metrics.autoSendMQA) {
            _this31.startMediaQualityMetrics();
          }
          _util2.default.startInternalStats(_this31);
        }).catch(function (err) {
          _this31.logger.error('Meeting:index#join --> Error joining the call on roap initialization, ', err);
          throw err;
        }).then(function () {
          return new _promise2.default(function (resolve, reject) {
            var timerCount = 0;

            // eslint-disable-next-line func-names
            // eslint-disable-next-line prefer-arrow-callback
            if (_this31.type === _constants._CALL_) {
              resolve();
            }
            var joiningTimer = setInterval(function () {
              timerCount += 1;
              if (_this31.meetingState === _constants.FULL_STATE.ACTIVE) {
                clearInterval(joiningTimer);
                resolve();
              }

              if (timerCount === 4) {
                clearInterval(joiningTimer);
                reject(new Error('Meeting is still not active '));
              }
            }, 1000);
          });
        }).then(function () {
          return _this31.roap.sendRoapMediaRequest({
            sdp: _this31.mediaProperties.peerConnection.sdp,
            roapSeq: _this31.roapSeq,
            meeting: _this31 // or can pass meeting ID
          }).catch(function (err) {
            _this31.logger.error('Meeting:index#join --> Error joining the call on send roap media request, ', err);
            throw err;
          });
        }).then(function () {
          if (mediaSettings && mediaSettings.sendShare && localShare) {
            if (_this31.state === _constants.MEETING_STATE.STATES.JOINED) {
              return _this31.share();
            }

            // When the self state changes to JOINED then request the floor
            _this31.floorGrantPending = true;
          }

          return _promise2.default.resolve();
        });
      });
    }

    /**
     * Informs if the peer connection is in a state that can be updated with updateMedia (audio/video/share)
     * @returns {Boolean}
     */

  }, {
    key: 'canUpdateMedia',
    value: function canUpdateMedia() {
      return this.mediaProperties.peerConnection.signalingState === _constants.SDP.STABLE;
    }

    /**
     * A confluence of updateAudio, updateVideo, and updateShare
     * this function re-establishes all of the media streams with new options
     * @param {Object} options
     * @param {MediaStream} options.localStream
     * @param {MediaStream} options.localShare
     * @param {MediaDirection} options.mediaSettings
     * @returns {Promise}
     * @todo fix setRemoteStream for updateMedia
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'updateMedia',
    value: function updateMedia() {
      var _this32 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.canUpdateMedia()) {
        return _promise2.default.reject(new _media4.default('The peer connection is currently negotiation an offer. Please wait for a few seconds and try again.'));
      }
      var localStream = options.localStream,
          localShare = options.localShare,
          mediaSettings = options.mediaSettings;


      var previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;

      return _util2.default.validateOptions(options).then(function () {
        return _this32.preMedia(localStream, localShare, mediaSettings);
      }).then(function () {
        return _media2.default.updateMedia(_this32.mediaProperties, _this32.id).then(function (peerConnection) {
          _loggerProxy2.default.logger.log('Meeting:index->updateMedia#PeerConnection received from updateMedia, ' + peerConnection);
          _this32.setRemoteStream(peerConnection);
          if (mediaSettings.receiveShare || localShare) {
            _peerConnectionManager2.default.setContentSlides(peerConnection);
          }
        }).catch(function (err) {
          _loggerProxy2.default.logger.error('Meeting:index#updateMedia --> Error updatedMedia, ', err);
          throw err;
        }).then(function () {
          return _this32.roap.sendRoapMediaRequest({
            sdp: _this32.mediaProperties.peerConnection.sdp,
            roapSeq: _this32.roapSeq,
            meeting: _this32 // or can pass meeting ID
          }).catch(function (err) {
            _loggerProxy2.default.logger.error('Meeting:index#updateMedia --> Error updateMedia on send roap media request, ', err);
            throw err;
          });
        }).then(function () {
          return _this32.checkForStopShare(mediaSettings.sendShare, previousSendShareStatus);
        }).then(function (startShare) {
          // This is a special case if we do an /floor grant followed by /media
          // we actually get a OFFER from the server and a GLAR condition happens
          if (startShare) {
            // We are assuming that the clients are connected when doing an update
            return _this32.share();
          }

          return _promise2.default.resolve();
        });
      });
    }

    /**
     * Update the main audio streams with new parameters
     * @param {Object} options
     * @param {boolean} options.sendAudio
     * @param {boolean} options.receiveAudio
     * @param {MediaStream} [stream]
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'updateAudio',
    value: function updateAudio(options) {
      var _this33 = this;

      if (!this.canUpdateMedia()) {
        return _promise2.default.reject(new _media4.default('The peer connection is currently negotiation an offer. Please wait for a few seconds and try again.'));
      }
      var sendAudio = options.sendAudio,
          receiveAudio = options.receiveAudio,
          stream = options.stream;
      var audioTransceiver = this.mediaProperties.peerConnection.audioTransceiver;

      var track = _util2.default.getTrack(stream).audioTrack;

      if (typeof sendAudio !== 'boolean' || typeof receiveAudio !== 'boolean') {
        return _promise2.default.reject(new _parameter2.default('Pass sendVideo and receiveVideo parameter'));
      }

      return _util2.default.validateOptions({ sendAudio: sendAudio, localStream: stream }).then(function () {
        var previousMediaDirection = {};

        if (_this33.mediaProperties.mediaDirection) {
          previousMediaDirection = {
            sendTrack: _this33.mediaProperties.mediaDirection.sendAudio,
            receiveTrack: _this33.mediaProperties.mediaDirection.receiveAudio
          };
        } else {
          _this33.mediaProperties.mediaDirection = {};
        }

        return _util2.default.updateTransceiver({
          type: 'audio',
          sendTrack: options.sendAudio,
          receiveTrack: options.receiveAudio,
          track: track,
          transceiver: audioTransceiver,
          peerConnection: _this33.mediaProperties.peerConnection,
          previousMediaDirection: previousMediaDirection
        }, {
          mediaProperties: _this33.mediaProperties,
          roapSeq: _this33.roapSeq,
          meeting: _this33,
          id: _this33.id
        });
      }).then(function () {
        _this33.setLocalTracks(stream);
        _this33.mediaProperties.mediaDirection.sendAudio = sendAudio;
        _this33.mediaProperties.mediaDirection.receiveAudio = receiveAudio;

        // audio state could be undefined if you have not sent audio before
        _this33.audio = _this33.audio || _audio2.default.create(_this33.mediaProperties.mediaDirection, _this33);
      });
    }

    /**
     * Update the main video streams with new parameters
     * @param {Object} options
     * @param {boolean} options.sendVideo
     * @param {boolean} options.receiveVideo
     * @param {MediaStream} [stream]
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'updateVideo',
    value: function updateVideo(options) {
      var _this34 = this;

      if (!this.canUpdateMedia()) {
        return _promise2.default.reject(new _media4.default('The peer connection is currently negotiation an offer. Please wait for a few seconds and try again.'));
      }
      var sendVideo = options.sendVideo,
          receiveVideo = options.receiveVideo,
          stream = options.stream;
      var videoTransceiver = this.mediaProperties.peerConnection.videoTransceiver;

      var track = _util2.default.getTrack(stream).videoTrack;

      if (typeof sendVideo !== 'boolean' || typeof receiveVideo !== 'boolean') {
        return _promise2.default.reject(new _parameter2.default('Pass sendVideo and receiveVideo parameter'));
      }

      return _util2.default.validateOptions({ sendVideo: sendVideo, localStream: stream }).then(function () {
        return _util2.default.updateTransceiver({
          type: 'video',
          sendTrack: options.sendVideo,
          receiveTrack: options.receiveVideo,
          track: track,
          transceiver: videoTransceiver,
          peerConnection: _this34.mediaProperties.peerConnection,
          previousMediaDirection: {
            sendTrack: _this34.mediaProperties.mediaDirection.sendVideo,
            receiveTrack: _this34.mediaProperties.mediaDirection.receiveVideo
          }
        }, {
          mediaProperties: _this34.mediaProperties,
          roapSeq: _this34.roapSeq,
          meeting: _this34,
          id: _this34.id
        });
      }).then(function () {
        _this34.setLocalTracks(stream);
        _this34.mediaProperties.mediaDirection.sendVideo = sendVideo;
        _this34.mediaProperties.mediaDirection.receiveVideo = receiveVideo;

        // video state could be undefined if you have not sent video before
        _this34.video = _this34.video || _video2.default.create(_this34.mediaProperties.mediaDirection, _this34);
      });
    }

    /**
     * Internal function when stopping a share stream, cleanup
     * @param {boolean} sendShare
     * @param {boolean} previousShareStatus
     * @returns {Promise}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'checkForStopShare',
    value: function checkForStopShare(sendShare, previousShareStatus) {
      if (!this.isSharing && sendShare && !previousShareStatus) {
        // When user starts sharing
        // return this.share();
        return _promise2.default.resolve(true);
      }
      if (this.isSharing && !sendShare && previousShareStatus) {
        // When user stops sharing
        return this.stopShare().then(function () {
          return _promise2.default.resolve(false);
        });
      }

      return _promise2.default.resolve();
    }

    /**
     * Update the share streams, can be used to start sharing
     * @param {Object} options
     * @param {boolean} options.sendShare
     * @param {boolean} options.receiveShare
     * @param {MediaStream} [stream]
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'updateShare',
    value: function updateShare(options) {
      var _this35 = this;

      if (!this.canUpdateMedia()) {
        return _promise2.default.reject(new _media4.default('The peer connection is currently negotiation an offer. Please wait for a few seconds and try again.'));
      }
      var sendShare = options.sendShare,
          receiveShare = options.receiveShare,
          stream = options.stream;
      var shareTransceiver = this.mediaProperties.peerConnection.shareTransceiver;

      var track = _util2.default.getTrack(stream).videoTrack;

      if (typeof sendShare !== 'boolean' || typeof receiveShare !== 'boolean') {
        return _promise2.default.reject(new _parameter2.default('Pass sendShare and receiveShare parameter'));
      }
      var previousSendShareStatus = this.mediaProperties.mediaDirection.sendShare;

      return _util2.default.validateOptions({ sendShare: sendShare, localShare: stream }).then(function () {
        return _this35.checkForStopShare(sendShare, previousSendShareStatus);
      }).then(function (startShare) {
        return _util2.default.updateTransceiver({
          type: 'video',
          sendTrack: sendShare,
          receiveTrack: receiveShare,
          track: track,
          transceiver: shareTransceiver,
          peerConnection: _this35.mediaProperties.peerConnection,
          previousMediaDirection: {
            sendTrack: _this35.mediaProperties.mediaDirection.sendShare,
            receiveTrack: _this35.mediaProperties.mediaDirection.receiveShare
          }
        }, {
          mediaProperties: _this35.mediaProperties,
          roapSeq: _this35.roapSeq,
          meeting: _this35,
          id: _this35.id
        }).then(function () {
          if (startShare) {
            return _this35.share();
          }

          return _promise2.default.resolve();
        });
      }).then(function () {
        _this35.setLocalShareTrack(stream);
        _this35.mediaProperties.mediaDirection.sendShare = sendShare;
        _this35.mediaProperties.mediaDirection.receiveShare = receiveShare;
      });
    }

    /**
     * Do all the attach media pre set up before executing the actual attach
     * @param {MediaStream} localStream
     * @param {MediaStream} localShare
     * @param {MediaDirection} mediaSettings
     * @returns {undefined}
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'preMedia',
    value: function preMedia(localStream, localShare, mediaSettings) {
      // eslint-disable-next-line no-warning-comments
      // TODO wire into default config. There's currently an issue with the stateless plugin or how we register
      this.mediaProperties.setMediaDirection((0, _assign2.default)(this.config.mediaSettings, mediaSettings));
      // add a setup a function move the create and setup media in future
      // TODO: delete old audio and video if stale
      this.audio = this.audio || _audio2.default.create(this.mediaProperties.mediaDirection, this);
      this.video = this.video || _video2.default.create(this.mediaProperties.mediaDirection, this);
      // Validation is already done in addMedia so no need to check if the lenght is greater then 0
      this.setLocalTracks(localStream);
      this.setLocalShareTrack(localShare);
    }

    /**
     * Acknowledge the meeting, outgoing or incoming
     * @param {String} type
     * @returns {Promise} resolve {message, ringing, response}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'acknowledge',
    value: function acknowledge(type) {
      var _this36 = this;

      if (!type) {
        return _promise2.default.reject(new _parameter2.default('Type must be set to acknowledge the meeting.'));
      }
      if (type === _constants._INCOMING_) {
        return this.meetingRequest.acknowledgeMeeting({
          locusUrl: this.locusUrl,
          deviceUrl: this.deviceUrl,
          id: this.id
        }).then(function (response) {
          return _promise2.default.resolve(response);
        }).then(function (response) {
          _this36.meetingFiniteStateMachine.ring(type);
          _metrics2.default.postEvent({ event: _config.eventType.ALERT_DISPLAYED, meeting: _this36 });

          return _promise2.default.resolve({
            response: response
          });
        });
      }

      // TODO: outside of 1:1 incoming, and all outgoing calls
      return _promise2.default.resolve({
        message: 'noop'
      });
    }

    /**
     * Decline this meeting
     * @param {String} reason
     * @returns {undefined}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'decline',
    value: function decline() {
      var _this37 = this;

      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _constants._BUSY_;

      return _util2.default.declineMeeting(this, reason).then(function (decline) {
        _this37.meetingFiniteStateMachine.decline();

        return _promise2.default.resolve(decline);
      }).catch(function (error) {
        _this37.meetingFiniteStateMachine.fail(error);

        return _promise2.default.reject(error);
      });
    }

    /**
     * Leave the current meeting
     * @param {Object} options leave options
     * @param {String} options.resourceId the device with which to leave from, empty if just the computer
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'leave',
    value: function leave() {
      var _this38 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _metrics2.default.postEvent({ event: _config.eventType.LEAVE, meeting: this, data: { trigger: _config.trigger.USER_INTERACTION, canProceed: false } });
      var leaveReason = options.reason || _constants.MEETING_REMOVED_REASON.CLIENT_LEAVE_REQUEST;

      return _util2.default.leaveMeeting(this, options).then(function (leave) {
        _this38.meetingFiniteStateMachine.leave();
        // TODO: more testing before we remove this code, we are not sure the scenarios for destroy here
        if (_this38.wirelessShare || _this38.guest) {
          // If screen sharing clean the meeting object
          _triggerProxy2.default.trigger(_this38, {
            file: 'meeting/index',
            function: 'leave'
          }, _constants.EVENTS.DESTROY_MEETING, {
            reason: options.reason,
            meetingId: _this38.id
          });
        }
        _loggerProxy2.default.logger.log('LEAVE REASON ', leaveReason);

        return _promise2.default.resolve(leave);
      }).catch(function (error) {
        _this38.meetingFiniteStateMachine.fail(error);

        return _promise2.default.reject(error);
      });
    }

    /**
     * Start sharing content with server
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @private
     * @memberof Meeting
     */

  }, {
    key: 'share',
    value: function share() {
      var _this39 = this;

      var content = this.locusInfo.mediaShares.find(function (element) {
        return element.name === _constants.CONTENT;
      });

      if (content && !this.isSharing) {
        _metrics2.default.postEvent({ event: _config.eventType.SHARE_INITIATED, meeting: this });

        return this.meetingRequest.changeMeetingFloor({
          disposition: _constants.FLOOR_ACTION.GRANTED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: content.url,
          resourceUrl: this.resourceUrl
        }).then(function () {
          _this39.isSharing = true;
          _triggerProxy2.default.trigger(_this39, {
            file: 'meeting/index',
            function: 'share'
          }, _constants.EVENT_TRIGGERS.MEETING_STARTED_SHARING_LOCAL);
          _metrics2.default.postEvent({ event: _config.eventType.LOCAL_SHARE_FLOOR_GRANTED, meeting: _this39 });

          return _promise2.default.resolve();
        }).catch(function (e) {
          _loggerProxy2.default.logger.error('Meeting/index->share#Error ', e);

          return _promise2.default.reject(e);
        });
      }

      return _promise2.default.reject(new _parameter2.default('Cannot share without content.'));
    }

    /**
     * Stops the screen share
     * @returns {Promise} see #meetingRequest.changeMeetingFloor
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'stopShare',
    value: function stopShare() {
      var _this40 = this;

      var content = this.locusInfo.mediaShares.find(function (element) {
        return element.name === _constants.CONTENT;
      });

      if (content && this.isSharing) {
        _metrics2.default.postEvent({ event: _config.eventType.SHARE_STOPPED, meeting: this });
        _media2.default.stopTracks(this.mediaProperties.shareTrack);

        return this.meetingRequest.changeMeetingFloor({
          disposition: _constants.FLOOR_ACTION.RELEASED,
          personUrl: this.locusInfo.self.url,
          deviceUrl: this.deviceUrl,
          uri: content.url,
          resourceUrl: this.resourceUrl
        }).catch(function (e) {
          _loggerProxy2.default.logger.error('Meeting/index->stopShare#Error ', e);

          return _promise2.default.reject(e);
        }).finally(function () {
          _this40.isSharing = false;
          _triggerProxy2.default.trigger(_this40, {
            file: 'meeting/index',
            function: 'stopShare'
          }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL);
        });
      }

      return _promise2.default.reject(new _parameter2.default('Cannot stop share without content'));
    }

    /**
     * Intiate a recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'startRecording',
    value: function startRecording() {
      return _util2.default.startRecording(this.meetingRequest, this.locusUrl, this.locusInfo);
    }

    /**
     * End the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'stopRecording',
    value: function stopRecording() {
      return _util2.default.stopRecording(this.meetingRequest, this.locusUrl, this.locusInfo);
    }

    /**
     * Pauses the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'pauseRecording',
    value: function pauseRecording() {
      return _util2.default.pauseRecording(this.meetingRequest, this.locusUrl, this.locusInfo);
    }

    /**
     * Resumes the recording of this meeting
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'resumeRecording',
    value: function resumeRecording() {
      return _util2.default.resumeRecording(this.meetingRequest, this.locusUrl, this.locusInfo);
    }

    /**
     * Locks the current meeting if possible
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'lockMeeting',
    value: function lockMeeting() {
      return _util2.default.lockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);
    }

    /**
     * Unlocks the current meeting if possible
     * @returns {Promise}
     * @public
     * @memberof Meeting
     */

  }, {
    key: 'unlockMeeting',
    value: function unlockMeeting() {
      return _util2.default.unlockMeeting(this.inMeetingActions, this.meetingRequest, this.locusUrl);
    }
  }]);
  return Meeting;
}(_webexCore.StatelessWebexPlugin);

exports.default = Meeting;
//# sourceMappingURL=index.js.map
