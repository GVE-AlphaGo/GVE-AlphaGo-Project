'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _javascriptStateMachine = require('javascript-state-machine');

var _javascriptStateMachine2 = _interopRequireDefault(_javascriptStateMachine);

var _history = require('javascript-state-machine/lib/history');

var _history2 = _interopRequireDefault(_history);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

var _util = require('../meeting/util');

var _util2 = _interopRequireDefault(_util);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var handleTransition = function handleTransition(video) {
  if (video.mute && video.self) {
    return _constants.MEETING_VIDEO_STATE_MACHINE.STATES.MUTE_SELF;
  }
  if (!video.mute && video.self) {
    return _constants.MEETING_VIDEO_STATE_MACHINE.STATES.UNMUTE_SELF;
  }

  return null;
};

var doToggle = function doToggle(transition, video, meeting) {
  _media2.default.setLocalTrack(video.mute, meeting.mediaProperties.videoTrack);
  var meetingAudio = meeting.audio;
  var audioMuted = meetingAudio ? meetingAudio.muted : true;

  return _util2.default.remoteUpdateAudioVideo(audioMuted, video.mute, meeting).then(function () {
    _loggerProxy2.default.logger.log('VideoStateMachine->onAfterToggle#' + transition.event + ' fired! State changed from \'' + transition.from + '\' to \'' + transition.to + '\' with transition \'' + transition.transition + '\'\'.');
  }).catch(function (remoteUpdateError) {
    _loggerProxy2.default.logger.log('VideoStateMachine->onBeforeToggle#' + transition.event + ' fired! State failed to change with transition \'' + transition.transition + '\'\'. After local Video toggle failed, resetting remote also failed, meeting video in bad state with error: ' + remoteUpdateError + '.');

    return _promise2.default.reject(remoteUpdateError);
  });
};

var VideoStateMachine = {
  /**
   *
   * @param {Object} mediaDirection object containing media direction
   * @param {Boolean} mediaDirection.sendVideo Whether or not to send video in the meeting
   * @param {Meeting} meeting an instance of a Meeting
   * @returns {Statemachine} returns a state machine instance
   */
  create: function create(mediaDirection, meeting) {
    if (!mediaDirection.sendVideo) {
      return undefined;
    }

    return new _javascriptStateMachine2.default({
      transitions: [{
        name: _constants.MEETING_VIDEO_STATE_MACHINE.TRANSITIONS.TOGGLE,
        from: '*',
        /**
         *
         * @param {Object} video current video data for the transition {mute, self}
         * @returns {String} a new state value for the transition
         */
        to: function to(video) {
          return handleTransition(video) || this.state;
        }
      }],
      data: {
        muted: false,
        self: true
      },
      methods: {
        /**
         * Convenience function to tell whether we are muted or not
         * @returns {Boolen} boolean that indicates whether the video is currently muted
         */
        isMuted: function isMuted() {
          return this.muted;
        },

        /**
         * Convenience function to tell who last muted/unmuted the video
         * @returns {Boolen} boolean that indicates whether the video was muted by the end user or server
         */
        isSelf: function isSelf() {
          return this.self;
        },


        /**
         *
         * @param {Object} video current video options to set on the state machine
         * @param {Boolean} video.mute indicates if video is muted or not for a meeting
         * @param {Boolean} video.self indicates whether the end user or server muted the video
         * @returns {null}
         */
        setData: function setData(video) {
          this.muted = video.mute;
          this.self = video.self;
        },


        /**
         * Method that gets fired before the toggle state change.
         * If this fails, return false will cancel the transition and the state will remain unchanged
          * @param {Object} transition the StateMachine transition object
         * @param {Object} video video options
         * @returns {Object} this.data which contains {muted, self}
         */
        onBeforeToggle: function onBeforeToggle(transition, video) {
          var _this = this;

          if (transition.from !== transition.to) {
            return doToggle(transition, video, meeting).then(function () {
              return _promise2.default.resolve(_this.data);
            });
          }

          return _promise2.default.resolve(this.data);
        },


        /**
         *
         * @param {Object} transition StateMachine transition
         * @param {Object} video video options
         * @returns {Object} this.data which contains {muted, self}
         */
        onAfterToggle: function onAfterToggle(transition, video) {
          this.setData(video);

          return _promise2.default.resolve(this.data);
        },

        plugins: [new _history2.default({ max: 5 })]
      }
    });
  }
};

exports.default = VideoStateMachine;
//# sourceMappingURL=video.js.map
