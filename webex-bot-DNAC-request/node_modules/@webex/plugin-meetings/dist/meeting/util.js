'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _util = require('../stats/util');

var _util2 = _interopRequireDefault(_util);

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

var _config = require('../metrics/config');

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _index = require('../stats/index');

var _index2 = _interopRequireDefault(_index);

var _constants = require('../constants');

var _intentToJoin = require('../common/errors/intent-to-join');

var _intentToJoin2 = _interopRequireDefault(_intentToJoin);

var _joinMeeting = require('../common/errors/join-meeting');

var _joinMeeting2 = _interopRequireDefault(_joinMeeting);

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

var _permission = require('../common/errors/permission');

var _permission2 = _interopRequireDefault(_permission);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MeetingUtil = {};

MeetingUtil.parseLocusJoin = function (response) {
  var parsed = {};

  // First todo: add check for existance
  parsed.locus = response.body.locus;
  parsed.mediaConnections = response.body.mediaConnections;
  parsed.locusUrl = parsed.locus.url;
  parsed.locusId = parsed.locus.url.split('/').pop();
  parsed.selfId = parsed.locus.self.id;

  // we need mediaId before making roap calls
  parsed.mediaConnections.forEach(function (mediaConnection) {
    if (mediaConnection.mediaId) {
      parsed.mediaId = mediaConnection.mediaId;
    }
  });

  return parsed;
};

MeetingUtil.remoteUpdateAudioVideo = function (audioMuted, videoMuted, meeting) {
  if (!meeting) {
    return _promise2.default.reject(new _parameter2.default('You need a meeting object.'));
  }
  var localMedias = _media2.default.generateLocalMedias(meeting.mediaId, audioMuted, videoMuted);

  if ((0, _isEmpty3.default)(localMedias)) {
    return _promise2.default.reject(new _parameter2.default('You need a media id on the meeting to change remote audio.'));
  }

  _metrics2.default.postEvent({ event: _config.eventType.MEDIA_REQUEST, meeting: meeting });

  return meeting.meetingRequest.remoteAudioVideoToggle({
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    localMedias: localMedias,
    deviceUrl: meeting.deviceUrl,
    correlationId: meeting.correlationId
  }).then(function (response) {
    _metrics2.default.postEvent({ event: _config.eventType.MEDIA_RESPONSE, meeting: meeting });
    meeting.locusInfo.onFullLocus(response.body.locus);
  });
};

MeetingUtil.checkShare = function (meeting) {
  if (meeting.wirelessShare && meeting.isSharing || meeting.isSharing) {
    return meeting.stopShare();
  }

  return _promise2.default.resolve();
};

// TODO: have locus ignore hostPin if they find out it's my claimed PMR
/*
for my claimed PMR
passing an "undefined" hostPin was causing the issue.
if I don't include hostPin in the first request, locus figures out it's my PMR
and sends a 200 after the first request
so we must clean up the hostPin to stop the double request
*/
MeetingUtil.cleanOptions = function (options, info, owner, userId) {
  if (MeetingUtil.hasOwner(info)) {
    if (MeetingUtil.isOwnerSelf(owner, userId)) {
      if (options.hostPin) {
        delete options.hostPin;
      }
      options.moderator = _constants.MODERATOR_TRUE;
    } else {
      options.moderator = _constants.MODERATOR_FALSE;
    }
  }

  return options;
};

MeetingUtil.hasOwner = function (info) {
  return info && info.owner;
};

MeetingUtil.isOwnerSelf = function (owner, selfId) {
  return owner === selfId;
};

MeetingUtil.isPinOrGuest = function (err) {
  if (err && err.body && err.body.errorCode === _constants.INTENT_TO_JOIN) {
    return true;
  }

  return false;
};

MeetingUtil.joinMeeting = function (meeting, options) {
  if (!meeting) {
    return _promise2.default.reject(new _parameter2.default('You need a meeting object.'));
  }

  _metrics2.default.postEvent({ event: _config.eventType.LOCAL_JOIN_REQUEST, meeting: meeting });

  // eslint-disable-next-line no-warning-comments
  // TODO: check if the meeting is in JOINING state
  // if Joining state termintate the request as user might click multiple times
  return meeting.meetingRequest.joinMeeting({
    sipUri: meeting.sipUri,
    deviceUrl: meeting.deviceUrl,
    locusUrl: meeting.locusUrl,
    correlationId: meeting.id,
    roapMessage: options.roapMessage,
    resourceId: options.resourceId || null,
    moderator: options.moderator,
    hostPin: options.hostPin,
    moveToResource: options.moveToResource
  }).then(function (res) {
    _metrics2.default.postEvent({
      event: _config.eventType.LOCUS_JOIN_RESPONSE,
      meeting: meeting,
      data: {
        trigger: _config.trigger.LOCI_UPDATE,
        locus: res.body.locus,
        trackingId: res.headers.trackingid
      }
    });

    return MeetingUtil.parseLocusJoin(res);
  });
};

MeetingUtil.cleanUp = function (meeting) {
  return meeting.closeLocalStream().then(function () {
    return meeting.closeLocalShare();
  }).then(function () {
    return meeting.closePeerConnections();
  }).then(function () {
    meeting.unsetLocalVideoTrack();
    meeting.unsetLocalShareTrack();
    meeting.unsetRemoteStream();
    meeting.unsetPeerConnections();
    meeting.cleanMQAInterval();
  }).then(function () {
    return meeting.roap.stop(meeting.correlationId, meeting.roapSeq);
  });
};

// by default will leave on meeting's resourceId
// if you explicity want it not to leave on resource id, pass
// {resourceId: null}
// TODO: chris, you can modify this however you want
MeetingUtil.leaveMeeting = function (meeting) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var defaultOptions = {
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    correlationId: meeting.correlationId,
    resourceId: meeting.resourceId,
    deviceUrl: meeting.deviceUrl
  };

  var leaveOptions = (0, _extends3.default)({}, defaultOptions, options);

  return meeting.meetingRequest.leaveMeeting(leaveOptions).then(function (response) {
    if (response && response.body && response.body.locus) {
      // && !options.moveMeeting) {
      meeting.locusInfo.onFullLocus(response.body.locus);
    }

    return _promise2.default.resolve();
  }).then(function () {
    if (options.moveMeeting) {
      return _promise2.default.resolve();
    }

    return MeetingUtil.cleanUp(meeting);
  }).catch(function (err) {
    _loggerProxy2.default.logger.error('MeetingUtil->leaveMeeting#An error occured while trying to leave meeting with an id of ' + meeting.id + ', error: ' + err);

    return _promise2.default.reject(err);
  });
};
MeetingUtil.declineMeeting = function (meeting, reason) {
  return meeting.meetingRequest.declineMeeting({
    locusUrl: meeting.locusUrl,
    deviceUrl: meeting.deviceUrl,
    reason: reason
  });
};

MeetingUtil.isGuestUnjoined = function (locusInfo) {
  return locusInfo.parsedLocus && locusInfo.parsedLocus.self && locusInfo.parsedLocus.self.guest && locusInfo.parsedLocus.self.state !== _constants._JOINED_;
};

MeetingUtil.joinMeetingOptions = function (meeting) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  meeting.resourceId = meeting.resourceId || options.resourceId;
  meeting.setCorrelationId(meeting.id);
  // TODO: this should be removed following locus changes.
  options = MeetingUtil.cleanOptions(options, meeting.meetingInfo, meeting.owner, meeting.userId);

  if (options.hostPin) {
    _metrics2.default.postEvent({
      event: _config.eventType.PIN_COLLECTED,
      meeting: meeting
    });
  }

  // normal join meeting, scenario A, D
  return MeetingUtil.joinMeeting(meeting, options).then(function (response) {
    meeting.setLocus(response);

    return _promise2.default.resolve(response);
  }).catch(function (err) {
    // joining a claimed PMR that is not my own, scenario B
    if (MeetingUtil.isPinOrGuest(err)) {
      if (MeetingUtil.hasOwner(meeting.meetingInfo)) {
        return MeetingUtil.joinMeeting(meeting, options).then(function (response) {
          meeting.setLocus(response);

          return _promise2.default.resolve();
        });
      }

      _metrics2.default.postEvent({
        event: _config.eventType.PIN_PROMPT,
        meeting: meeting
      });

      // request host pin or non host for unclaimed PMR, start of Scenario C
      // see https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-Lobby-and--IVR-Feature
      return _promise2.default.reject(new _intentToJoin2.default('Error Joining Meeting', err));
    }
    _loggerProxy2.default.logger.log('Meeting:index#join --> Error joining the call, ', err);

    return _promise2.default.reject(new _joinMeeting2.default(options, 'Error Joining Meeting', err));
  });
};

MeetingUtil.updateTransceiver = function (options, meetingOptions) {
  var type = options.type,
      sendTrack = options.sendTrack,
      receiveTrack = options.receiveTrack,
      track = options.track,
      transceiver = options.transceiver,
      peerConnection = options.peerConnection,
      previousMediaDirection = options.previousMediaDirection;


  if (sendTrack !== undefined && sendTrack !== previousMediaDirection.sendTrack || receiveTrack !== undefined && receiveTrack !== previousMediaDirection.receiveTrack) {
    return _media2.default.updateTransceiver(meetingOptions.id, peerConnection, transceiver, {
      track: track,
      type: type,
      receiveTrack: receiveTrack,
      sendTrack: sendTrack
    }).then(function () {
      return meetingOptions.meeting.roap.sendRoapMediaRequest({
        sdp: meetingOptions.mediaProperties.peerConnection.sdp,
        roapSeq: meetingOptions.roapSeq,
        meeting: meetingOptions.meeting // or can pass meeting ID
      });
    }).catch(function (e) {
      _loggerProxy2.default.logger.error('Meeting:index->updateTransceiver#Error updating the ' + type + ' streams with error: ' + e);
    });
  }if (track) {
    transceiver.sender.replaceTrack(track);

    return _promise2.default.resolve();
  }

  return _promise2.default.reject(new _parameter2.default('update Failed: please pass valid parameter'));
};

MeetingUtil.validateOptions = function (options) {
  var sendVideo = options.sendVideo,
      sendAudio = options.sendAudio,
      sendShare = options.sendShare,
      localStream = options.localStream,
      localShare = options.localShare;


  if (sendVideo && !MeetingUtil.getTrack(localStream).videoTrack) {
    return _promise2.default.reject(new _parameter2.default('please pass valid video streams'));
  }

  if (sendAudio && !MeetingUtil.getTrack(localStream).audioTrack) {
    return _promise2.default.reject(new _parameter2.default('please pass valid audio streams'));
  }

  if (sendShare && !MeetingUtil.getTrack(localShare).videoTrack) {
    return _promise2.default.reject(new _parameter2.default('please pass valid share streams'));
  }

  return _promise2.default.resolve();
};

MeetingUtil.getTrack = function (stream) {
  var audioTrack = null;
  var videoTrack = null;
  var audioTracks = null;
  var videoTracks = null;

  if (!stream) {
    return { audioTrack: null, videoTrack: null };
  }
  if (stream.getAudioTracks) {
    audioTracks = stream.getAudioTracks();
  }
  if (stream.getVideoTracks) {
    videoTracks = stream.getVideoTracks();
  }

  if (audioTracks && audioTracks.length > 0) {
    var _audioTracks = audioTracks;

    var _audioTracks2 = (0, _slicedToArray3.default)(_audioTracks, 1);

    audioTrack = _audioTracks2[0];
  }

  if (videoTracks && videoTracks.length > 0) {
    var _videoTracks = videoTracks;

    var _videoTracks2 = (0, _slicedToArray3.default)(_videoTracks, 1);

    videoTrack = _videoTracks2[0];
  }

  return { audioTrack: audioTrack, videoTrack: videoTrack };
};

MeetingUtil.getModeratorFromLocusInfo = function (locusInfo) {
  return locusInfo && locusInfo.parsedLocus && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info.moderator;
};

MeetingUtil.getPolicyFromLocusInfo = function (locusInfo) {
  return locusInfo && locusInfo.parsedLocus && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info && locusInfo.parsedLocus.info.policy;
};

MeetingUtil.canUserLock = function (moderator, joined) {
  if (moderator.LOCK_CONTROL_LOCK && joined.LOCK_STATUS_UNLOCKED) {
    return true;
  }

  return false;
};

MeetingUtil.canUserUnlock = function (moderator, joined) {
  if (moderator.LOCK_CONTROL_UNLOCK && joined.LOCK_STATUS_LOCKED) {
    return true;
  }

  return false;
};

MeetingUtil.canUserRecord = function (moderator) {
  return moderator.RECORDING_CONTROL_START;
};

MeetingUtil.canUserPause = function (moderator) {
  return moderator.RECORDING_CONTROL_PAUSE;
};

MeetingUtil.canUserResume = function (moderator) {
  return moderator.RECORDING_CONTROL_RESUME;
};

MeetingUtil.canUserStop = function (moderator) {
  return moderator.RECORDING_CONTROL_STOP;
};

MeetingUtil.startRecording = function (request, locusUrl, locusInfo) {
  var moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserRecord(moderator)) {
    return request.recordMeeting({ locusUrl: locusUrl, recording: true, paused: false });
  }

  return _promise2.default.reject(new _permission2.default('Start recording not allowed, due to moderator property.'));
};

MeetingUtil.pauseRecording = function (request, locusUrl, locusInfo) {
  var moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserPause(moderator)) {
    return request.recordMeeting({ locusUrl: locusUrl, recording: true, paused: true });
  }

  return _promise2.default.reject(new _permission2.default('Pause recording not allowed, due to moderator property.'));
};

MeetingUtil.resumeRecording = function (request, locusUrl, locusInfo) {
  var moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserResume(moderator)) {
    return request.recordMeeting({ locusUrl: locusUrl, recording: true, paused: false });
  }

  return _promise2.default.reject(new _permission2.default('Resume recording not allowed, due to moderator property.'));
};

MeetingUtil.stopRecording = function (request, locusUrl, locusInfo) {
  var moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserStop(moderator)) {
    return request.recordMeeting({ locusUrl: locusUrl, recording: false, paused: false });
  }

  return _promise2.default.reject(new _permission2.default('Stop recording not allowed, due to moderator property.'));
};

MeetingUtil.lockMeeting = function (actions, request, locusUrl) {
  if (actions && actions.canLock) {
    return request.lockMeeting({ locusUrl: locusUrl, lock: true });
  }

  return _promise2.default.reject(new _permission2.default('Lock not allowed, due to joined property.'));
};

MeetingUtil.unlockMeeting = function (actions, request, locusUrl) {
  if (actions && actions.canUnlock) {
    return request.lockMeeting({ locusUrl: locusUrl, lock: false });
  }

  return _promise2.default.reject(new _permission2.default('Unlock not allowed, due to joined property.'));
};

MeetingUtil.startInternalStats = function (meeting) {
  if (!meeting.internalStats) {
    var options = {
      useConfig: true,
      senders: [{
        id: 'mainAudio',
        correlate: 'audio',
        history: true,
        onEvent: function onEvent(event) {
          // TODO: we don't need checks like this since it comes from the transceiver
          // refactor event linkage to use callbacks instead of events
          if (event.kind === 'audio' && event.stat === 'bytesSent') {
            _metrics2.default.postEvent({
              event: _config.eventType.SENDING_MEDIA_START,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.AUDIO
              }
            });
          } else if (event.stop && event.stat === 'bytesSent') {
            _metrics2.default.postEvent({
              event: _config.eventType.SENDING_MEDIA_STOP,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.AUDIO
              }
            });
          }
        },
        onData: function onData() {}
      }, {
        id: 'mainVideo',
        correlate: 'video',
        history: true,
        onEvent: function onEvent(event) {
          if (event.kind === 'video' && event.stat === 'bytesSent') {
            _metrics2.default.postEvent({
              event: _config.eventType.SENDING_MEDIA_START,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.VIDEO
              }
            });
          } else if (event.stop && event.stat === 'bytesSent') {
            _metrics2.default.postEvent({
              event: _config.eventType.SENDING_MEDIA_STOP,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.VIDEO
              }
            });
          }
        },
        onData: function onData() {}
      }, {
        id: 'mainShare',
        correlate: 'video',
        onData: function onData() {}
      }],
      receivers: [{
        id: 'mainAudio',
        correlate: 'audio',
        history: true,
        onEvent: function onEvent(event) {
          if (event.kind === 'audio' && event.stat === 'bytesReceived') {
            _metrics2.default.postEvent({
              event: _config.eventType.RECEIVING_MEDIA_START,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.AUDIO
              }
            });
          } else if (event.stop && event.stat === 'bytesReceived') {
            _metrics2.default.postEvent({
              event: _config.eventType.RECEIVING_MEDIA_STOP,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.AUDIO
              }
            });
          }
        },
        onData: function onData() {}
      }, {
        id: 'mainVideo',
        correlate: 'video',
        history: true,
        onEvent: function onEvent(event) {
          if (event.kind === 'video' && event.stat === 'bytesReceived') {
            _metrics2.default.postEvent({
              event: _config.eventType.RECEIVING_MEDIA_START,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.VIDEO
              }
            });
          } else if (event.stop && event.stat === 'bytesReceived') {
            _metrics2.default.postEvent({
              event: _config.eventType.RECEIVING_MEDIA_STOP,
              meeting: meeting,
              data: {
                mediaType: _config.mediaType.VIDEO
              }
            });
          }
        },
        onData: function onData() {}
      }, {
        id: 'mainShare',
        correlate: 'video',
        onData: function onData() {}
      }]
    };

    _util2.default.generateOptions(options, _constants.STATS.CONFIG, meeting);

    options.config = _constants.STATS.CONFIG;

    // pass the attrs and options for the webex instance
    meeting.internalStats = new _index2.default(meeting.attrs, meeting.options, options);
  }

  return meeting.internalStats;
};

MeetingUtil.setPeerConnectionEvents = function (meeting) {
  // In case ICE fail
  var peerConnection = meeting.mediaProperties.peerConnection;


  peerConnection.oniceconnectionstatechange = function () {
    switch (peerConnection.iceConnectionState) {
      case _constants.ICE_STATE.CHECKING:
        _metrics2.default.postEvent({ event: _config.eventType.ICE_START, meeting: meeting });
        break;
      case _constants.ICE_STATE.COMPLETED:
        _metrics2.default.postEvent({ event: _config.eventType.ICE_END, meeting: meeting });
        break;
      case _constants.ICE_STATE.CONNECTED:
        break;
      case _constants.ICE_STATE.CLOSED:
        break;
      case _constants.ICE_STATE.DISCONNECTED:

        break;
      case _constants.ICE_STATE.FAILED:
        // notify of ice failure
        _metrics2.default.postEvent({
          event: _config.eventType.ICE_END,
          meeting: meeting,
          data: {
            canProceed: false,
            errors: [_metrics2.default.generateErrorPayload(2004, false, _config.error.name.MEDIA_ENGINE)]
          }
        });
        break;
      default:
        break;
    }
  };
};

exports.default = MeetingUtil;
//# sourceMappingURL=util.js.map
