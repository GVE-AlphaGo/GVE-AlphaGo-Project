'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _javascriptStateMachine = require('javascript-state-machine');

var _javascriptStateMachine2 = _interopRequireDefault(_javascriptStateMachine);

var _history = require('javascript-state-machine/lib/history');

var _history2 = _interopRequireDefault(_history);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _triggerProxy = require('../common/events/trigger-proxy');

var _triggerProxy2 = _interopRequireDefault(_triggerProxy);

var _constants = require('../constants');

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: ensure that meeting can be destroyed when in an error state
var MeetingStateMachine = {
  /**
   * Initializes the StateMachine for the meeting
   * @param {Meeting} meetingRef A reference to a meeting instance
   * @returns {StateMachine}
   */
  create: function create(meetingRef) {
    if (!meetingRef) {
      throw new _parameter2.default('You must initialize the meeting state machine with a meeting reference.');
    }

    return new _javascriptStateMachine2.default({
      init: _constants.MEETING_STATE_MACHINE.STATES.IDLE,
      transitions: [
      // when ringing a meeting, it must be first IDLE, because all other states are invalid, it transitions to the RINGING state
      {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.RING,
        from: [_constants.MEETING_STATE_MACHINE.STATES.IDLE, _constants.MEETING_STATE_MACHINE.STATES.SAFE, _constants.MEETING_STATE_MACHINE.STATES.JOINED],
        to: _constants.MEETING_STATE_MACHINE.STATES.RINGING
      },
      // when joining a meeting, it must be from the RINGING or IDLE state, transitions to JOINED state, 1:1 will go to RINGING,
      // others will go straight to JOINED with this transition
      {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.JOIN,
        from: [_constants.MEETING_STATE_MACHINE.STATES.JOINED, _constants.MEETING_STATE_MACHINE.STATES.IDLE, _constants.MEETING_STATE_MACHINE.STATES.RINGING, _constants.MEETING_STATE_MACHINE.STATES.SAFE],
        to: _constants.MEETING_STATE_MACHINE.STATES.JOINED
      },
      // signify that ringing has stopped and somebody else answered, move state to DECLINED, ANSWERED
      {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.REMOTE,
        from: [_constants.MEETING_STATE_MACHINE.STATES.JOINED, _constants.MEETING_STATE_MACHINE.STATES.SAFE],
        /**
        * @param {Object} remote
        * @param {Boolean} remote.remoteAnswered
        * @param {Boolean} remote.remoteDeclined
        * @returns {String}
        */
        to: function to(remote) {
          // other user answered the call
          if (remote.remoteAnswered) {
            return _constants.MEETING_STATE_MACHINE.STATES.ANSWERED;
          }
          // other user declined the call
          if (remote.remoteDeclined) {
            return _constants.MEETING_STATE_MACHINE.STATES.DECLINED;
          }

          // default
          return _constants.MEETING_STATE_MACHINE.STATES.ERROR;
        }
      },
      // when leaving a meeting it must be from either the RINGING, JOINED, or ERROR states, and transitions it to the ENDED state
      {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.LEAVE,
        from: [_constants.MEETING_STATE_MACHINE.STATES.RINGING, _constants.MEETING_STATE_MACHINE.STATES.JOINED, _constants.MEETING_STATE_MACHINE.STATES.ANSWERED, _constants.MEETING_STATE_MACHINE.STATES.DECLINED, _constants.MEETING_STATE_MACHINE.STATES.ERROR, _constants.MEETING_STATE_MACHINE.STATES.SAFE],
        to: _constants.MEETING_STATE_MACHINE.STATES.ENDED
      },
      // when declining an incoming meeting it must be from the ringing state, and it moves to DECLINED state
      {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.DECLINE,
        from: [_constants.MEETING_STATE_MACHINE.STATES.RINGING, _constants.MEETING_STATE_MACHINE.STATES.SAFE],
        to: _constants.MEETING_STATE_MACHINE.STATES.ENDED
      },
      // transition from ANY state to ERROR state
      {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.FAIL,
        from: '*',
        to: _constants.MEETING_STATE_MACHINE.STATES.ERROR
      }, {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.SAFE,
        from: _constants.MEETING_STATE_MACHINE.STATES.ERROR,
        to: _constants.MEETING_STATE_MACHINE.STATES.SAFE
      },
      // fail safe, transition from ANY state to IDLE state
      {
        name: _constants.MEETING_STATE_MACHINE.TRANSITIONS.RESET,
        from: '*',
        to: _constants.MEETING_STATE_MACHINE.STATES.IDLE
      }],
      data: {
        /**
         * The meeting instance to execute all state changes on
         */
        meeting: meetingRef
      },
      methods: {
        /**
         * Ring stop transition, to end the ring event for the meeting, and transition the state to ANSWERED OR DECLINED, only for outgoing meetings
         * @param {Object} transition -- FiniteStateMachine automatically passed, not used
         * @param {Object} stop -- {remoteAnswered: {Boolean}, remoteDeclined: {Boolean}}
         * @returns {Boolean}
         */
        onRemote: function onRemote(transition, stop) {
          if (this.meeting) {
            _triggerProxy2.default.trigger(this.meeting, {
              file: 'meeting/state',
              function: 'onRemote'
            }, _constants.EVENT_TRIGGERS.MEETING_RINGING_STOP, {
              id: this.meeting.id,
              type: stop
            });
          }
        },

        /**
         * Ring transition, to cause the ring event for the meeting, and transition the state to RINGING, for both incoming, and outgoing meetings
         * @param {Object} transition -- FiniteStateMachine automatically passed, not used
         * @param {String} type -- incoming call === INCOMING / or other meetings have a ring type of JOIN
         * @returns {Boolean}
         */
        onRing: function onRing(transition, type) {
          if (this.meeting) {
            _triggerProxy2.default.trigger(this.meeting, {
              file: 'meeting/state',
              function: 'onRing'
            }, _constants.EVENT_TRIGGERS.MEETING_RINGING, {
              type: type,
              id: this.meeting.id
            });
          }
        },

        /**
         * handle the error transition stage
         * @param {Object} transition
         * @param {Error} error
         * @returns {Boolean}
         */
        onBeforeError: function onBeforeError(transition, error) {
          _loggerProxy2.default.logger.error('meeting/state->onError#meeting.id: ' + this.meeting.id + ' | Transition \'' + transition.transition + '\' : ' + transition.from + ' -> ' + transition.to + ' failed after last state transition, with error ' + error + '. Moving to a non-informative state. Last states: ' + this.history);
        },
        onAfterError: function onAfterError() {
          this.safe();
        },

        /**
         * After ANY transition occurs, we want to know what state the meeting moved to for debugging
         * @param {Object} transition
         * @returns {Boolean}
         */
        onAfterTransition: function onAfterTransition(transition) {
          _loggerProxy2.default.logger.log('meeting/state->onAfterTransition#meeting.id: ' + this.meeting.id + ' | Transition \'' + transition.transition + '\' : ' + transition.from + ' -> ' + transition.to + ' executed. Last states: ' + this.history);
        }
      },
      // track the last 25 states entered
      plugins: [new _history2.default({ max: 25 })]
    });
  }
};

exports.default = MeetingStateMachine;
//# sourceMappingURL=state.js.map
