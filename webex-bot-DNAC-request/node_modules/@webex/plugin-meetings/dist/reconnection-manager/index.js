'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _constants = require('../constants');

var _reconnection = require('../common/errors/reconnection');

var _reconnection2 = _interopRequireDefault(_reconnection);

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @export
 * @class ReconnectionManager
*/
var ReconnectionManager = function () {
  /**
   * @param {Meeting} meeting
   */
  function ReconnectionManager(meeting) {
    (0, _classCallCheck3.default)(this, ReconnectionManager);

    /**
     * @instance
     * @type {String}
     * @private
     * @memberof ReconnectionManager
    */
    this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
    /**
     * @instance
     * @type {Number}
     * @private
     * @memberof ReconnectionManager
    */
    this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
    */
    this.webex = meeting.webex;
    this.configure(meeting);
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */


  (0, _createClass3.default)(ReconnectionManager, [{
    key: 'configure',
    value: function configure(meeting) {
      this.backOff = meeting.config.reconnection.retry.backOff.start;
    }

    /**
     * @returns {undefined}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
      this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    }

    /**
     * @param {Meeting} meeting
     * @returns {Boolean}
     * @returns {ReconnectionError}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'validate',
    value: function validate(meeting) {
      if (meeting.config.reconnection.enabled) {
        if (meeting.locusInfo && meeting.locusInfo.fullState && meeting.locusInfo.fullState.state === _constants._ACTIVE_ && meeting.locusInfo.fullState.active) {
          if (meeting.webex.internal.mercury.connected) {
            if (this.status !== _constants.RECONNECTION.STATE.DEFAULT_STATUS || this.status !== _constants.RECONNECTION.STATE.COMPLETE) {
              return true;
            }

            return new _reconnection2.default('Multiple reconnections cannot occur concurrently');
          }

          return new _reconnection2.default('mercury is not connected, cannot reconnect');
        }

        return new _reconnection2.default('locus server for this call is not active, cannot reconnect');
      }

      return new _reconnection2.default('Reconnection is not enabled.');
    }

    /**
     * Initiates a media reconnect for the active meeting
     * @param {Meeting} meeting
     * @returns {Promise}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: 'reconnect',
    value: function reconnect(meeting) {
      var validatedReconnect = this.validate(meeting);

      return validatedReconnect === true ? this.execute(meeting) : _promise2.default.reject(validatedReconnect);
    }

    /**
     * @param {Meeting} meeting
     * @returns {Promise}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'execute',
    value: function execute(meeting) {
      var _this = this;

      this.status = _constants.RECONNECTION.STATE.IN_PROGRESS;

      return this.media(meeting).then(function (media) {
        _loggerProxy2.default.logger.log('ReconnectionManager->execute#Media reestablished at: ' + new Date());
        _this.status = _constants.RECONNECTION.STATE.COMPLETE;

        return _promise2.default.resolve(media);
      }).catch(function (err) {
        // eslint-disable-line
        _loggerProxy2.default.logger.error('ReconnectionManager->execute#Media reestablishment failed at: ' + new Date());
        if (_this.tryCount > meeting.config.reconnection.retry.times) {
          _this.status = _constants.RECONNECTION.STATE.FAILURE;

          return _promise2.default.reject(new _reconnection2.default(err));
        }
        // exponential backoff and retry logic
        setTimeout(function () {
          return _this.reconnect(meeting);
        }, _this.backOff *= meeting.config.reconnection.retry.backOff.rate);
      });
    }

    /**
     * @param {Meeting} meeting
     * @param {boolean} [recreate] default false to re attach media if true
     * @returns {Promise}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'reconnectMedia',
    value: function reconnectMedia(meeting) {
      var recreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var promise = null;

      if (recreate) {
        promise = _media2.default.attachMedia(meeting.mediaProperties).then(function (peerConnection) {
          return meeting.setRemoteStream(peerConnection);
        });
      } else {
        promise = _media2.default.reconnectMedia(meeting.mediaProperties.peerConnection, meeting.meetingId);
      }

      return _promise2.default.resolve(promise).then(function () {
        return meeting.roap.sendRoapMediaRequest({
          sdp: meeting.mediaProperties.peerConnection.sdp,
          roapSeq: meeting.roapSeq,
          meeting: meeting // or can pass meeting ID
        });
      });
    }

    /**
     * @param {Meeting} meeting
     * @returns {Promise} see #Meeting.addMedia
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'media',
    value: function media(meeting) {
      this.tryCount += 1;
      _loggerProxy2.default.logger.log('Reconnection->media#Begin reestablishment of media at ' + new Date());

      // TODO: chekc peerconnection status
      // create an offer
      return this.reconnectMedia(meeting).then(function (media) {
        return _promise2.default.resolve(media);
      }).catch(function (err) {
        _loggerProxy2.default.logger.warn('Reconnection->media#Media could not reuse peer connection, failed with ' + err);
        // TODO: test getting to this scenario
        ReconnectionManager.cleanup(meeting);
        meeting.mediaProperties.reInitiatePeerconnection();

        return meeting.reconnectMedia(true).catch(function (error) {
          _loggerProxy2.default.logger.error('ReconnectionManager->media#Error reconnecting , error: ' + error);
        });
      });
    }

    /**
     * @param {Meeting} meeting
     * @returns {undefined}
     * @private
     * @memberof ReconnectionManager
     */

  }], [{
    key: 'cleanup',
    value: function cleanup(meeting) {
      // close pcs, unset to null and reuse the streams with new pcs
      _peerConnectionManager2.default.close(meeting.mediaProperties.peerConnection);
      meeting.mediaProperties.unsetPeerConnection();
    }
  }]);
  return ReconnectionManager;
}(); /*!
      * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
      */

exports.default = ReconnectionManager;
//# sourceMappingURL=index.js.map
