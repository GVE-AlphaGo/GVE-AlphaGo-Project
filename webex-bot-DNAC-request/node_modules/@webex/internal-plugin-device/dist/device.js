'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _dec, _dec2, _dec3, _dec4, _dec5, _desc, _value, _obj; // Internal Dependencies


// Local Dependencies


var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _commonTimers = require('@webex/common-timers');

var _constants = require('./constants');

var _featuresModel = require('./features/features-model');

var _featuresModel2 = _interopRequireDefault(_featuresModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Determine if the plugin should be initialized based on cached storage.
 *
 * @returns {boolean} - If the device is ephemeral.
 */
function decider() {
  return !this.config.ephemeral;
}

var Device = _webexCore.WebexPlugin.extend((_dec = (0, _webexCore.waitForValue)('@'), _dec2 = (0, _webexCore.waitForValue)('@'), _dec3 = (0, _webexCore.waitForValue)('@'), _dec4 = (0, _common.deprecated)('device#markUrlFailedAndGetNew(): Use services#markFailedUrl()'), _dec5 = (0, _webexCore.persist)('@', decider), (_obj = {

  // Ampersand property members.

  namespace: 'Device',

  // Allow for extra properties to prevent the plugin from failing due to
  // **WDM** service DTO changes.
  extraProperties: 'allow',

  idAttribute: 'url',

  children: {
    /**
     * The class object that contains all of the feature collections.
     *
     * @type {FeaturesModel}
     */
    features: _featuresModel2.default
  },

  /**
   * A collection of device properties mostly assigned by the retrieved DTO from
   * the **WDM** service that are mapped against the ampersand properties.
   *
   * @type {Object}
   */
  props: {
    /**
     * This property determines whether or not giphy support is enabled.
     *
     * @type {'ALLOW' | 'BLOCK'}
     */
    clientMessagingGiphy: 'string',

    /**
     * This property should store the company name.
     *
     * @type {string}
     */
    customerCompanyName: 'string',

    /**
     * This property should store the logo url.
     *
     * @type {string}
     */
    customerLogoUrl: 'string',

    /**
     * This property doesn't have any real values, but is sent during device
     * refresh to prevent the **wdm** service from falling back to an iOS device
     * type.
     *
     * @type {string}
     */
    deviceType: 'string',

    /**
     * This property should store the help url.
     *
     * @type {string}
     */
    helpUrl: 'string',

    /**
     * This property should store the intranet inactivity timer duration.
     *
     * @type {number}
     */
    intranetInactivityDuration: 'number',

    /**
     * This property stores the url required to validate if the device is able
     * to actively reach the intranet network.
     *
     * @type {string}
     */
    intranetInactivityCheckUrl: 'string',

    /**
     * This property stores the inactivity timer duration, and could possibly
     * deprecate the `intranetInactivityDuration` property.
     *
     * @type {number}
     */
    inNetworkInactivityDuration: 'number',

    /**
     * This property stores the ECM (external content management) enabled value
     * for the whole organization.
     *
     * @type {boolean}
     */
    ecmEnabledForAllUsers: ['boolean', false, false],

    /**
     * This property stores an array of ECM (external content management)
     * providers that are currently available.
     *
     * @returns {Array<string>}
     */
    ecmSupportedStorageProviders: ['array', false, function () {
      return [];
    }],

    /**
     * This property stores the modification time value retrieved from the
     * **WDM** endpoint formatted as ISO 8601.
     *
     * @type {string}
     */
    modificationTime: 'string',

    /**
     * This property stores the navigation bar color.
     *
     * @type {string}
     */
    navigationBarColor: 'string',

    /**
     * This property stores the partner company's name when available.
     *
     * @type {string}
     */
    partnerCompanyName: 'string',

    /**
     * This property stores the partner company's logo when available.
     *
     * @type {string}
     */
    partnerLogoUrl: 'string',

    /**
     * This property stores the availability of people data from the **WDM**
     * service.
     *
     * @type {boolean}
     */
    peopleInsightsEnabled: 'boolean',

    /**
     * This property stores the reporting site's description when available.
     *
     * @type {string}
     */
    reportingSiteDesc: 'string',

    /**
     * This property stores the reporting site's access url when available.
     *
     * @type {string}
     */
    reportingSiteUrl: 'string',

    /**
     * This property stores the encryption key url when available.
     *
     * @type {string}
     */
    searchEncryptionKeyUrl: 'string',

    /**
     * This property stores the availability of support-provided text from the
     * **WDM** service.
     *
     * @type {boolean}
     */
    showSupportText: 'boolean',

    /**
     * This property stores the support provider's company name when available.
     *
     * @type {string}
     */
    supportProviderCompanyName: 'string',

    /**
     * This property stores the support provider's logo url when available.
     *
     * @type {string}
     */
    supportProviderLogoUrl: 'string',

    /**
     * This property stores the device's url retrieved from a registration
     * request. This property gets set via the initial registration process by a
     * `this.set()` method.
     *
     * @type {string}
     */
    url: 'string',

    /**
     * This property stores the device's userId uuid value, which can also be
     * derived from the device's registerd user's userId retrieved from
     * the **Hydra** service.
     *
     * @type {string}
     */
    userId: 'string',

    /**
     * This property stores whether or not file sharing is enabled
     *
     * @type {'BLOCK_BOTH' | 'BLOCK_UPLOAD'}
     */
    webFileShareControl: 'string',

    /**
     * This property stores the current web socket url used by the registered
     * device.
     *
     * @type {string}
     */
    webSocketUrl: 'string',

    /**
     * This property stores the value indicating whether or not white board file
     * sharing is enabled for the current device.
     *
     * @type {'ALLOW' | 'BLOCK'}
     */
    whiteboardFileShareControl: 'string'
  },

  /**
   * A list of derived properties that populate based when their parent data
   * available via the device's properties.
   *
   * @type {Object}
   */
  derived: {
    /**
     * This property determines if the current device is registered.
     *
     * @type {boolean}
     */
    registered: {
      deps: ['url'],

      /**
       * Checks if the device is registered by validating that the url exists.
       * Amperstand does not allow this to method to be written as an arrow
       * function.
       *
       * @returns {boolean}
       */
      fn: function fn() {
        return !!this.url;
      }
    }
  },

  /**
   * Stores timer data as well as other state details.
   *
   * @type {Object}
   */
  session: {
    /**
     * This property stores the logout timer object
     *
     * @type {any}
     */
    logoutTimer: 'any',

    /**
     * This property stores the date for the last activity the user made
     * with the current device.
     *
     * @type {number}
     */
    lastUserActivityDate: 'number',

    /**
     * This property stores whether or not the reachability check has been
     * performed to prevent the reachability check from performing its
     * operation more than once after a successful check.
     *
     * @returns {boolean}
     */
    isReachabilityChecked: ['boolean', false, false],

    /**
     * This property stores whether or not the current device is in a meeting
     * to prevent an unneeded timeout of a meeting due to inactivity.
     *
     * @type {boolean}
     */
    isInMeeting: 'boolean',

    /**
     * This property identifies if the device is currently in network to prevent
     * the `resetLogoutTimer()` method from being called repeatedly once its
     * known client is connected to the organization's internal network.
     *
     * @type {boolean}
     */
    isInNetwork: 'boolean'
  },

  // Event method members.

  /**
   * Trigger meeting started event for webex instance. Used by web-client team.
   *
   * @returns {void}
   */
  meetingStarted: function meetingStarted() {
    this.webex.trigger('meeting started');
  },


  /**
   * Trigger meeting ended event for webex instance. Used by web-client team.
   *
   * @returns {void}
   */
  meetingEnded: function meetingEnded() {
    this.webex.trigger('meeting ended');
  },
  refresh: function refresh() {
    var _this = this;

    this.logger.info('device: refreshing');

    // Validate that the device can be registered.
    return this.canRegister().then(function () {
      // Validate if the device is not registered and register instead.
      if (!_this.registered) {
        _this.logger.info('device: device not registered, registering');

        return _this.register();
      }

      // Merge body configurations, overriding defaults.
      var body = (0, _extends3.default)({}, _this.serialize(), _this.config.body ? _this.config.body : {});

      // Remove unneeded properties from the body object.
      delete body.features;
      delete body.mediaCluster;

      // Append a ttl value if the device is marked as ephemeral.
      if (_this.config.ephemeral) {
        body.ttl = _this.config.ephemeralDeviceTTL;
      }

      // Merge header configurations, overriding defaults.
      var headers = (0, _extends3.default)({}, _this.config.defaults.headers ? _this.config.defaults.headers : {}, _this.config.headers ? _this.config.headers : {});

      return _this.request({
        method: 'PUT',
        uri: _this.url,
        body: body,
        headers: headers
      }).then(function (response) {
        return _this.processRegistrationSuccess(response);
      }).catch(function (reason) {
        // Handle a 404 error, which indicates that the device is no longer
        // valid and needs to be registered as a new device.
        if (reason.statusCode === 404) {
          _this.logger.info('device: refresh failed, device is not valid');
          _this.logger.info('device: attempting to register a new device');

          _this.clear();

          return _this.register();
        }

        return _promise2.default.reject(reason);
      });
    });
  },
  register: function register() {
    var _this2 = this;

    this.logger.info('device: registering');

    // Validate that the device can be registered.
    return this.canRegister().then(function () {
      // Validate if the device is already registered and refresh instead.
      if (_this2.registered) {
        _this2.logger.info('device: device already registered, refreshing');

        return _this2.refresh();
      }

      // Merge body configurations, overriding defaults.
      var body = (0, _extends3.default)({}, _this2.config.defaults.body ? _this2.config.defaults.body : {}, _this2.config.body ? _this2.config.body : {});

      // Merge header configurations, overriding defaults.
      var headers = (0, _extends3.default)({}, _this2.config.defaults.headers ? _this2.config.defaults.headers : {}, _this2.config.headers ? _this2.config.headers : {});

      // This will be replaced by a `create()` method.
      return _this2.request({
        method: 'POST',
        service: 'wdm',
        resource: 'devices',
        body: body,
        headers: headers
      }).then(function (response) {
        return _this2.processRegistrationSuccess(response);
      });
    });
  },
  unregister: function unregister() {
    var _this3 = this;

    this.logger.info('device: unregistering');

    if (!this.registered) {
      this.logger.warn('device: not registered');

      return _promise2.default.resolve();
    }

    return this.request({
      uri: this.url,
      method: 'DELETE'
    }).then(function () {
      return _this3.clear();
    });
  },

  /* eslint-enable require-jsdoc */

  // Helper method members

  /**
   * Determine if registration methods can be performed. This method utilizes
   * the `services` plugin to confirm if the appropriate service urls are
   * available for device registration.
   *
   * @returns {Promise<void, Error>}
   */
  canRegister: function canRegister() {
    this.logger.info('device: validating if registration can occur');

    // Destructure the services plugin for ease of reference.
    var services = this.webex.internal.services;

    // Wait for the postauth catalog to populate.

    return services.waitForCatalog('postauth', this.config.canRegisterWaitDuration).then(function () {
      return (
        // Validate that the service exists after waiting for the catalog.
        services.get('wdm') ? _promise2.default.resolve() : _promise2.default.reject(new Error(['device: cannot register,', '\'wdm\' service is not available from the postauth catalog'].join(' ')))
      );
    });
  },


  /**
   * Check if the device can currently reach the inactivity check url.
   *
   * @returns {Promise<void, Error>}
   */
  checkNetworkReachability: function checkNetworkReachability() {
    var _this4 = this;

    this.logger.info('device: checking network reachability');

    // Validate if the device has been checked and reset the logout timer.
    if (this.isReachabilityChecked) {
      return _promise2.default.resolve(this.resetLogoutTimer());
    }

    // Validate if the device has a intranet checking url.
    if (!this.intranetInactivityCheckUrl) {
      this.isInNetwork = false;

      return _promise2.default.resolve(this.resetLogoutTimer());
    }

    this.isReachabilityChecked = true;

    // Clear unnecessary headers for reachability request.
    var headers = {
      'cisco-no-http-redirect': null,
      'spark-user-agent': null,
      trackingid: null
    };

    // Send the network reachability request.
    return this.request({
      headers: headers,
      method: 'GET',
      uri: this.intranetInactivityCheckUrl
    }).then(function () {
      _this4.isInNetwork = true;

      return _promise2.default.resolve(_this4.resetLogoutTimer());
    }).catch(function () {
      _this4.logger.info('device: did not reach ping endpoint');
      _this4.logger.info('device: triggering off-network timer');

      _this4.isInNetwork = false;

      return _promise2.default.resolve(_this4.resetLogoutTimer());
    });
  },


  /**
   * Clears the registration ttl value if available.
   *
   * @param {Object} options - Values to be cleared.
   * @returns {void}
   */
  clear: function clear() {
    this.logger.info('device: clearing registered device');

    // Prototype the extended class in order to preserve the parent member.

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.clear, this, args);
  },


  /**
   * Get the current websocket url with the appropriate priority host.
   *
   * @param {boolean} [wait=false] - Willing to wait on a valid url.
   * @returns {Promise<string, Error>} - The priority-mapped web socket url.
   */
  getWebSocketUrl: function getWebSocketUrl() {
    var _this5 = this;

    var wait = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.logger.info('device: getting the current websocket url');

    // Destructure the services plugin for ease of reference.
    var services = this.webex.internal.services;

    // Validate if the method should wait for registration.

    if (wait) {
      return this.waitForRegistration().then(function () {
        return services.convertUrlToPriorityHostUrl(_this5.webSocketUrl);
      }).catch(function (error) {
        _this5.logger.warn(error.message);

        return _promise2.default.reject(new Error('device: failed to get the current websocket url'));
      });
    }

    // Validate if the device is registered.
    if (!this.registered) {
      return _promise2.default.reject(new Error('device: cannot get websocket url, device is not registered'));
    }

    // Attempt to collect the priority-host-mapped web socket URL.
    var wsUrl = services.convertUrlToPriorityHostUrl(this.webSocketUrl);

    // Validate that the url was collected.
    if (wsUrl) {
      return _promise2.default.resolve(wsUrl);
    }

    return _promise2.default.reject(new Error('device: failed to get the current websocket url'));
  },


  /**
   * Process a successful device registration.
   *
   * @param {Object} response - response object from registration success.
   * @returns {void}
   */
  processRegistrationSuccess: function processRegistrationSuccess(response) {
    var _this6 = this;

    this.logger.info('device: received registration payload');

    // Clone the response body for service cleaning.
    var body = (0, _extends3.default)({}, response.body);

    // Clean service data.
    delete body.services;
    delete body.serviceHostMap;

    // Assign the recieved DTO from **WDM** to this device.
    this.set(body);

    // Validate if device is ephemeral and setup refresh timer.
    if (this.config.ephemeral) {
      this.logger.info('device: enqueuing device refresh');

      var delay = (this.config.ephemeralDeviceTTL / 2 + 60) * 1000;

      this.refreshTimer = (0, _commonTimers.safeSetTimeout)(function () {
        return _this6.refresh();
      }, delay);
    }

    // Emit the registration:success event.
    this.trigger(_constants.DEVICE_EVENT_REGISTRATION_SUCCESS, this);
  },


  /**
   * Reset the current local logout timer for the registered device if
   * registered.
   *
   * @returns {void}
   */
  resetLogoutTimer: function resetLogoutTimer() {
    this.logger.info('device: resetting logout timer');

    // Clear current logout timer.
    clearTimeout(this.logoutTimer);

    // Remove last activity date event listener.
    this.off('change:lastUserActivityDate');

    // Remove the logout timer.
    this.unset('logoutTimer');

    // Validate if the device is currently in a meeting and is configured to
    // required inactivity enforcement.
    if (!this.isInMeeting && this.config.enableInactivityEnforcement && this.isReachabilityChecked) {
      if (this.isInNetwork) {
        this.setLogoutTimer(this.inNetworkInactivityDuration);
      } else {
        this.setLogoutTimer(this.intranetInactivityDuration);
      }
    }
  },


  /**
   * Set the value of the logout timer for the current registered device.
   *
   * @param {number} duration - Value in seconds of the new logout timer.
   * @returns {void}
   */
  setLogoutTimer: function setLogoutTimer(duration) {
    var _this7 = this;

    this.logger.info('device: setting logout timer');

    if (!duration || duration <= 0) {
      return;
    }

    // Setup user activity date event listener.
    this.on('change:lastUserActivityDate', function () {
      _this7.resetLogoutTimer();
    });

    // Initialize a new timer.
    this.logoutTimer = (0, _commonTimers.safeSetTimeout)(function () {
      _this7.webex.logout();
    }, duration * 1000);
  },


  /**
   * Wait for the device to be registered.
   *
   * @param {number} [timeout=10] - The maximum duration to wait, in seconds.
   * @returns {Promise<void, Error>}
   */
  waitForRegistration: function waitForRegistration() {
    var _this8 = this;

    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

    this.logger.info('device: waiting for registration');

    return new _promise2.default(function (resolve, reject) {
      if (_this8.registered) {
        resolve();
      }

      var timeoutTimer = (0, _commonTimers.safeSetTimeout)(function () {
        return reject(new Error('device: timeout occured while waiting for registration'));
      }, timeout * 1000);

      _this8.once(_constants.DEVICE_EVENT_REGISTRATION_SUCCESS, function () {
        clearTimeout(timeoutTimer);
        resolve();
      });
    });
  },
  markUrlFailedAndGetNew: function markUrlFailedAndGetNew(url) {
    return _promise2.default.resolve(this.webex.internal.services.markFailedUrl(url));
  },
  initialize: function initialize() {
    var _this9 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    // Prototype the extended class in order to preserve the parent member.
    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, args);

    // Initialize feature events and listeners.
    _constants.FEATURE_COLLECTION_NAMES.forEach(function (collectionName) {
      _this9.features.on('change:' + collectionName, function (model, value, options) {
        _this9.trigger('change', _this9, options);
        _this9.trigger('change:features', _this9, _this9.features, options);
      });
    });

    // Initialize network reachability checking event for url change.
    this.on('change:intranetInactivityCheckUrl', function () {
      _this9.checkNetworkReachability();
    });

    // Initialize network reachability checking event for duration change.
    this.on('change:intranetInactivityDuration', function () {
      _this9.checkNetworkReachability();
    });

    // Initialize network reachability checking event for duration change.
    this.on('change:inNetworkInactivityDuration', function () {
      _this9.checkNetworkReachability();
    });

    // Initialize listener for activity checking.
    this.listenTo(this.webex, 'user-activity', function () {
      _this9.lastUserActivityDate = Date.now();
    });

    // Initialize listener for meeting started event.
    this.listenTo(this.webex, 'meeting started', function () {
      _this9.isInMeeting = true;
      _this9.resetLogoutTimer();
    });

    // Initialize listener for meeting ended event.
    this.listenTo(this.webex, 'meeting ended', function () {
      _this9.isInMeeting = false;
      _this9.resetLogoutTimer();
    });
  }
  /* eslint-enable require-jsdoc */
  ,
  version: '1.80.147'
}, (_applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight, _dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'register', [_common.oneFlight, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'register'), _obj), _applyDecoratedDescriptor(_obj, 'unregister', [_common.oneFlight, _dec3], (0, _getOwnPropertyDescriptor2.default)(_obj, 'unregister'), _obj), _applyDecoratedDescriptor(_obj, 'markUrlFailedAndGetNew', [_dec4], (0, _getOwnPropertyDescriptor2.default)(_obj, 'markUrlFailedAndGetNew'), _obj), _applyDecoratedDescriptor(_obj, 'initialize', [_dec5], (0, _getOwnPropertyDescriptor2.default)(_obj, 'initialize'), _obj)), _obj)));

exports.default = Device;
//# sourceMappingURL=device.js.map
