'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _constants = require('./constants');

var _serviceHost = require('./service-host');

var _serviceHost2 = _interopRequireDefault(_serviceHost);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The parameter transfer object for {@link ServiceRegistry#mapRemoteCatalog}.
 * This object is shaped to match the object returned from the **U2C** service.
 *
 * @typedef {Record<string, string>} RSL
 * @typedef {Record<string, Array<Record<string, number | string>>>} RHC
 *
 * @typedef {Object} MapRemoteCatalogPTO
 * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.
 * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.
 * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.
 */

/**
 * Service manipulation filter object for retrieving services within the
 * {@link ServiceRegistry} class.
 *
 * @typedef {Object} HostFilter
 * @property {boolean} [HostFilter.active] - Active state to filter.
 * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.
 * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.
 * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.
 * @property {boolean} [HostFilter.priority] - Filter for the highest priority.
 * @property {Array<string> | string} [HostFilter.service] - Services to filter.
 * @property {Array<string> | string} [HostFilter.url] - URL to filter.
 */

/**
 * @class
 * @classdesc - Manages a collection of {@link ServiceHost} class objects.
 */
var ServiceRegistry = function () {
  /**
   * Generate a new {@link ServiceHost}.
   *
   * @public
   * @constructor
   * @memberof ServiceHost
   */
  function ServiceRegistry() {
    (0, _classCallCheck3.default)(this, ServiceRegistry);

    /**
     * The collection of managed {@link ServiceHost}s.
     *
     * @instance
     * @type {Array<ServiceHost>}
     * @private
     * @memberof ServiceRegistry
     */
    this.hosts = [];
  }

  /**
   * An active, local, and priority mapped record of the current
   * {@link ServiceCatalog#hosts}.
   *
   * @public
   * @memberof ServiceCatalog
   * @type {Record<string, string>}
   */


  (0, _createClass3.default)(ServiceRegistry, [{
    key: 'clear',


    /**
     * Removes a collection of {@link ServiceHost} class objects from the
     * {@link ServiceRegistry#hosts} array based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter for hosts to remove.
     * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.
     */
    value: function clear(filter) {
      // Collect a list of hosts to remove based on the provided filter.
      var removing = this.find(filter);

      // Remove the hosts from the array.
      this.hosts = this.hosts.filter(function (host) {
        return !removing.includes(host);
      });

      // Return the removed hosts.
      return removing;
    }

    /**
     * Mark a collection of {@link ServiceHost} class objects from the
     * {@link ServiceRegistry#hosts} array as failed based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter for hosts to mark failed.
     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked failed.
     */

  }, {
    key: 'failed',
    value: function failed(filter) {
      // Collect a list of hosts to mark as failed based on the provided filter.
      var failing = this.find(filter);

      // Mark the hosts from the array as failed.
      failing.forEach(function (host) {
        host.setStatus({ failed: true });
      });

      // Return the marked hosts.
      return failing;
    }

    /**
     * Filter the {@link ServiceRegistry#hosts} array against their active states.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {boolean} [active] - Filter for the host state.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: 'filterActive',
    value: function filterActive(active) {
      // Filter the host array if the active requirement is true.
      return typeof active === 'boolean' ? this.hosts.filter(function (host) {
        return host.active === active;
      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));
    }

    /**
     * Filter the {@link ServiceRegistry#hosts} array against their assigned
     * catalog values.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [catalog] - Catalogs to filter.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: 'filterCatalog',
    value: function filterCatalog() {
      var catalog = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // Generate a catalog names array based on the provided catalog param.
      var catalogs = (Array.isArray(catalog) ? catalog : [catalog]).map(function (catalogId) {
        return ServiceRegistry.mapCatalogName({
          id: catalogId,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING
        }) || catalogId;
      });

      // Filter the host array against the catalog names array.
      return catalogs.length > 0 ? this.hosts.filter(function (host) {
        return catalogs.includes(host.catalog);
      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));
    }

    /**
     * Filter the {@link ServiceRegistry#hosts} array against their assigned
     * cluster values.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [cluster] - Clusters to filter for.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: 'filterCluster',
    value: function filterCluster() {
      var cluster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // Generate an array of clusters regardless of parameter type.
      var clusters = Array.isArray(cluster) ? cluster : [cluster];

      // Filter the host array against the provided clusters.
      return clusters.length > 0 ? this.hosts.filter(function (host) {
        return clusters.includes(host.id);
      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));
    }

    /**
     * Filter the {@link ServiceRegistry#hosts} array against their location in
     * reference to the authenticated user.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {boolean} [local] - Filter for the host location.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: 'filterLocal',
    value: function filterLocal(local) {
      return typeof local === 'boolean' ? this.hosts.filter(function (host) {
        return host.local === local;
      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));
    }

    /**
     * Filter the {@link ServiceRegistry#hosts} array for the highest priority
     * hosts for each specific service.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {boolean} [priority] - Filter for the highest priority
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: 'filterPriority',
    value: function filterPriority(priority) {
      return priority ? this.hosts.reduce(function (filteredHosts, currentHost) {
        // Validate that the current host is not active.
        if (!currentHost.active) {
          return filteredHosts;
        }

        // Determine if the filtered hosts array contains a host from the same
        // host group.
        var foundHost = filteredHosts.find(function (host) {
          return host.hostGroup === currentHost.hostGroup;
        });

        // Validate if a host was found.
        if (!foundHost) {
          filteredHosts.push(currentHost);

          return filteredHosts;
        }

        // Map the found host's catalog to its priority value.
        var foundHostCatalogPriority = ServiceRegistry.mapCatalogName({
          id: foundHost.catalog,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER
        });

        // Map the current host's catalog to its priority value.
        var currentHostCatalogPriority = ServiceRegistry.mapCatalogName({
          id: currentHost.catalog,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER
        });

        // Validate if the found host has a lower priority than the current
        // host.
        if (foundHostCatalogPriority < currentHostCatalogPriority || foundHost.priority < currentHost.priority) {
          filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));
          filteredHosts.push(currentHost);
        }

        return filteredHosts;
      }, []) : [].concat((0, _toConsumableArray3.default)(this.hosts));
    }

    /**
     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified
     * set of service names.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [service] - Services to filter.
     * @returns {Array<ServiceHost>} - The filtered host array.
     */

  }, {
    key: 'filterService',
    value: function filterService() {
      var service = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // Generate an array of services regardless of parameter type.
      var services = Array.isArray(service) ? service : [service];

      // Filter the host array against the provided services.
      return services.length > 0 ? this.hosts.filter(function (host) {
        return services.includes(host.service);
      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));
    }

    /**
     * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified
     * set of URLs.
     *
     * @private
     * @memberof ServiceRegistry
     * @param {Array<string> | string} [url] - URL to filter.
     * @returns {Array<ServiceHost>} - The filter host array.
     */

  }, {
    key: 'filterUrl',
    value: function filterUrl() {
      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // Generate an array of URLs regardless of the parameter type.
      var urls = Array.isArray(url) ? url : [url];

      // Filter the host array against the provided URLs.
      return urls.length > 0 ? this.hosts.filter(function (host) {
        return urls.includes(host.url);
      }) : [].concat((0, _toConsumableArray3.default)(this.hosts));
    }

    /**
     * Get an array of {@link ServiceHost}s based on a provided
     * {@link HostFilter} from the {@link ServiceRegistry#hosts} array.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} [filter] - The inclusive filter for hosts to find.
     * @returns {Array<ServiceHost>} - The filtered hosts.
     */

  }, {
    key: 'find',
    value: function find() {
      var _this = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          active = _ref.active,
          catalog = _ref.catalog,
          cluster = _ref.cluster,
          local = _ref.local,
          priority = _ref.priority,
          service = _ref.service,
          url = _ref.url;

      return this.hosts.filter(function (host) {
        return _this.filterActive(active).includes(host) && _this.filterCatalog(catalog).includes(host) && _this.filterCluster(cluster).includes(host) && _this.filterLocal(local).includes(host) && _this.filterPriority(priority).includes(host) && _this.filterService(service).includes(host) && _this.filterUrl(url).includes(host);
      });
    }

    /**
     * Load a formatted array of {@link ServiceHost} constructor parameter
     * transfer objects as instances of {@link ServiceHost} class objects to the
     * {@link ServiceRegistry#hosts} array.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {Array<ServiceHost.ConstructorPTO>} hosts
     * @returns {this}
     */

  }, {
    key: 'load',
    value: function load() {
      var _hosts;

      var hosts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      // Validate that the provided hosts are eligible to be loaded.
      var validHosts = hosts.filter(function (host) {
        return !!ServiceRegistry.mapCatalogName({
          id: host.catalog,
          type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING
        });
      });

      // Load the eligible hosts.
      (_hosts = this.hosts).push.apply(_hosts, (0, _toConsumableArray3.default)(validHosts.map(function (loadableHost) {
        return new _serviceHost2.default(loadableHost);
      })));

      return this;
    }

    /**
     * Mark a collection of {@link ServiceHost} class objects from the
     * {@link ServiceRegistry#hosts} array as replaced based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter to mark replaced.
     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked replaced.
     */

  }, {
    key: 'replaced',
    value: function replaced(filter) {
      // Collect a list of hosts to mark as replaced based on the provided filter.
      var replacing = this.find(filter);

      // Mark the hosts from the array as replaced.
      replacing.forEach(function (host) {
        host.setStatus({ replaced: true });
      });

      // Return the marked hosts.
      return replacing;
    }

    /**
     * Reset the failed status of a collection of {@link ServiceHost} class
     * objects from the {@link ServiceRegistry#hosts} array based on the provided
     * {@link HostFilter}.
     *
     * @public
     * @memberof ServiceRegistry
     * @param {HostFilter} filter - The inclusive filter of hosts to reset.
     * @returns {Array<ServiceHost>} - The {@link ServiceHost}s that reset.
     */

  }, {
    key: 'reset',
    value: function reset(filter) {
      // Collect a list of hosts to mark as replaced based on the provided filter.
      var resetting = this.find(filter);

      // Mark the hosts from the array as replaced.
      resetting.forEach(function (host) {
        host.setStatus({ failed: false });
      });

      // Return the marked hosts.
      return resetting;
    }

    /**
     * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated
     * idenfier or value.
     *
     * @public
     * @static
     * @memberof ServiceRegistry
     * @param {Object} pto - The parameter transfer object.
     * @property {string | number} pto.id - The identifier to convert in the enum.
     * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.
     * @returns {string|number} - The matching enum value or index.
     */

  }, {
    key: 'map',
    get: function get() {
      // Get a list of active, local, and priority-mapped hosts.
      return this.find({
        active: true,
        local: true,
        priority: true
      }).reduce(function (map, host) {
        // Generate a new object to assign the existing map.
        var hostReference = {};

        // Assign the key:value pair for the service and url.
        hostReference[host.service] = host.url;

        // Assign the reference to the map and return.
        return (0, _extends3.default)({}, map, hostReference);
      }, {});
    }
  }], [{
    key: 'mapCatalogName',
    value: function mapCatalogName(_ref2) {
      var id = _ref2.id,
          type = _ref2.type;

      // Validate that the id is a number.
      if (typeof id === 'number') {
        // Validate that the desired type is a number.
        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {
          return _constants.SERVICE_CATALOGS[id] !== undefined ? id : undefined;
        }

        // Validate that the desired type is a string.
        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {
          return _constants.SERVICE_CATALOGS[id];
        }
      }

      // Validate that the id is a string.
      if (typeof id === 'string') {
        // Validate that the desired type is a string.
        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING) {
          return _constants.SERVICE_CATALOGS.includes(id) ? id : undefined;
        }

        // Validate that the desired type is a number.
        if (type === _constants.SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {
          return _constants.SERVICE_CATALOGS.includes(id) ? _constants.SERVICE_CATALOGS.indexOf(id) : undefined;
        }
      }

      return undefined;
    }

    /**
     * Generate a formatted array based on the object received from the **U2C**
     * service for usage in the {@link ServiceRegistry#load} method.
     *
     * @public
     * @static
     * @memberof ServiceRegistry
     * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.
     * @throws - If the target catalog does not exist.
     * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}
     */

  }, {
    key: 'mapRemoteCatalog',
    value: function mapRemoteCatalog(_ref3) {
      var catalog = _ref3.catalog,
          hostCatalog = _ref3.hostCatalog,
          serviceLinks = _ref3.serviceLinks;

      // Collect the service catalog name if needed.
      var catalogIndex = ServiceRegistry.mapCatalogName({
        id: catalog,
        type: _constants.SERVICE_CATALOGS_ENUM_TYPES.STRING
      });

      // Validate that the target catalog exists.
      if (!_constants.SERVICE_CATALOGS.includes(catalogIndex)) {
        throw new Error('service-catalogs: \'' + catalog + '\' is not a valid catalog');
      }

      // Map the remote catalog to a mountable host array.
      return (0, _keys2.default)(hostCatalog).reduce(function (output, key) {
        output.push.apply(output, (0, _toConsumableArray3.default)(hostCatalog[key].map(function (host) {
          return {
            catalog: catalogIndex,
            defaultUri: serviceLinks[host.id.split(':')[3]],
            hostGroup: key,
            id: host.id,
            priority: host.priority,
            uri: host.host
          };
        })));

        return output;
      }, []);
    }
  }]);
  return ServiceRegistry;
}();

exports.default = ServiceRegistry;
//# sourceMappingURL=service-registry.js.map
