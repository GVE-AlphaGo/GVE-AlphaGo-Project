'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _serviceUrl = require('./service-url');

var _serviceUrl2 = _interopRequireDefault(_serviceUrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
var ServiceCatalog = _ampersandState2.default.extend({
  namespace: 'ServiceCatalog',

  props: {
    serviceGroups: ['object', true, function () {
      return {
        discovery: [],
        preauth: [],
        signin: [],
        postauth: []
      };
    }],
    status: ['object', true, function () {
      return {
        discovery: {
          ready: false,
          collecting: false
        },
        preauth: {
          ready: false,
          collecting: false
        },
        postauth: {
          ready: false,
          collecting: false
        },
        signin: {
          ready: false,
          collecting: false
        }
      };
    }],
    allowedDomains: ['array', false, function () {
      return [];
    }]
  },

  /**
   * @private
   * Search the service url array to locate a `ServiceUrl`
   * class object based on its name.
   * @param {string} name
   * @param {string} [serviceGroup]
   * @returns {ServiceUrl}
   */
  _getUrl: function _getUrl(name, serviceGroup) {
    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray3.default)(this.serviceGroups.postauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.discovery));

    return serviceUrls.find(function (serviceUrl) {
      return serviceUrl.name === name;
    });
  },


  /**
   * @private
   * Generate an array of `ServiceUrl`s that is organized from highest auth
   * level to lowest auth level.
   * @returns {Array<ServiceUrl>} - array of `ServiceUrl`s
   */
  _listServiceUrls: function _listServiceUrls() {
    return [].concat((0, _toConsumableArray3.default)(this.serviceGroups.postauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.discovery));
  },


  /**
   * @private
   * Safely load one or more `ServiceUrl`s into this `Services` instance.
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _loadServiceUrls: function _loadServiceUrls(serviceGroup, services) {
    var _this = this;

    // declare namespaces outside of loop
    var existingService = void 0;

    services.forEach(function (service) {
      existingService = _this._getUrl(service.name, serviceGroup);

      if (!existingService) {
        _this.serviceGroups[serviceGroup].push(service);
      }
    });

    return this;
  },


  /**
   * @private
   * Safely unload one or more `ServiceUrl`s into this `Services` instance
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _unloadServiceUrls: function _unloadServiceUrls(serviceGroup, services) {
    var _this2 = this;

    // declare namespaces outside of loop
    var existingService = void 0;

    services.forEach(function (service) {
      existingService = _this2._getUrl(service.name, serviceGroup);

      if (existingService) {
        _this2.serviceGroups[serviceGroup].splice(_this2.serviceGroups[serviceGroup].indexOf(existingService), 1);
      }
    });

    return this;
  },


  /**
   * Clear all collected catalog data and reset catalog status.
   *
   * @returns {void}
   */
  clean: function clean() {
    this.serviceGroups.preauth.length = 0;
    this.serviceGroups.signin.length = 0;
    this.serviceGroups.postauth.length = 0;
    this.status.preauth = { ready: false };
    this.status.signin = { ready: false };
    this.status.postauth = { ready: false };
  },


  /**
   * Search over all service groups to find a cluster id based
   * on a given url.
   * @param {string} url - Must be parsable by `Url`
   * @returns {string} - ClusterId of a given url
   */
  findClusterId: function findClusterId(url) {
    var incomingUrlObj = _url2.default.parse(url);
    var serviceUrlObj = void 0;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)((0, _keys2.default)(this.serviceGroups)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(this.serviceGroups[key]), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var service = _step2.value;

            serviceUrlObj = _url2.default.parse(service.defaultUrl);

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = (0, _getIterator3.default)(service.hosts), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var host = _step3.value;

                if (incomingUrlObj.hostname === host.host && host.id) {
                  return host.id;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            if (serviceUrlObj.hostname === incomingUrlObj.hostname && service.hosts.length > 0) {
              // no exact match, so try to grab the first home cluster
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = (0, _getIterator3.default)(service.hosts), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var _host = _step4.value;

                  if (_host.homeCluster) {
                    return _host.id;
                  }
                }

                // no match found still, so return the first entry
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }

              return service.hosts[0].id;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return undefined;
  },


  /**
   * Search over all service groups and return a service value from a provided
   * clusterId. Currently, this method will return either a service name, or a
   * service url depending on the `value` parameter. If the `value` parameter
   * is set to `name`, it will return a service name to be utilized within the
   * Services plugin methods.
   * @param {object} params
   * @param {string} params.clusterId - clusterId of found service
   * @param {boolean} [params.priorityHost = true] - returns priority host url if true
   * @param {string} [params.serviceGroup] - specify service group
   * @returns {object} service
   * @returns {string} service.name
   * @returns {string} service.url
   */
  findServiceFromClusterId: function findServiceFromClusterId() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        clusterId = _ref.clusterId,
        _ref$priorityHost = _ref.priorityHost,
        priorityHost = _ref$priorityHost === undefined ? true : _ref$priorityHost,
        serviceGroup = _ref.serviceGroup;

    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray3.default)(this.serviceGroups.postauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.discovery));

    var identifiedServiceUrl = serviceUrls.find(function (serviceUrl) {
      return serviceUrl.hosts.find(function (host) {
        return host.id === clusterId;
      });
    });

    if (identifiedServiceUrl) {
      return {
        name: identifiedServiceUrl.name,
        url: identifiedServiceUrl.get(priorityHost, clusterId)
      };
    }

    return undefined;
  },


  /**
   * Find a service based on the provided url.
   * @param {string} url - Must be parsable by `Url`
   * @returns {serviceUrl} - ServiceUrl assocated with provided url
   */
  findServiceUrlFromUrl: function findServiceUrlFromUrl(url) {
    var incomingUrlObj = _url2.default.parse(url);
    var serviceUrls = [].concat((0, _toConsumableArray3.default)(this.serviceGroups.discovery), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.postauth));

    return serviceUrls.find(function (serviceUrl) {
      if (incomingUrlObj.hostname === _url2.default.parse(serviceUrl.defaultUrl).hostname) {
        return true;
      }

      if (serviceUrl.hosts.find(function (host) {
        return host.host === incomingUrlObj.hostname;
      })) {
        return true;
      }

      return false;
    });
  },


  /**
   * Finds an allowed domain that matches a specific url.
   *
   * @param {string} url - The url to match the allowed domains against.
   * @returns {string} - The matching allowed domain.
   */
  findAllowedDomain: function findAllowedDomain(url) {
    var urlObj = _url2.default.parse(url);

    if (!urlObj.host) {
      return undefined;
    }

    return this.allowedDomains.find(function (allowedDomain) {
      return urlObj.host.includes(allowedDomain);
    });
  },


  /**
   * Get a service url from the current services list by name.
   * @param {string} name
   * @param {boolean} priorityHost
   * @param {string} serviceGroup
   * @returns {string}
   */
  get: function get(name, priorityHost, serviceGroup) {
    var serviceUrl = this._getUrl(name, serviceGroup);

    return serviceUrl ? serviceUrl.get(priorityHost) : undefined;
  },


  /**
   * Get the current allowed domains list.
   *
   * @returns {Array<string>} - the current allowed domains list.
   */
  getAllowedDomains: function getAllowedDomains() {
    return [].concat((0, _toConsumableArray3.default)(this.allowedDomains));
  },


  /**
   * Creates an object where the keys are the service names
   * and the values are the service urls.
   * @param {boolean} priorityHost - use the highest priority if set to `true`
   * @param {string} [serviceGroup]
   * @returns {Record<string, string>}
   */
  list: function list(priorityHost, serviceGroup) {
    var output = {};

    var serviceUrls = typeof serviceGroup === 'string' ? this.serviceGroups[serviceGroup] || [] : [].concat((0, _toConsumableArray3.default)(this.serviceGroups.discovery), (0, _toConsumableArray3.default)(this.serviceGroups.preauth), (0, _toConsumableArray3.default)(this.serviceGroups.signin), (0, _toConsumableArray3.default)(this.serviceGroups.postauth));

    if (serviceUrls) {
      serviceUrls.forEach(function (serviceUrl) {
        output[serviceUrl.name] = serviceUrl.get(priorityHost);
      });
    }

    return output;
  },


  /**
   * Mark a priority host service url as failed.
   * This will mark the host associated with the
   * `ServiceUrl` to be removed from the its
   * respective host array, and then return the next
   * viable host from the `ServiceUrls` host array,
   * or the `ServiceUrls` default url if no other priority
   * hosts are available, or if `noPriorityHosts` is set to
   * `true`.
   * @param {string} url
   * @param {boolean} noPriorityHosts
   * @returns {string}
   */
  markFailedUrl: function markFailedUrl(url, noPriorityHosts) {
    var _this3 = this;

    var serviceUrl = this._getUrl((0, _keys2.default)(this.list()).find(function (key) {
      return _this3._getUrl(key).failHost(url);
    }));

    if (!serviceUrl) {
      return undefined;
    }

    return noPriorityHosts ? serviceUrl.get(false) : serviceUrl.get(true);
  },


  /**
   * Set the allowed domains for the catalog.
   *
   * @param {Array<string>} allowedDomains - allowed domains to be assigned.
   * @returns {void}
   */
  setAllowedDomains: function setAllowedDomains(allowedDomains) {
    this.allowedDomains = [].concat((0, _toConsumableArray3.default)(allowedDomains));
  },


  /**
   * Update the current list of `ServiceUrl`s against a provided
   * service hostmap.
   * @emits ServiceCatalog#preauthorized
   * @emits ServiceCatalog#postauthorized
   * @param {string} serviceGroup
   * @param {object} serviceHostmap
   * @returns {Services}
   */
  updateServiceUrls: function updateServiceUrls(serviceGroup, serviceHostmap) {
    var _this4 = this;

    var currentServiceUrls = this.serviceGroups[serviceGroup];

    var unusedUrls = currentServiceUrls.filter(function (serviceUrl) {
      return serviceHostmap.every(function (item) {
        return item.name !== serviceUrl.name;
      });
    });

    this._unloadServiceUrls(serviceGroup, unusedUrls);

    serviceHostmap.forEach(function (serviceObj) {
      var service = _this4._getUrl(serviceObj.name, serviceGroup);

      if (service) {
        service.defaultUrl = serviceObj.defaultUrl;
        service.hosts = serviceObj.hosts || [];
      } else {
        _this4._loadServiceUrls(serviceGroup, [new _serviceUrl2.default((0, _extends3.default)({}, serviceObj))]);
      }
    });

    this.status[serviceGroup].ready = true;
    this.trigger(serviceGroup);

    return this;
  },


  /**
   * Wait until the service catalog is available,
   * or reject after a timeout of 60 seconds.
   * @param {string} serviceGroup
   * @param {number} [timeout] - in seconds
   * @returns {Promise<void>}
   */
  waitForCatalog: function waitForCatalog(serviceGroup, timeout) {
    var _this5 = this;

    return new _promise2.default(function (resolve, reject) {
      if (_this5.status[serviceGroup].ready) {
        resolve();
      }

      var timeoutTimer = setTimeout(function () {
        return reject(new Error('services: timeout occured while waiting for \'' + serviceGroup + '\' catalog to populate'));
      }, timeout ? timeout * 1000 : 60000);

      _this5.once(serviceGroup, function () {
        clearTimeout(timeoutTimer);
        resolve();
      });
    });
  }
});
/* eslint-enable no-underscore-dangle */

exports.default = ServiceCatalog;
//# sourceMappingURL=service-catalog.js.map
