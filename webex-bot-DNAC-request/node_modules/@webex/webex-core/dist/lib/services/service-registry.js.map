{"version":3,"sources":["service-registry.js"],"names":["ServiceRegistry","hosts","filter","removing","find","host","includes","failing","forEach","setStatus","failed","active","catalog","catalogs","Array","isArray","map","catalogId","mapCatalogName","id","type","SERVICE_CATALOGS_ENUM_TYPES","STRING","length","cluster","clusters","local","priority","reduce","filteredHosts","currentHost","foundHost","hostGroup","push","foundHostCatalogPriority","NUMBER","currentHostCatalogPriority","splice","indexOf","service","services","url","urls","filterActive","filterCatalog","filterCluster","filterLocal","filterPriority","filterService","filterUrl","validHosts","loadableHost","ServiceHost","replacing","replaced","resetting","hostReference","SERVICE_CATALOGS","undefined","hostCatalog","serviceLinks","catalogIndex","Error","output","key","defaultUri","split","uri"],"mappings":"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","file":"service-registry.js","sourcesContent":["import {\n  SERVICE_CATALOGS,\n  SERVICE_CATALOGS_ENUM_TYPES\n} from './constants';\nimport ServiceHost from './service-host';\n\n/**\n * The parameter transfer object for {@link ServiceRegistry#mapRemoteCatalog}.\n * This object is shaped to match the object returned from the **U2C** service.\n *\n * @typedef {Record<string, string>} RSL\n * @typedef {Record<string, Array<Record<string, number | string>>>} RHC\n *\n * @typedef {Object} MapRemoteCatalogPTO\n * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.\n * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.\n * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.\n */\n\n/**\n * Service manipulation filter object for retrieving services within the\n * {@link ServiceRegistry} class.\n *\n * @typedef {Object} HostFilter\n * @property {boolean} [HostFilter.active] - Active state to filter.\n * @property {Array<string> | string} [HostFilter.catalog] - Catalogs to filter.\n * @property {Array<string> | string} [HostFilter.cluster] - Clusters to filter.\n * @property {boolean} [HostFilter.local] - Filter to the user's home cluster.\n * @property {boolean} [HostFilter.priority] - Filter for the highest priority.\n * @property {Array<string> | string} [HostFilter.service] - Services to filter.\n * @property {Array<string> | string} [HostFilter.url] - URL to filter.\n */\n\n/**\n * @class\n * @classdesc - Manages a collection of {@link ServiceHost} class objects.\n */\nexport default class ServiceRegistry {\n  /**\n   * Generate a new {@link ServiceHost}.\n   *\n   * @public\n   * @constructor\n   * @memberof ServiceHost\n   */\n  constructor() {\n    /**\n     * The collection of managed {@link ServiceHost}s.\n     *\n     * @instance\n     * @type {Array<ServiceHost>}\n     * @private\n     * @memberof ServiceRegistry\n     */\n    this.hosts = [];\n  }\n\n  /**\n   * An active, local, and priority mapped record of the current\n   * {@link ServiceCatalog#hosts}.\n   *\n   * @public\n   * @memberof ServiceCatalog\n   * @type {Record<string, string>}\n   */\n  get map() {\n    // Get a list of active, local, and priority-mapped hosts.\n    return this.find({\n      active: true,\n      local: true,\n      priority: true\n    }).reduce(\n      (map, host) => {\n        // Generate a new object to assign the existing map.\n        const hostReference = {};\n\n        // Assign the key:value pair for the service and url.\n        hostReference[host.service] = host.url;\n\n        // Assign the reference to the map and return.\n        return {...map, ...hostReference};\n      }, {}\n    );\n  }\n\n  /**\n   * Removes a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter for hosts to remove.\n   * @returns {Array<ServiceHost>} - The removed {@link ServiceHost}s.\n   */\n  clear(filter) {\n    // Collect a list of hosts to remove based on the provided filter.\n    const removing = this.find(filter);\n\n    // Remove the hosts from the array.\n    this.hosts = this.hosts.filter(\n      (host) => !removing.includes(host)\n    );\n\n    // Return the removed hosts.\n    return removing;\n  }\n\n  /**\n   * Mark a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array as failed based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter for hosts to mark failed.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked failed.\n   */\n  failed(filter) {\n    // Collect a list of hosts to mark as failed based on the provided filter.\n    const failing = this.find(filter);\n\n    // Mark the hosts from the array as failed.\n    failing.forEach(\n      (host) => {\n        host.setStatus({failed: true});\n      }\n    );\n\n    // Return the marked hosts.\n    return failing;\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their active states.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [active] - Filter for the host state.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterActive(active) {\n    // Filter the host array if the active requirement is true.\n    return (typeof active === 'boolean') ?\n      this.hosts.filter((host) => host.active === active) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their assigned\n   * catalog values.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [catalog] - Catalogs to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCatalog(catalog = []) {\n    // Generate a catalog names array based on the provided catalog param.\n    const catalogs = (Array.isArray(catalog) ? catalog : [catalog])\n      .map((catalogId) => ServiceRegistry.mapCatalogName({\n        id: catalogId,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      }) || catalogId);\n\n    // Filter the host array against the catalog names array.\n    return (catalogs.length > 0) ?\n      this.hosts.filter((host) => catalogs.includes(host.catalog)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their assigned\n   * cluster values.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [cluster] - Clusters to filter for.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterCluster(cluster = []) {\n    // Generate an array of clusters regardless of parameter type.\n    const clusters = (Array.isArray(cluster) ? cluster : [cluster]);\n\n    // Filter the host array against the provided clusters.\n    return (clusters.length > 0) ?\n      this.hosts.filter((host) => clusters.includes(host.id)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array against their location in\n   * reference to the authenticated user.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [local] - Filter for the host location.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterLocal(local) {\n    return (typeof local === 'boolean') ?\n      this.hosts.filter((host) => host.local === local) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for the highest priority\n   * hosts for each specific service.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {boolean} [priority] - Filter for the highest priority\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterPriority(priority) {\n    return (priority) ?\n      this.hosts.reduce(\n        (filteredHosts, currentHost) => {\n          // Validate that the current host is not active.\n          if (!currentHost.active) {\n            return filteredHosts;\n          }\n\n          // Determine if the filtered hosts array contains a host from the same\n          // host group.\n          const foundHost = filteredHosts.find(\n            (host) => host.hostGroup === currentHost.hostGroup\n          );\n\n          // Validate if a host was found.\n          if (!foundHost) {\n            filteredHosts.push(currentHost);\n\n            return filteredHosts;\n          }\n\n          // Map the found host's catalog to its priority value.\n          const foundHostCatalogPriority = ServiceRegistry.mapCatalogName({\n            id: foundHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Map the current host's catalog to its priority value.\n          const currentHostCatalogPriority = ServiceRegistry.mapCatalogName({\n            id: currentHost.catalog,\n            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER\n          });\n\n          // Validate if the found host has a lower priority than the current\n          // host.\n          if (\n            foundHostCatalogPriority < currentHostCatalogPriority ||\n            foundHost.priority < currentHost.priority\n          ) {\n            filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));\n            filteredHosts.push(currentHost);\n          }\n\n          return filteredHosts;\n        }, []\n      ) : [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n   * set of service names.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [service] - Services to filter.\n   * @returns {Array<ServiceHost>} - The filtered host array.\n   */\n  filterService(service = []) {\n    // Generate an array of services regardless of parameter type.\n    const services = (Array.isArray(service) ? service : [service]);\n\n    // Filter the host array against the provided services.\n    return (services.length > 0) ?\n      this.hosts.filter((host) => services.includes(host.service)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Filter the {@link ServiceRegistry#hosts} array for hosts with a specified\n   * set of URLs.\n   *\n   * @private\n   * @memberof ServiceRegistry\n   * @param {Array<string> | string} [url] - URL to filter.\n   * @returns {Array<ServiceHost>} - The filter host array.\n   */\n  filterUrl(url = []) {\n    // Generate an array of URLs regardless of the parameter type.\n    const urls = (Array.isArray(url) ? url : [url]);\n\n    // Filter the host array against the provided URLs.\n    return (urls.length > 0) ?\n      this.hosts.filter((host) => urls.includes(host.url)) :\n      [...this.hosts];\n  }\n\n  /**\n   * Get an array of {@link ServiceHost}s based on a provided\n   * {@link HostFilter} from the {@link ServiceRegistry#hosts} array.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} [filter] - The inclusive filter for hosts to find.\n   * @returns {Array<ServiceHost>} - The filtered hosts.\n   */\n  find({\n    active,\n    catalog,\n    cluster,\n    local,\n    priority,\n    service,\n    url\n  } = {}) {\n    return this.hosts.filter(\n      (host) => (\n        this.filterActive(active).includes(host) &&\n        this.filterCatalog(catalog).includes(host) &&\n        this.filterCluster(cluster).includes(host) &&\n        this.filterLocal(local).includes(host) &&\n        this.filterPriority(priority).includes(host) &&\n        this.filterService(service).includes(host) &&\n        this.filterUrl(url).includes(host)\n      )\n    );\n  }\n\n  /**\n   * Load a formatted array of {@link ServiceHost} constructor parameter\n   * transfer objects as instances of {@link ServiceHost} class objects to the\n   * {@link ServiceRegistry#hosts} array.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {Array<ServiceHost.ConstructorPTO>} hosts\n   * @returns {this}\n   */\n  load(hosts = []) {\n    // Validate that the provided hosts are eligible to be loaded.\n    const validHosts = hosts.filter((host) => !!(\n      ServiceRegistry.mapCatalogName({\n        id: host.catalog,\n        type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n      })));\n\n    // Load the eligible hosts.\n    this.hosts.push(\n      ...validHosts.map((loadableHost) => new ServiceHost(loadableHost))\n    );\n\n    return this;\n  }\n\n  /**\n   * Mark a collection of {@link ServiceHost} class objects from the\n   * {@link ServiceRegistry#hosts} array as replaced based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter to mark replaced.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s marked replaced.\n   */\n  replaced(filter) {\n    // Collect a list of hosts to mark as replaced based on the provided filter.\n    const replacing = this.find(filter);\n\n    // Mark the hosts from the array as replaced.\n    replacing.forEach(\n      (host) => {\n        host.setStatus({replaced: true});\n      }\n    );\n\n    // Return the marked hosts.\n    return replacing;\n  }\n\n  /**\n   * Reset the failed status of a collection of {@link ServiceHost} class\n   * objects from the {@link ServiceRegistry#hosts} array based on the provided\n   * {@link HostFilter}.\n   *\n   * @public\n   * @memberof ServiceRegistry\n   * @param {HostFilter} filter - The inclusive filter of hosts to reset.\n   * @returns {Array<ServiceHost>} - The {@link ServiceHost}s that reset.\n   */\n  reset(filter) {\n    // Collect a list of hosts to mark as replaced based on the provided filter.\n    const resetting = this.find(filter);\n\n    // Mark the hosts from the array as replaced.\n    resetting.forEach(\n      (host) => {\n        host.setStatus({failed: false});\n      }\n    );\n\n    // Return the marked hosts.\n    return resetting;\n  }\n\n  /**\n   * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated\n   * idenfier or value.\n   *\n   * @public\n   * @static\n   * @memberof ServiceRegistry\n   * @param {Object} pto - The parameter transfer object.\n   * @property {string | number} pto.id - The identifier to convert in the enum.\n   * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.\n   * @returns {string|number} - The matching enum value or index.\n   */\n  static mapCatalogName({id, type}) {\n    // Validate that the id is a number.\n    if (typeof id === 'number') {\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS[id] !== undefined) ? id : undefined;\n      }\n\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS[id];\n      }\n    }\n\n    // Validate that the id is a string.\n    if (typeof id === 'string') {\n      // Validate that the desired type is a string.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {\n        return SERVICE_CATALOGS.includes(id) ? id : undefined;\n      }\n\n      // Validate that the desired type is a number.\n      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {\n        return (SERVICE_CATALOGS.includes(id)) ?\n          SERVICE_CATALOGS.indexOf(id) :\n          undefined;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Generate a formatted array based on the object received from the **U2C**\n   * service for usage in the {@link ServiceRegistry#load} method.\n   *\n   * @public\n   * @static\n   * @memberof ServiceRegistry\n   * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.\n   * @throws - If the target catalog does not exist.\n   * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}\n   */\n  static mapRemoteCatalog({catalog, hostCatalog, serviceLinks}) {\n    // Collect the service catalog name if needed.\n    const catalogIndex = ServiceRegistry.mapCatalogName({\n      id: catalog,\n      type: SERVICE_CATALOGS_ENUM_TYPES.STRING\n    });\n\n    // Validate that the target catalog exists.\n    if (!SERVICE_CATALOGS.includes(catalogIndex)) {\n      throw new Error(`service-catalogs: '${catalog}' is not a valid catalog`);\n    }\n\n    // Map the remote catalog to a mountable host array.\n    return Object.keys(hostCatalog).reduce((output, key) => {\n      output.push(\n        ...hostCatalog[key].map((host) => ({\n          catalog: catalogIndex,\n          defaultUri: serviceLinks[host.id.split(':')[3]],\n          hostGroup: key,\n          id: host.id,\n          priority: host.priority,\n          uri: host.host\n        }))\n      );\n\n      return output;\n    }, []);\n  }\n}\n"]}