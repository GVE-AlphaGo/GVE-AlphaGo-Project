'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _desc, _value, _obj; /*!
                          * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
                          */

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var Search = _webexCore.WebexPlugin.extend((_obj = {
  namespace: 'Search',

  people: function people(options) {
    options = options || {};

    if (!options.queryString && options.query) {
      options.queryString = options.query;
      (0, _deleteProperty2.default)(options, 'query');
    }

    if (!options.queryString) {
      return _promise2.default.reject(new Error('`options.query` is required'));
    }

    return this.request({
      api: 'argonaut',
      resource: 'directory',
      method: 'POST',
      body: options
    }).then(function (res) {
      return res.body;
    });
  },
  bindSearchKey: function bindSearchKey() {
    var _this = this;

    return this.webex.internal.encryption.kms.createUnboundKeys({ count: 1 }).then(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 1),
          key = _ref2[0];

      return _this.webex.internal.encryption.kms.createResource({
        key: key,
        userIds: [_this.webex.internal.device.userId]
      }).then(function () {
        return _this.webex.internal.device.set('searchEncryptionKeyUrl', key.uri);
      });
    });
  },


  /**
  * Fetches search result activities
  * @param {Object} options
  * @param {boolean} options.includeRemoteClusterReferences when true,
  * includes search results from remote clusters
  * @returns {Promise<Array>} Resolves with the activities
  */
  search: function search(options) {
    var _this2 = this;

    /* eslint max-nested-callbacks: [0] */
    options = options || {};

    var promise = _promise2.default.resolve();

    if (!this.webex.internal.device.searchEncryptionKeyUrl) {
      promise = this.bindSearchKey();
    }

    return promise.then(function () {
      return _this2.webex.request({
        service: 'argonaut',
        resource: 'search',
        method: 'POST',
        body: (0, _assign2.default)(options, {
          searchEncryptionKeyUrl: _this2.webex.internal.device.searchEncryptionKeyUrl
        })
      });
    }).then(function (res) {
      var resActivities = (0, _get3.default)(res, 'body.activities.items', []);

      if (options.includeRemoteClusterReferences && res.body.breadcrumbs) {
        var breadcrumbs = res.body.breadcrumbs;

        var promises = [];

        (0, _keys2.default)(breadcrumbs).forEach(function (cluster) {
          // Map activity URLs to their cluster
          var editedCluster = cluster + ':identityLookup';
          var clusterActivityUrls = breadcrumbs[cluster].items.map(function (activity) {
            return activity.activityUrl;
          });

          // Find activities per cluster
          var bulkActivitiesPromise = _this2.webex.internal.conversation.bulkActivitiesFetch(clusterActivityUrls, editedCluster).catch(function (err) {
            _this2.logger.warn('search: error fetching from remote clusters', err);

            return _promise2.default.resolve([]);
          });

          promises.push(bulkActivitiesPromise);
        });

        return _promise2.default.all(promises).then(function (clusterResults) {
          return clusterResults.reduce(function (accumulator, clusterResult) {
            return accumulator.concat(clusterResult);
          }, resActivities);
        });
      }

      return resActivities;
    });
  },
  version: '1.80.147'
}, (_applyDecoratedDescriptor(_obj, 'bindSearchKey', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'bindSearchKey'), _obj)), _obj));

exports.default = Search;
//# sourceMappingURL=search.js.map
