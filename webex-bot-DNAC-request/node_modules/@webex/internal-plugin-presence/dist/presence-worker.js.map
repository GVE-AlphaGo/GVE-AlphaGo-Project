{"version":3,"sources":["presence-worker.js"],"names":["PresenceWorker","debouncedFetch","checkFetchers","FETCH_DELAY","presences","watchers","fetchers","flights","campers","subscribers","webex","internal","Error","mercury","connected","resolve","connect","then","on","APHELEIA_SUBSCRIPTION_UPDATE","subscriptionUpdate","bind","setInterval","groundskeeper","GROUNDSKEEPER_INTERVAL","event","data","subject","Date","getTime","presence","emitEvent","PRESENCE_UPDATE","type","ENVELOPE_TYPE","SUBSCRIPTION","payload","id","now","UPDATE_PRESENCE_DELAY","boarding","list","response","statusList","forEach","PRESENCE","camper","time","SUBSCRIPTION_DELAY","push","renewIds","subscription","expiration","PREMATURE_EXPIRATION_SUBSCRIPTION_TIME","trash","tenMinutesAgo","EXPIRED_PRESENCE_TIME","lastUpdated","length","DELETE","checkCampers","renewSubscriptions","checkSubscriptions","ids","subscribe","body","responses","responseCode","ttl","subscriptionTtl","status","DEFAULT_SUBSCRIPTION_TTL","cleanPresences"],"mappings":"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","file":"presence-worker.js","sourcesContent":["\nimport {debounce} from 'lodash';\n\nimport {\n  FETCH_DELAY,\n  GROUNDSKEEPER_INTERVAL,\n  SUBSCRIPTION_DELAY,\n  UPDATE_PRESENCE_DELAY,\n  EXPIRED_PRESENCE_TIME,\n  PREMATURE_EXPIRATION_SUBSCRIPTION_TIME,\n  DEFAULT_SUBSCRIPTION_TTL,\n  APHELEIA_SUBSCRIPTION_UPDATE,\n  PRESENCE_UPDATE,\n  ENVELOPE_TYPE\n} from './constants';\n\n/**\n * Presence Worker\n * Manages fetches and subscriptions for presence\n * @class\n */\nexport default class PresenceWorker {\n  /**\n   * Constructs a presence worker to execute and\n   * maintain tasks related to presence upkeep.\n   * @returns {undefined}\n   */\n  constructor() {\n    this.presences = {}; // current presence objects; updated time\n    this.watchers = {}; // counter of visible presence-required objects\n    this.fetchers = {}; // waiting to get presence object\n    this.flights = {}; // in flight to get presence object\n    this.campers = {}; // waiting to subscribe; updated time\n    this.subscribers = {}; // current subscriptions; expiration time\n  }\n\n  /**\n   * Connect to the mercury for presence and starts worker.\n   * @param {object} webex\n   * @returns {undefined}\n   */\n  initialize(webex) {\n    if (!webex || !webex.internal) {\n      throw new Error('Must initialize Presence Worker with webex!');\n    }\n\n    this.webex = webex;\n\n    const mercury = this.webex.internal.mercury.connected ?\n      Promise.resolve() : this.webex.internal.mercury.connect();\n\n    mercury.then(() => {\n      this.webex.internal.mercury.on(APHELEIA_SUBSCRIPTION_UPDATE,\n        this.subscriptionUpdate.bind(this));\n    });\n\n    setInterval(this.groundskeeper.bind(this), GROUNDSKEEPER_INTERVAL);\n  }\n\n  /**\n   * Trigger a subscription update event.\n   * @param {string} event\n   * @returns {undefined}\n   */\n  subscriptionUpdate(event) {\n    this.presences[event.data.subject] = new Date().getTime();\n\n    this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n      type: ENVELOPE_TYPE.SUBSCRIPTION,\n      payload: event.data\n    });\n  }\n\n  /**\n   * Retrieves and subscribes to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  enqueue(id) {\n    const now = new Date().getTime();\n\n    if (this.watchers[id]) {\n      this.watchers[id] += 1;\n    }\n    else {\n      this.watchers[id] = 1;\n    }\n\n    if (this.subscribers[id]) {\n      return;\n    }\n\n    if (!this.campers[id]) {\n      this.campers[id] = now;\n    }\n\n    // Retrieve presence if:\n    // not in flight or\n    // don't already have the presence or\n    // presence has gone stale\n    if (!this.flights[id] &&\n        (!this.presences[id] ||\n        this.presences[id] < now - UPDATE_PRESENCE_DELAY)) {\n      this.fetchers[id] = id;\n      this.debouncedFetch();\n    }\n  }\n\n  /**\n   * Retract from subscribing to a user's presence.\n   * @param {string} id\n   * @returns {undefined}\n   */\n  dequeue(id) {\n    if (this.watchers[id]) {\n      this.watchers[id] -= 1;\n\n      if (this.watchers[id] <= 0) {\n        delete this.watchers[id];\n        delete this.fetchers[id];\n        delete this.campers[id];\n      }\n    }\n  }\n\n  /**\n   * Retrieve users' presences.\n   * @returns {undefined}\n   */\n  checkFetchers() {\n    const boarding = this.fetchers;\n\n    Object.assign(this.flights, boarding);\n    this.fetchers = {};\n\n\n    this.webex.internal.presence.list(Object.keys(boarding))\n      .then((response) => {\n        const now = new Date().getTime();\n\n        response.statusList.forEach((presence) => {\n          const id = presence.subject;\n\n          delete this.flights[id];\n          this.presences[id] = now;\n        });\n\n        this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n          type: ENVELOPE_TYPE.PRESENCE,\n          payload: response\n        });\n      });\n  }\n\n  debouncedFetch = debounce(this.checkFetchers, FETCH_DELAY)\n\n  /**\n   * Determine if we should subscribe to users' presences.\n   * @returns {Array}: User ids to subscribe.\n   */\n  checkCampers() {\n    const now = new Date().getTime();\n    const subscribers = [];\n\n    Object.entries(this.campers).forEach((camper) => {\n      const id = camper[0];\n      const time = camper[1];\n\n      // Subscribe if they've been camping for a minute\n      if (time < now - SUBSCRIPTION_DELAY) {\n        delete this.campers[id];\n        this.subscribers[id] = null;\n        subscribers.push(id);\n      }\n    });\n\n    return subscribers;\n  }\n\n  /**\n   * Determine if we should re-subscribe or remove users' subscriptions.\n   * @returns {Array}: User ids to re-subscribe.\n   */\n  checkSubscriptions() {\n    const now = new Date().getTime();\n\n    const renewIds = [];\n\n    Object.entries(this.subscribers).forEach((subscription) => {\n      const id = subscription[0];\n      const expiration = subscription[1];\n\n      if (expiration) {\n        // Renew subscription if they're about to expire\n        if (this.watchers[id] &&\n            now > expiration - PREMATURE_EXPIRATION_SUBSCRIPTION_TIME) {\n          renewIds.push(id);\n        }\n        else if (now > expiration) {\n          delete this.subscribers[id];\n        }\n      }\n    });\n\n    return renewIds;\n  }\n\n  /**\n   * Remove expired presence objects.\n   * @returns {undefined}\n   */\n  cleanPresences() {\n    const trash = [];\n    const tenMinutesAgo = new Date().getTime() - EXPIRED_PRESENCE_TIME;\n\n    Object.entries(this.presences).forEach((presence) => {\n      const id = presence[0];\n      const lastUpdated = presence[1];\n\n      // Delete the object if it is stale\n      if (lastUpdated < tenMinutesAgo) {\n        delete this.presences[id];\n        trash.push(id);\n      }\n    });\n\n    // Tells client to delete it too\n    if (trash.length) {\n      this.webex.internal.presence.emitEvent(PRESENCE_UPDATE, {\n        type: ENVELOPE_TYPE.DELETE,\n        payload: trash\n      });\n    }\n  }\n\n  /**\n   * Execute chores on an interval.\n   * Checks if we should make new subscribe,\n   * checks if we should re-subscribe,\n   * removes expired subscriptions,\n   * removes expired presence objects.\n   * @returns {undefined}\n   */\n  groundskeeper() {\n    const campers = this.checkCampers();\n    const renewSubscriptions = this.checkSubscriptions();\n\n    const ids = [\n      ...campers,\n      ...renewSubscriptions\n    ];\n\n    if (ids.length) {\n      this.webex.internal.presence.subscribe(ids)\n        .then((body) => {\n          const now = new Date().getTime();\n\n          body.responses.forEach((response) => {\n            if (response.responseCode === 200) {\n              const ttl = response.subscriptionTtl * 1000;\n\n              this.subscribers[response.subject] = now + ttl;\n              this.presences[response.status.subject] = now;\n            }\n            else {\n              // If it errored for any reason, set the ttl so we clean it out eventually\n              this.subscribers[response.subject] = now + DEFAULT_SUBSCRIPTION_TTL;\n            }\n          });\n        });\n    }\n\n    this.cleanPresences();\n  }\n}\n\n"]}