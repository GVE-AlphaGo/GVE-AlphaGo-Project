'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

require('@webex/internal-plugin-device');

var _webexCore = require('@webex/webex-core');

var _presenceBatcher = require('./presence-batcher');

var _presenceBatcher2 = _interopRequireDefault(_presenceBatcher);

var _presenceWorker = require('./presence-worker');

var _presenceWorker2 = _interopRequireDefault(_presenceWorker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var defaultSubscriptionTtl = 600;
var USER = 'user';
var USER_PRESENCE_ENABLED = 'user-presence-enabled';

/**
 * @class
 * @extends WebexPlugin
 */
var Presence = _webexCore.WebexPlugin.extend({
  namespace: 'Presence',

  children: {
    batcher: _presenceBatcher2.default
  },

  session: {
    worker: {
      default: function _default() {
        return new _presenceWorker2.default();
      },

      type: 'any'
    }
  },

  /**
   * Initialize the presence worker for client
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this = this;

    this.webex.once('ready', function () {
      if (_this.config.initializeWorker) {
        _this.worker.initialize(_this.webex);
      }
    });
  },


  /**
   * Trigger an event.
   * @param {string} event
   * @param {string} payload
   * @returns {undefined}
   */
  emitEvent: function emitEvent(event, payload) {
    if (payload.type && payload.payload) {
      this.trigger(event, payload);
    }
  },


  /**
   * Enables presence feature
   * @returns {Promise<boolean>} resolves with true, if successful
   */
  enable: function enable() {
    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, true).then(function (response) {
      return response.value;
    });
  },


  /**
   * Disables presence feature
   * @returns {Promise<boolean>} resolves with false, if successful
   */
  disable: function disable() {
    return this.webex.internal.feature.setFeature(USER, USER_PRESENCE_ENABLED, false).then(function (response) {
      return response.value;
    });
  },


  /**
   * Returns true if presence is enabled, false otherwise
   * @returns {Promise<boolean>} resolves with true if presence is enabled
   */
  isEnabled: function isEnabled() {
    return this.webex.internal.feature.getFeature(USER, USER_PRESENCE_ENABLED);
  },


  /**
   * The status object
   * @typedef {Object} PresenceStatusObject
   * @property {string} url: Public resource identifier for presence
   * @property {string} subject: User ID for the user the returned composed presence represents
   * @property {string} status: Current composed presence state
   * @property {string} statusTime: DateTime in RFC3339 format that the current status began
   * @property {string} lastActive: DateTime in RFC3339 format that the service last saw activity from the user.
   * @property {string} expires: DEPRECATED - DateTime in RFC3339 format that represents when the current
   * status will expire. Will not exist if expiresTTL is -1.
   * @property {Number} expiresTTL: TTL in seconds until the status will expire. If TTL is -1 the current
   * status has no known expiration.
   * @property {string} expiresTime: DateTime in RFC3339 format that the current status will expire. Missing
   * field means no known expiration.
   * @property {Object} vectorCounters: Used for packet ordering and tracking.
   * @property {Boolean} suppressNotifications: Indicates if notification suppresion is recommended for this status.
   * @property {string} lastSeenDeviceUrl: Resource Identifier of the last device to post presence activity for
   * this user.
   */

  /**
   * Gets the current presence status of a given person id
   * @param {string} personId
   * @returns {Promise<PresenceStatusObject>} resolves with status object of person
   */
  get: function get(personId) {
    if (!personId) {
      return _promise2.default.reject(new Error('A person id is required'));
    }

    return this.webex.request({
      method: 'GET',
      service: 'apheleia',
      resource: 'compositions?userId=' + personId
    }).then(function (response) {
      return response.body;
    });
  },


  /**
  * @typedef {Object} PresenceStatusesObject
  * @property {Array.<PresenceStatusObject>} statusList
   */
  /**
   * Gets the current presence statuses of an array of people ids
   * @param {Array} personIds
   * @returns {Promise<PresenceStatusesObject>} resolves with an object with key of `statusList` array
   */
  list: function list(personIds) {
    var _this2 = this;

    if (!personIds || !Array.isArray(personIds)) {
      return _promise2.default.reject(new Error('An array of person ids is required'));
    }

    return _promise2.default.all(personIds.map(function (id) {
      return _this2.batcher.request(id);
    })).then(function (presences) {
      return { statusList: presences };
    });
  },


  /**
   * Subscribes to a person's presence status updates
   * Updates are sent via mercury events `apheleia.subscription_update`
   * @param {string | Array} personIds
   * @param {number} subscriptionTtl - Requested length of subscriptions in seconds.
   * @returns {Promise}
   */
  subscribe: function subscribe(personIds) {
    var _this3 = this;

    var subscriptionTtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSubscriptionTtl;

    var subjects = void 0;
    var batches = [];
    var batchLimit = 50;

    if (!personIds) {
      return _promise2.default.reject(new Error('A person id is required'));
    }
    if (Array.isArray(personIds)) {
      subjects = personIds;
    } else {
      subjects = [personIds];
    }
    // Limit batches to 50 ids per request
    for (var i = 0; i < subjects.length; i += batchLimit) {
      batches.push(subjects.slice(i, i + batchLimit));
    }

    return _promise2.default.all(batches.map(function (ids) {
      return _this3.webex.request({
        method: 'POST',
        api: 'apheleia',
        resource: 'subscriptions',
        body: {
          subjects: ids,
          subscriptionTtl: subscriptionTtl,
          includeStatus: true
        }
      }).then(function (response) {
        return response.body.responses;
      });
    })).then(function (idBatches) {
      var _ref;

      return { responses: (_ref = []).concat.apply(_ref, (0, _toConsumableArray3.default)(idBatches)) };
    });
  },


  /**
   * Unsubscribes from a person or group of people's presence subscription
   * @param {string | Array} personIds
   * @returns {Promise}
   */
  unsubscribe: function unsubscribe(personIds) {
    var subjects = void 0;

    if (!personIds) {
      return _promise2.default.reject(new Error('A person id is required'));
    }
    if (Array.isArray(personIds)) {
      subjects = personIds;
    } else {
      subjects = [personIds];
    }

    return this.webex.request({
      method: 'POST',
      api: 'apheleia',
      resource: 'subscriptions',
      body: {
        subjects: subjects,
        subscriptionTtl: 0,
        includeStatus: true
      }
    });
  },


  /**
   * Sets the status of the current user
   * @param {string} status - active | inactive | ooo | dnd
   * @param {number} ttl - Time To Live for the event in seconds.
   * @returns {Promise}
   */
  setStatus: function setStatus(status, ttl) {
    if (!status) {
      return _promise2.default.reject(new Error('A status is required'));
    }

    return this.webex.request({
      method: 'POST',
      api: 'apheleia',
      resource: 'events',
      body: {
        subject: this.webex.internal.device.userId,
        eventType: status,
        ttl: ttl
      }
    }).then(function (response) {
      return response.body;
    });
  },


  /**
   * Retrieves and subscribes to a user's presence.
   * @param {string} id
   * @returns {undefined}
   */
  enqueue: function enqueue(id) {
    return this.worker.enqueue(id);
  },


  /**
   * Retract from subscribing to a user's presence.
   * @param {string} id
   * @returns {undefined}
   */
  dequeue: function dequeue(id) {
    return this.worker.dequeue(id);
  },
  version: '1.80.147'
});

exports.default = Presence;
//# sourceMappingURL=presence.js.map
