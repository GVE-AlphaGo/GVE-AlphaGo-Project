'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Presence Worker
 * Manages fetches and subscriptions for presence
 * @class
 */
var PresenceWorker = function () {
  /**
   * Constructs a presence worker to execute and
   * maintain tasks related to presence upkeep.
   * @returns {undefined}
   */
  function PresenceWorker() {
    (0, _classCallCheck3.default)(this, PresenceWorker);
    this.debouncedFetch = (0, _debounce3.default)(this.checkFetchers, _constants.FETCH_DELAY);

    this.presences = {}; // current presence objects; updated time
    this.watchers = {}; // counter of visible presence-required objects
    this.fetchers = {}; // waiting to get presence object
    this.flights = {}; // in flight to get presence object
    this.campers = {}; // waiting to subscribe; updated time
    this.subscribers = {}; // current subscriptions; expiration time
  }

  /**
   * Connect to the mercury for presence and starts worker.
   * @param {object} webex
   * @returns {undefined}
   */


  (0, _createClass3.default)(PresenceWorker, [{
    key: 'initialize',
    value: function initialize(webex) {
      var _this = this;

      if (!webex || !webex.internal) {
        throw new Error('Must initialize Presence Worker with webex!');
      }

      this.webex = webex;

      var mercury = this.webex.internal.mercury.connected ? _promise2.default.resolve() : this.webex.internal.mercury.connect();

      mercury.then(function () {
        _this.webex.internal.mercury.on(_constants.APHELEIA_SUBSCRIPTION_UPDATE, _this.subscriptionUpdate.bind(_this));
      });

      setInterval(this.groundskeeper.bind(this), _constants.GROUNDSKEEPER_INTERVAL);
    }

    /**
     * Trigger a subscription update event.
     * @param {string} event
     * @returns {undefined}
     */

  }, {
    key: 'subscriptionUpdate',
    value: function subscriptionUpdate(event) {
      this.presences[event.data.subject] = new Date().getTime();

      this.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {
        type: _constants.ENVELOPE_TYPE.SUBSCRIPTION,
        payload: event.data
      });
    }

    /**
     * Retrieves and subscribes to a user's presence.
     * @param {string} id
     * @returns {undefined}
     */

  }, {
    key: 'enqueue',
    value: function enqueue(id) {
      var now = new Date().getTime();

      if (this.watchers[id]) {
        this.watchers[id] += 1;
      } else {
        this.watchers[id] = 1;
      }

      if (this.subscribers[id]) {
        return;
      }

      if (!this.campers[id]) {
        this.campers[id] = now;
      }

      // Retrieve presence if:
      // not in flight or
      // don't already have the presence or
      // presence has gone stale
      if (!this.flights[id] && (!this.presences[id] || this.presences[id] < now - _constants.UPDATE_PRESENCE_DELAY)) {
        this.fetchers[id] = id;
        this.debouncedFetch();
      }
    }

    /**
     * Retract from subscribing to a user's presence.
     * @param {string} id
     * @returns {undefined}
     */

  }, {
    key: 'dequeue',
    value: function dequeue(id) {
      if (this.watchers[id]) {
        this.watchers[id] -= 1;

        if (this.watchers[id] <= 0) {
          delete this.watchers[id];
          delete this.fetchers[id];
          delete this.campers[id];
        }
      }
    }

    /**
     * Retrieve users' presences.
     * @returns {undefined}
     */

  }, {
    key: 'checkFetchers',
    value: function checkFetchers() {
      var _this2 = this;

      var boarding = this.fetchers;

      (0, _assign2.default)(this.flights, boarding);
      this.fetchers = {};

      this.webex.internal.presence.list((0, _keys2.default)(boarding)).then(function (response) {
        var now = new Date().getTime();

        response.statusList.forEach(function (presence) {
          var id = presence.subject;

          delete _this2.flights[id];
          _this2.presences[id] = now;
        });

        _this2.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {
          type: _constants.ENVELOPE_TYPE.PRESENCE,
          payload: response
        });
      });
    }
  }, {
    key: 'checkCampers',


    /**
     * Determine if we should subscribe to users' presences.
     * @returns {Array}: User ids to subscribe.
     */
    value: function checkCampers() {
      var _this3 = this;

      var now = new Date().getTime();
      var subscribers = [];

      (0, _entries2.default)(this.campers).forEach(function (camper) {
        var id = camper[0];
        var time = camper[1];

        // Subscribe if they've been camping for a minute
        if (time < now - _constants.SUBSCRIPTION_DELAY) {
          delete _this3.campers[id];
          _this3.subscribers[id] = null;
          subscribers.push(id);
        }
      });

      return subscribers;
    }

    /**
     * Determine if we should re-subscribe or remove users' subscriptions.
     * @returns {Array}: User ids to re-subscribe.
     */

  }, {
    key: 'checkSubscriptions',
    value: function checkSubscriptions() {
      var _this4 = this;

      var now = new Date().getTime();

      var renewIds = [];

      (0, _entries2.default)(this.subscribers).forEach(function (subscription) {
        var id = subscription[0];
        var expiration = subscription[1];

        if (expiration) {
          // Renew subscription if they're about to expire
          if (_this4.watchers[id] && now > expiration - _constants.PREMATURE_EXPIRATION_SUBSCRIPTION_TIME) {
            renewIds.push(id);
          } else if (now > expiration) {
            delete _this4.subscribers[id];
          }
        }
      });

      return renewIds;
    }

    /**
     * Remove expired presence objects.
     * @returns {undefined}
     */

  }, {
    key: 'cleanPresences',
    value: function cleanPresences() {
      var _this5 = this;

      var trash = [];
      var tenMinutesAgo = new Date().getTime() - _constants.EXPIRED_PRESENCE_TIME;

      (0, _entries2.default)(this.presences).forEach(function (presence) {
        var id = presence[0];
        var lastUpdated = presence[1];

        // Delete the object if it is stale
        if (lastUpdated < tenMinutesAgo) {
          delete _this5.presences[id];
          trash.push(id);
        }
      });

      // Tells client to delete it too
      if (trash.length) {
        this.webex.internal.presence.emitEvent(_constants.PRESENCE_UPDATE, {
          type: _constants.ENVELOPE_TYPE.DELETE,
          payload: trash
        });
      }
    }

    /**
     * Execute chores on an interval.
     * Checks if we should make new subscribe,
     * checks if we should re-subscribe,
     * removes expired subscriptions,
     * removes expired presence objects.
     * @returns {undefined}
     */

  }, {
    key: 'groundskeeper',
    value: function groundskeeper() {
      var _this6 = this;

      var campers = this.checkCampers();
      var renewSubscriptions = this.checkSubscriptions();

      var ids = [].concat((0, _toConsumableArray3.default)(campers), (0, _toConsumableArray3.default)(renewSubscriptions));

      if (ids.length) {
        this.webex.internal.presence.subscribe(ids).then(function (body) {
          var now = new Date().getTime();

          body.responses.forEach(function (response) {
            if (response.responseCode === 200) {
              var ttl = response.subscriptionTtl * 1000;

              _this6.subscribers[response.subject] = now + ttl;
              _this6.presences[response.status.subject] = now;
            } else {
              // If it errored for any reason, set the ttl so we clean it out eventually
              _this6.subscribers[response.subject] = now + _constants.DEFAULT_SUBSCRIPTION_TTL;
            }
          });
        });
      }

      this.cleanPresences();
    }
  }]);
  return PresenceWorker;
}();

exports.default = PresenceWorker;
//# sourceMappingURL=presence-worker.js.map
