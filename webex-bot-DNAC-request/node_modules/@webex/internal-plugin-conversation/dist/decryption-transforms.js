'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transforms = undefined;

var _isInteger = require('babel-runtime/core-js/number/is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _curry2 = require('lodash/curry');

var _curry3 = _interopRequireDefault(_curry2);

var _capitalize2 = require('lodash/capitalize');

var _capitalize3 = _interopRequireDefault(_capitalize2);

var _camelCase2 = require('lodash/camelCase');

var _camelCase3 = _interopRequireDefault(_camelCase2);

var _toArray = require('./to-array');

var _toArray2 = _interopRequireDefault(_toArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var decryptTextProp = (0, _curry3.default)(function (name, ctx, key, object) {
  return ctx.transform('decryptTextProp', name, key, object);
});

// eslint-disable-next-line import/prefer-default-export
/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var transforms = exports.transforms = (0, _toArray2.default)('inbound', {

  /**
   * This function is used recursively to decrypt various properties on convesations, activities, etc
   * @param   {Object} ctx    An object containg a webex instance and a transform
   * @param   {String} key    KMS encryption key url
   * @param   {Object} object Generic object that you want to decrypt some property on based on the type
   * @returns {Promise}       Returns a transform promise
   */
  decryptObject: function decryptObject(ctx, key, object) {
    if (!object) {
      object = key; // eslint-disable-line no-param-reassign
      key = undefined; // eslint-disable-line no-param-reassign
    }

    if (!object) {
      return _promise2.default.resolve();
    }

    if (!object.objectType) {
      return _promise2.default.resolve();
    }

    if (!key && object.encryptionKeyUrl) {
      key = object.encryptionKeyUrl; // eslint-disable-line no-param-reassign
    }

    // Transcoded content was not showing up on the activities since the
    // decryptFile was not being called. Calling decryptFile for
    // transcodedContent fixes the issue.
    if (object.objectType === 'transcodedContent') {
      return _promise2.default.all(object.files.items.map(function (item) {
        return ctx.transform('decryptFile', key, item);
      }));
    }

    return ctx.transform('decrypt' + (0, _capitalize3.default)(object.objectType), key, object);
  },


  /**
   * Decrypt an individual submit object from a cardAction activity
   *   (object.objectType === 'sumbit')
   * @param   {Object} ctx      An object containg a webex instance and a transform
   * @param   {String} key      KMS key
   * @param   {Object} object An instance of a Webex Teams submit object
   * these objects are returned when a user clicks on a Action.Submit button in a card
   * @returns {Promise}         Returns a ctx.transform promise
   */
  decryptSubmit: function decryptSubmit(ctx, key, object) {
    if (!object.inputs) {
      return _promise2.default.resolve();
    }
    var decryptionFailureMessage = ctx.webex.internal.conversation.config.decryptionFailureMessage;


    return ctx.transform('decryptPropCardItem', 0, key, [object.inputs]).then(function (inputs) {
      object.inputs = JSON.parse(inputs[0]); // eslint-disable-line no-param-reassign
    }).catch(function (reason) {
      ctx.webex.logger.warn('plugin-conversation: failed to decrypt attachmentAction.inputs: ' + reason);
      object.inputs = decryptionFailureMessage; // eslint-disable-line no-param-reassign

      return _promise2.default.resolve(decryptionFailureMessage);
    });
  },


  /**
   * Decrypt an individual reaction2Summary activity (object.objectType === 'reaction2Summary')
   * @param   {Object} ctx      An object containg a webex instance and a transform
   * @param   {String} key      KMS key
   * @param   {Object} object An instance of a Webex Teams reaction2Summary object
   * these objects are returned by various conversation APIs and over mercury
   * represents an aggregated summary of all reactions to a specific activity
   * @returns {Promise}         Returns a ctx.transform promise
   */
  decryptReaction2summary: function decryptReaction2summary(ctx, key, object) {
    if (!object.reactions) {
      return _promise2.default.resolve();
    }

    return _promise2.default.all(object.reactions.map(function (reaction) {
      return ctx.transform('decryptPropDisplayName', key, reaction);
    }));
  },


  /**
   * Decrypt an individual reaction2SelfSummary activity (object.objectType === 'reaction2SelfSummary')
   * @param   {Object} ctx      An object containg a webex instance and a transform
   * @param   {String} key      KMS key
   * @param   {Object} object An instance of a Webex Teams reaction2SelfSummary object
   * these objects are returned by various conversation APIs and NOT over mercury
   * they are ONLY received by the self user
   * they represent ONLY the self user's reactions and are used for enforcing
   * limit of times they can react to a specific activity
   * @returns {Promise}         Returns a ctx.transform promise
   */
  decryptReaction2selfsummary: function decryptReaction2selfsummary(ctx, key, object) {
    if (!object.reactions) {
      return _promise2.default.resolve();
    }

    return _promise2.default.all(object.reactions.map(function (reaction) {
      return ctx.transform('decryptPropDisplayName', key, reaction);
    }));
  },


  /**
   * Decrypt an individual reaction2 activity (object.objectType === 'reaction2')
   * @param   {Object} ctx      An object containg a webex instance and a transform
   * @param   {String} key      KMS key
   * @param   {Object} object An instance of a Webex Teams reaction2 object
   * these objects are returned by various conversation APIs and over mercury
   * ONLY self users receive these objects
   * @returns {Promise}         Returns a ctx.transform promise
   */
  decryptReaction2: function decryptReaction2(ctx, key, object) {
    return ctx.transform('decryptPropDisplayName', key, object);
  },


  /**
   * Decrypts a given conversation and it's activites by building an array of promises that call
   * decryptObject, which may then call other decrypt functions
   *
   * @param   {Object} ctx          An object containg a webex instance and a transform
   * @param   {String} key          KMS encryption key url (or actual key?)
   * @param   {Object} conversation A Webex Teams conversation object
   * @returns {Promise}             Returns the result of Promise.all
   */
  decryptConversation: function decryptConversation(ctx, key, conversation) {
    var promises = [];

    if (conversation.activities.items) {
      promises.push(_promise2.default.all(conversation.activities.items.map(function (item) {
        return ctx.transform('decryptObject', null, item);
      })));
    }

    var usableKey = conversation.encryptionKeyUrl || key;
    var decryptionFailureMessage = ctx.webex.internal.conversation.config.decryptionFailureMessage;


    if (usableKey) {
      promises.push(ctx.transform('decryptPropDisplayName', usableKey, conversation).catch(function (error) {
        ctx.webex.logger.warn('plugin-conversation: failed to decrypt display name of ', conversation.url, error);
        _promise2.default.resolve(decryptionFailureMessage);
      }));
      promises.push(ctx.transform('decryptPropContent', usableKey, conversation));
    }
    if (conversation.avatarEncryptionKeyUrl) {
      promises.push(ctx.transform('decryptObject', conversation.avatarEncryptionKeyUrl, conversation.avatar));
    }
    if (conversation.previous) {
      promises.push(ctx.transform('decryptPropDisplayName', usableKey, conversation.previous));
    }

    return _promise2.default.all(promises);
  },


  /**
   * Decrypt an individual activity
   * @param   {Object} ctx      An object containg a webex instance and a transform
   * @param   {String} key      KMS encryption key url (or actual key?)
   * @param   {Object} activity An instance of a Webex Teams activity
   * @returns {Promise}         Returns a ctx.transform promise
   */
  decryptActivity: function decryptActivity(ctx, key, activity) {
    if (!activity.encryptionKeyUrl && !(activity.object && activity.object.encryptionKeyUrl)) {
      return _promise2.default.resolve(activity);
    }

    var keyUrl = activity.encryptionKeyUrl || activity.object.encryptionKeyUrl || key;

    var promises = [];

    // iterate and recursively decrypt over children objects
    if (activity.children && Array.isArray(activity.children)) {
      promises = activity.children.map(function (child) {
        return ctx.transform('decryptObject', keyUrl, child.activity);
      });
    }

    promises.push(ctx.transform('decryptObject', keyUrl, activity.object));

    return _promise2.default.all(promises);
  },


  /**
   * Decrypts a microappInstance (recording) model
   * @param   {Object} ctx                     An object containing a webex instance and transform prop
   * @param   {String} key                     KMS key
   * @param   {Object} microappInstance        A microappInstance which includes several properties of a recording
   * @param   {String} microappInstance.model  An encrypted string which decrypts to an object
   * @returns {Promise}                        Returns a contex transform
   */
  decryptMicroappinstance: function decryptMicroappinstance(ctx, key, microappInstance) {
    return ctx.transform('decryptPropModel', key, microappInstance);
  },


  /**
  * Decrypts a comment...
  * @param {Object} ctx An object containing a webex instance and transform prop
  * @param {String} key KMS key
  * @param {Object} comment A comment object with a displayName and content (encrypted)
  * @returns {Promise} Returns the results of Promise.all on two transforms
  */
  decryptComment: function decryptComment(ctx, key, comment) {
    var promises = [ctx.transform('decryptPropDisplayName', key, comment), ctx.transform('decryptPropContent', key, comment)];

    if (comment.cards && Array.isArray(comment.cards)) {
      comment.cards.map(function (item, index) {
        return promises.push(ctx.transform('decryptPropCardItem', index, key, comment.cards));
      });
    }

    return _promise2.default.all(promises);
  },


  /**
   * Decrypts a content field
   * @param   {Object} ctx            An object containing a webex instance and transform prop
   * @param   {String} key            KMS key
   * @param   {Object} content        An object with properties to be decrypted
   * @returns {Promise}               A promise that will return when the decryption has finished
   */
  decryptContent: function decryptContent(ctx, key, content) {
    if (content.contentCategory === 'links') {
      return ctx.transform('decryptContentLinks', key, content);
    }

    return ctx.transform('decryptContentFiles', key, content);
  },


  /**
   * Decrypts a content field which contains files and possibly links
   * @param   {Object} ctx            An object containing a webex instance and transform prop
   * @param   {String} key            KMS key
   * @param   {Object} content        An object with properties to be decrypted
   * @param   {Array}  content.files  An array of files to decrypt by calling decryptObject
   * @param   {Array}  content.links  An array of links to decrypt by calling decryptObject
   * @returns {Promise}               A promise that will return when the decryption has finished
   */
  decryptContentFiles: function decryptContentFiles(ctx, key, content) {
    if (!content.files || !content.files.items || !Array.isArray(content.files.items)) {
      return _promise2.default.resolve();
    }

    var promises = content.files.items.map(function (item) {
      return ctx.transform('decryptObject', key, item);
    });

    promises.push(ctx.transform('decryptComment', key, content));

    if (content.links && content.links.items && Array.isArray(content.links.items)) {
      content.links.items.forEach(function (item) {
        return promises.push(ctx.transform('decryptObject', key, item));
      });
    }

    return _promise2.default.all(promises);
  },


  /**
   * Decrypts a content field which contains links
   * @param   {Object} ctx            An object containing a webex instance and transform prop
   * @param   {String} key            KMS key
   * @param   {Object} content        An object with properties to be decrypted
   * @param   {Array}  content.links  An array of links to decrypt by calling decryptObject
   * @returns {Promise}               A promise that will return when the decryption has finished
   */
  decryptContentLinks: function decryptContentLinks(ctx, key, content) {
    if (!content.links || !content.links.items || !Array.isArray(content.links.items)) {
      return _promise2.default.resolve();
    }

    var promises = content.links.items.map(function (item) {
      return ctx.transform('decryptObject', key, item);
    });

    promises.push(ctx.transform('decryptComment', key, content));

    return _promise2.default.all(promises);
  },


  /**
   * Decrypts what may be a meeting event?
   * @param   {Object} ctx   An object containing a webex instance and transform prop
   * @param   {String} key   KMS key
   * @param   {Object} event An object with a display name and location to be decrypted
   * @returns {Promise}      Returns the result of Promise.all
   */
  decryptEvent: function decryptEvent(ctx, key, event) {
    var promises = [ctx.transform('decryptPropDisplayName', key, event)];

    if (event.location && event.location.split('.').length === 5) {
      promises.push(ctx.transform('decryptPropLocation', key, event));
    }

    return _promise2.default.all(promises);
  },


  /**
   * Decrypts a file and it's transcodedContents if they exist
   * @param   {Object} ctx  An object containing a webex instance and transform prop
   * @param   {String} key  KMS key
   * @param   {Object} file A file object with file props an optional transcodedCollection to decrypt
   * @returns {Promise}     Returns the result of Promise.all
   */
  decryptFile: function decryptFile(ctx, key, file) {
    return _promise2.default.all([file.transcodedCollection && _promise2.default.all(file.transcodedCollection.items.map(function (item) {
      return ctx.transform('decryptObject', key, item);
    })), ctx.transform('decryptPropScr', key, file), ctx.transform('decryptPropDisplayName', key, file), ctx.transform('decryptPropContent', key, file), file.image && ctx.transform('decryptPropScr', key, file.image)]);
  },


  /**
   * Decrypts a file and it's transcodedContents if they exist
   * @param   {Object} ctx  An object containing a webex instance and transform prop
   * @param   {String} key  KMS key
   * @param   {Object} link A link object with a URL to decrypt
   * @returns {Promise}     Returns the result of Promise.all
   */
  decryptLink: function decryptLink(ctx, key, link) {
    return _promise2.default.all([ctx.transform('decryptPropSslr', key, link), ctx.transform('decryptPropDisplayName', key, link)]);
  },


  /**
   * Decrypts transcoded file content. Calls decryptFile
   * @param   {Object} ctx               An object containing a webex instance and transform prop
   * @param   {String} key               KMS key
   * @param   {Object} transcodedContent Transcoded content with a files prop
   * @returns {Promise}                  Returns the result of Promise.all
   */
  decryptTranscodedContent: function decryptTranscodedContent(ctx, key, transcodedContent) {
    return _promise2.default.all(transcodedContent.files.items.map(function (item) {
      return ctx.transform('decryptFile', key, item);
    }));
  },


  /**
   * Decrypts an image uri
   * @param   {Object} ctx       An object containing a webex instance and transform prop
   * @param   {String} key       KMS key
   * @param   {String} imageURI  URI of the image to decrypt
   * @returns {Promise}          Returns a promise.
   */
  decryptImageURI: function decryptImageURI(ctx, key, imageURI) {
    return ctx.transform('decryptPropLocation', key, imageURI);
  },


  /**
   * The heart of most decryption logic ends here. Decrypting text.
   * @param   {Object} ctx    An object containing a webex instance and transform prop
   * @param   {String} name   Property of an object to be decrypted
   * @param   {String} key    KMS key
   * @param   {Object} object A generic object with text props to be decrypted
   * @returns {Promise}       Returns a lonely Promise
   */
  decryptTextProp: function decryptTextProp(ctx, name, key, object) {
    if (!object[name]) {
      return _promise2.default.resolve();
    }
    var decryptionFailureMessage = ctx.webex.internal.conversation.config.decryptionFailureMessage;


    return ctx.webex.internal.encryption.decryptText(key, object[name]).then(function (plaintext) {
      if (ctx.webex.config.conversation.keepEncryptedProperties) {
        var encryptedPropName = (0, _camelCase3.default)('encrypted_' + name);

        object[encryptedPropName] = object[name]; // eslint-disable-line no-param-reassign
      }

      object[name] = plaintext; // eslint-disable-line no-param-reassign
    }).catch(function (reason) {
      ctx.webex.logger.warn('plugin-conversation: failed to decrypt ' + name + ' ', reason);
      object[name] = decryptionFailureMessage; // eslint-disable-line no-param-reassign

      return _promise2.default.resolve(decryptionFailureMessage);
    });
  },


  /**
  * Decrypting an element in an Array.
  * @param {Object} ctx An object containing a webex instance and transform prop
  * @param {Integer} index Property of an object to be decrypted
  * @param {String} key KMS key
  * @param {Array} array An array of Strings to be decrypted
  * @returns {Promise} Returns a lonely Promise
  */
  decryptPropCardItem: function decryptPropCardItem(ctx, index, key, array) {
    if (!(0, _isInteger2.default)(index) || !array || !Array.isArray(array) || index < 0 || index >= array.length || !(array[index] instanceof String || typeof array[index] === 'string')) {
      return _promise2.default.resolve();
    }
    var decryptionFailureMessage = ctx.webex.internal.conversation.config.decryptionFailureMessage;


    return ctx.webex.internal.encryption.decryptText(key, array[index]).then(function (plaintext) {
      array[index] = plaintext; // eslint-disable-line no-param-reassign
    }).catch(function (reason) {
      ctx.webex.logger.warn('plugin-conversation: failed to decrypt card at ' + index + ' ', reason);
      array[index] = decryptionFailureMessage; // eslint-disable-line no-param-reassign

      return _promise2.default.resolve(decryptionFailureMessage);
    });
  },

  /**
   * Decrypts the src of an object (for images?)
   * @param   {Object} ctx    An object containing a webex instance and transform prop
   * @param   {String} key    KMS key
   * @param   {Object} object An object with a scr property to be decrypted
   * @returns {Promise}       Returns a promise
   */
  decryptPropScr: function decryptPropScr(ctx, key, object) {
    return ctx.webex.internal.encryption.decryptScr(key, object.scr).then(function (scr) {
      object.scr = scr; // eslint-disable-line no-param-reassign
    });
  },


  /**
   * Decrypts the sslr object
   * @param   {Object} ctx    An object containing a webex instance and transform prop
   * @param   {String} key    KMS key
   * @param   {Object} object An object with a sslr property to be decrypted
   * @returns {Promise}       Returns a promise
   */
  decryptPropSslr: function decryptPropSslr(ctx, key, object) {
    return ctx.webex.internal.encryption.decryptScr(key, object.sslr).then(function (sslr) {
      object.sslr = sslr; // eslint-disable-line no-param-reassign
    });
  },


  decryptPropDisplayName: decryptTextProp('displayName'),

  decryptPropContent: decryptTextProp('content'),

  decryptPropModel: decryptTextProp('model'),

  decryptPropLocation: decryptTextProp('location')
});
//# sourceMappingURL=decryption-transforms.js.map
