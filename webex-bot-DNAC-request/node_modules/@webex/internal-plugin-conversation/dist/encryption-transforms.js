'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transforms = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _curry2 = require('lodash/curry');

var _curry3 = _interopRequireDefault(_curry2);

var _capitalize2 = require('lodash/capitalize');

var _capitalize3 = _interopRequireDefault(_capitalize2);

var _toArray = require('./to-array');

var _toArray2 = _interopRequireDefault(_toArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KEY = (0, _symbol2.default)('KEY'); /*!
                                         * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
                                         */

var encryptTextProp = (0, _curry3.default)(function (name, ctx, key, object) {
  return ctx.transform('encryptTextProp', name, key, object);
});

var encryptJsonProp = (0, _curry3.default)(function (name, ctx, key, object) {
  return ctx.transform('encryptJsonProp', name, key, object);
});

// eslint-disable-next-line import/prefer-default-export
var transforms = exports.transforms = (0, _toArray2.default)('outbound', {
  encryptObject: function encryptObject(ctx, key, object) {
    if (!object) {
      object = key;
      key = undefined;
    }

    if (!object) {
      return _promise2.default.resolve();
    }

    if (!object.objectType) {
      return _promise2.default.resolve();
    }

    if (key === false) {
      return _promise2.default.resolve();
    }

    return ctx.transform('encrypt' + (0, _capitalize3.default)(object.objectType), key, object);
  },
  encryptConversation: function encryptConversation(ctx, key, conversation) {
    if (key === false) {
      return _promise2.default.resolve();
    }

    return _promise2.default.resolve(key || ctx.webex.internal.encryption.kms.createUnboundKeys({ count: 1 })).then(function (keys) {
      var k = (0, _isArray3.default)(keys) ? keys[0] : keys;

      if ((0, _has3.default)(conversation, 'kmsMessage.keyUris') && !conversation.kmsMessage.keyUris.includes(k.uri)) {
        conversation.kmsMessage.keyUris.push(k.uri);
      }

      return _promise2.default.all([
      // too many implicit returns on the same line is difficult to interpret
      // eslint-disable-next-line arrow-body-style
      (0, _has3.default)(conversation, 'activities.items') && conversation.activities.items.reduce(function (p, activity) {
        // eslint-disable-next-line max-nested-callbacks
        return p.then(function () {
          return ctx.transform('encryptObject', k, activity);
        });
      }, _promise2.default.resolve()), ctx.transform('encryptPropDisplayName', k, conversation)]).then(function () {
        conversation.encryptionKeyUrl = k.uri || k;
        // we only want to set the defaultActivityEncryptionKeyUrl if we've
        // bound a new key
        if (!key) {
          conversation.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl || k.uri || k;
        }
      });
    });
  },
  encryptActivity: function encryptActivity(ctx, key, activity) {
    // Activity is already encrypted
    if (activity.encryptionKeyUrl) {
      return _promise2.default.resolve();
    }

    return ctx.transform('encrypt' + (0, _capitalize3.default)(activity.verb) + 'Activity', key, activity).then(function () {
      key = key || activity[KEY];

      return ctx.transform('prepareActivityKmsMessage', key, activity);
    });
  },
  encryptVerbActivity: function encryptVerbActivity(ctx, key, activity) {
    return ctx.transform('maybeEncryptTarget', key, activity).then(function () {
      key = key || activity[KEY];
    }).then(function () {
      return ctx.transform('encryptObject', key, activity.object);
    });
  },
  maybeEncryptTarget: function maybeEncryptTarget(ctx, key, activity) {
    // This isn't quite right; if we just go by key, we have no guarantee that
    // we have a proper KRO available for add activities
    if (key) {
      return _promise2.default.resolve();
    }

    if ((0, _has3.default)(activity, 'target.defaultActivityEncryptionKeyUrl') && activity.target.defaultActivityEncryptionKeyUrl && (0, _has3.default)(activity, 'target.kmsResourceObjectUrl')) {
      activity[KEY] = key || activity.target.defaultActivityEncryptionKeyUrl;

      return _promise2.default.resolve();
    }

    var conversationUrl = activity.target && activity.target.url;

    if (!conversationUrl) {
      return _promise2.default.reject(new Error('Cannot determine encryption key for activity\'s conversation; no key url or conversation url provided'));
    }

    return ctx.webex.internal.conversation.get({ url: conversationUrl }).then(function (conversation) {
      if (!conversation.defaultActivityEncryptionKeyUrl) {
        return ctx.webex.internal.conversation.updateKey(conversation).then(function (updateKeyActivity) {
          if (updateKeyActivity.kmsMessage.resource) {
            activity.target.kmsResourceObjectUrl = updateKeyActivity.kmsMessage.resource.uri;
          }
          activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = updateKeyActivity.object.defaultActivityEncryptionKeyUrl;
        });
      }

      if (!activity.target.defaultActivityEncryptionKeyUrl) {
        ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its defaultActivityEncryptionKeyUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');
      }

      if (!activity.target.kmsResourceObjectUrl) {
        ctx.webex.logger.warn('plugin-conversation: downloaded conversation to determine its kmsResourceObjectUrl; make sure to pass all encryption related properties when calling Webex.conversation methods.');
      }

      activity[KEY] = activity.target.defaultActivityEncryptionKeyUrl = conversation.defaultActivityEncryptionKeyUrl;
      activity.target.kmsResourceObjectUrl = conversation.kmsResourceObjectUrl;

      return _promise2.default.resolve();
    });
  },
  prepareActivityKmsMessage: function prepareActivityKmsMessage(ctx, key, activity) {
    if (activity.kmsMessage) {
      if (!key && activity.verb === 'updateKey' && (0, _has3.default)(activity, 'object.defaultActivityEncryptionKeyUrl')) {
        key = (0, _get3.default)(activity, 'object.defaultActivityEncryptionKeyUrl');
      }

      if (!key && activity.verb === 'leave' && (0, _has3.default)(activity, 'target.defaultActivityEncryptionKeyUrl')) {
        key = (0, _get3.default)(activity, 'target.defaultActivityEncryptionKeyUrl');
      }

      if (key) {
        var kro = activity.target.kmsResourceObjectUrl;

        ['uri', 'resourceUri'].forEach(function (k) {
          if (activity.kmsMessage[k] && !kro && activity.kmsMessage[k].includes('<KRO>')) {
            throw new Error('encrypter: cannot determine kro');
          }

          if (activity.kmsMessage[k]) {
            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KRO>', kro);
            // key may be a key or a key url
            activity.kmsMessage[k] = activity.kmsMessage[k].replace('<KEYURL>', key.keyUrl || key);
          }
        });
      }
      // If we made it this far and still don't have an encryption key, assume
      // this is a conversation that is not encrypted and we're performing an
      // action that should not encrypt it (e.g. `leave`)
      else {
          (0, _deleteProperty2.default)(activity, 'kmsMessage');
        }
    }
  },


  encryptVerbActivityWithKey: {
    direction: 'outbound',
    fn: function fn(ctx, key, activity) {
      return ctx.transform('encryptVerbActivity', key, activity).then(function () {
        key = key || activity[KEY];
        activity.encryptionKeyUrl = key.uri || key;
      });
    }
  },

  encryptAddActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivity'
  },

  encryptAssignActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivityWithKey'
  },

  encryptCreateActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivity'
  },

  encryptPostActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivityWithKey'
  },

  encryptShareActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivityWithKey'
  },

  encryptCardactionActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivityWithKey'
  },

  encryptUpdateActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivityWithKey'
  },

  encryptUpdateKeyActivity: {
    direction: 'outbound',
    alias: 'encryptVerbActivity'
  },

  encryptComment: function encryptComment(ctx, key, comment) {
    return _promise2.default.all([ctx.transform('encryptPropDisplayName', key, comment), ctx.transform('encryptPropContent', key, comment)]);
  },
  encryptContent: function encryptContent(ctx, key, content) {
    var promises = content.files.items.map(function (item) {
      return ctx.transform('encryptObject', key, item);
    });

    promises.push(ctx.transform('encryptPropContent', key, content));
    promises.push(ctx.transform('encryptPropDisplayName', key, content));

    return _promise2.default.all(promises);
  },
  encryptFile: function encryptFile(ctx, key, file) {
    if (file.image && !file.image.scr) {
      return _promise2.default.reject(new Error('`file.image` must have an `scr`'));
    }

    return _promise2.default.all([ctx.transform('encryptPropScr', key, file), ctx.transform('encryptPropDisplayName', key, file), ctx.transform('encryptPropContent', key, file), file.image && ctx.transform('encryptPropScr', key, file.image)]);
  },
  encryptSubmit: function encryptSubmit(ctx, key, submit) {
    return ctx.transform('encryptPropInputs', key, submit);
  },


  // TODO is this used for anything other than the now-removed stickies service?
  encryptImageURI: function encryptImageURI(ctx, key, imageURI) {
    return ctx.transform('encryptPropLocation', key, imageURI);
  },


  encryptPropContent: encryptTextProp('content'),

  encryptPropDisplayName: encryptTextProp('displayName'),

  encryptPropInputs: encryptJsonProp('inputs'),

  encryptPropLocation: encryptTextProp('location'),

  encryptPropScr: function encryptPropScr(ctx, key, object) {
    if (!object.scr) {
      return _promise2.default.resolve();
    }

    return ctx.webex.internal.encryption.encryptScr(key, object.scr).then(function (scr) {
      object.scr = scr;
    });
  },
  encryptJsonProp: function encryptJsonProp(ctx, name, key, object) {
    if (!object[name]) {
      return _promise2.default.resolve();
    }

    return ctx.webex.internal.encryption.encryptText(key.uri || key, (0, _stringify2.default)(object[name])).then(function (ciphertext) {
      object[name] = ciphertext;
    });
  },
  encryptTextProp: function encryptTextProp(ctx, name, key, object) {
    if (!object[name]) {
      return _promise2.default.resolve();
    }

    return ctx.webex.internal.encryption.encryptText(key.uri || key, object[name]).then(function (ciphertext) {
      object[name] = ciphertext;
    });
  }
});
//# sourceMappingURL=encryption-transforms.js.map
