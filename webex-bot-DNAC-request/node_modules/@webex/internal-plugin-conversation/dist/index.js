'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InvalidUserCreation = exports.ConversationError = exports.ShareActivity = exports.default = undefined;

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _capitalize2 = require('lodash/capitalize');

var _capitalize3 = _interopRequireDefault(_capitalize2);

var _conversation = require('./conversation');

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_conversation).default;
  }
});

var _shareActivity = require('./share-activity');

Object.defineProperty(exports, 'ShareActivity', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_shareActivity).default;
  }
});

var _convoError = require('./convo-error');

Object.defineProperty(exports, 'ConversationError', {
  enumerable: true,
  get: function get() {
    return _convoError.ConversationError;
  }
});
Object.defineProperty(exports, 'InvalidUserCreation', {
  enumerable: true,
  get: function get() {
    return _convoError.InvalidUserCreation;
  }
});

require('@webex/internal-plugin-encryption');

require('@webex/internal-plugin-user');

var _common = require('@webex/common');

var _helperHtml = require('@webex/helper-html');

var _webexCore = require('@webex/webex-core');

var _conversation2 = _interopRequireDefault(_conversation);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _encryptionTransforms = require('./encryption-transforms');

var _decryptionTransforms = require('./decryption-transforms');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _webexCore.registerInternalPlugin)('conversation', _conversation2.default, {
  payloadTransformer: {
    predicates: [{
      name: 'transformObject',
      test: function test(ctx, optionsOrResponse) {
        return _promise2.default.resolve((0, _has3.default)(optionsOrResponse, 'body.objectType'));
      },
      extract: function extract(optionsOrResponse) {
        return _promise2.default.resolve(optionsOrResponse.body);
      }
    }, {
      name: 'transformObject',
      direction: 'inbound',
      test: function test(ctx, event) {
        return _promise2.default.resolve((0, _has3.default)(event, 'activity'));
      },
      extract: function extract(event) {
        return _promise2.default.resolve(event.activity);
      }
    }, {
      name: 'transformObjectArray',
      direction: 'inbound',
      test: function test(ctx, response) {
        return _promise2.default.resolve((0, _has3.default)(response, 'body.multistatus'));
      },
      extract: function extract(response) {
        return _promise2.default.resolve(response.body.multistatus.map(function (item) {
          return item && item.data && item.data.activity;
        }));
      }
    }, {
      name: 'normalizeConversationListAndBindDecrypters',
      direction: 'inbound',
      test: function test(ctx, options) {
        if (!(0, _has3.default)(options, 'body.items[0].objectType')) {
          return _promise2.default.resolve(false);
        }

        if ((0, _get3.default)(options, 'options.deferDecrypt')) {
          return _promise2.default.resolve(true);
        }

        return _promise2.default.resolve(false);
      },
      extract: function extract(options) {
        return _promise2.default.resolve(options.body.items);
      }
    }, {
      name: 'transformObjectArray',
      direction: 'inbound',
      test: function test(ctx, options) {
        if (!(0, _has3.default)(options, 'body.items[0].objectType')) {
          return _promise2.default.resolve(false);
        }

        if ((0, _get3.default)(options, 'options.deferDecrypt')) {
          return _promise2.default.resolve(false);
        }

        return _promise2.default.resolve(true);
      },
      extract: function extract(options) {
        return _promise2.default.resolve(options.body.items);
      }
    }],
    transforms: [{
      name: 'normalizeConversationListAndBindDecrypters',
      fn: function fn(ctx, array) {
        return _promise2.default.all(array.map(function (item) {
          return ctx.transform('normalizeObject', item).then(function () {
            item.decrypt = function decrypt() {
              (0, _deleteProperty2.default)(item, 'decrypt');

              return ctx.transform('decryptObject', item);
            };

            return item;
          });
        }));
      }
    }, {
      name: 'transformObjectArray',
      fn: function fn(ctx, array) {
        return _promise2.default.all(array.map(function (item) {
          return ctx.transform('transformObject', item);
        }));
      }
    }, {
      name: 'transformObject',
      direction: 'outbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise2.default.resolve();
        }

        if (!object.objectType) {
          return _promise2.default.resolve();
        }

        return ctx.transform('normalizeObject', object).then(function () {
          return ctx.transform('encryptObject', object);
        }).then(function () {
          return ctx.transform('encryptKmsMessage', object);
        });
      }
    }, {
      name: 'transformObject',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise2.default.resolve();
        }

        if (!object.objectType) {
          return _promise2.default.resolve();
        }

        return ctx.transform('decryptObject', object).then(function () {
          return ctx.transform('normalizeObject', object);
        });
      }
    }, {
      name: 'normalizeObject',
      fn: function fn(ctx, object) {
        if (!object) {
          return _promise2.default.resolve();
        }

        if (!object.objectType) {
          return _promise2.default.resolve();
        }

        return _promise2.default.all([ctx.transform('normalize' + (0, _capitalize3.default)(object.objectType), object), ctx.transform('normalizePropContent', object)]);
      }
    }, {
      name: 'normalizePropContent',
      direction: 'inbound',
      fn: function fn(ctx, object) {
        if (!object.content) {
          return _promise2.default.resolve();
        }
        var _ctx$webex$config$con = ctx.webex.config.conversation,
            inboundProcessFunc = _ctx$webex$config$con.inboundProcessFunc,
            allowedInboundTags = _ctx$webex$config$con.allowedInboundTags,
            allowedInboundStyles = _ctx$webex$config$con.allowedInboundStyles;


        return (0, _helperHtml.filter)(inboundProcessFunc, allowedInboundTags || {}, allowedInboundStyles, object.content).then(function (c) {
          object.content = c;
        });
      }
    }, {
      name: 'normalizePropContent',
      direction: 'outbound',
      fn: function fn(ctx, object) {
        if (!object.content) {
          return _promise2.default.resolve();
        }

        var _ctx$webex$config$con2 = ctx.webex.config.conversation,
            outboundProcessFunc = _ctx$webex$config$con2.outboundProcessFunc,
            allowedOutboundTags = _ctx$webex$config$con2.allowedOutboundTags,
            allowedOutboundStyles = _ctx$webex$config$con2.allowedOutboundStyles;


        return (0, _helperHtml.filterEscape)(outboundProcessFunc, allowedOutboundTags || {}, allowedOutboundStyles, object.content).then(function (c) {
          object.content = c;
        });
      }
    }, {
      name: 'normalizeConversation',
      fn: function fn(ctx, conversation) {
        conversation.activities = conversation.activities || {};
        conversation.activities.items = conversation.activities.items || [];
        conversation.participants = conversation.participants || {};
        conversation.participants.items = conversation.participants.items || [];

        return _promise2.default.all([_promise2.default.all(conversation.activities.items.map(function (item) {
          return ctx.transform('normalizeObject', item);
        })), _promise2.default.all(conversation.participants.items.map(function (item) {
          return ctx.transform('normalizeObject', item);
        }))]);
      }
    }, {
      name: 'normalizeActivity',
      fn: function fn(ctx, activity) {
        return _promise2.default.all([ctx.transform('normalizeObject', activity.actor), ctx.transform('normalizeObject', activity.object), ctx.transform('normalizeObject', activity.target)]);
      }
    }, {
      name: 'normalizePerson',
      // eslint-disable-next-line complexity
      fn: function fn(ctx, person) {
        var email = person.entryEmail || person.emailAddress || person.id;
        var id = person.entryUUID || person.id;

        if (_common.patterns.email.test(email)) {
          person.entryEmail = person.emailAddress = email.toLowerCase();
        } else {
          (0, _deleteProperty2.default)(person, 'entryEmail');
          (0, _deleteProperty2.default)(person, 'emailAddress');
        }

        if (person.roomProperties) {
          person.roomProperties.isModerator = Boolean(person.roomProperties.isModerator);
        }

        if (_common.patterns.uuid.test(id)) {
          person.entryUUID = person.id = id.toLowerCase();

          return _promise2.default.resolve(person);
        }

        if (!email) {
          return _promise2.default.reject(new Error('cannot determine id without an `emailAddress` or `entryUUID` property'));
        }

        return ctx.webex.internal.user.asUUID(email).then(function (uuid) {
          person.entryUUID = person.id = uuid;

          return person;
        });
      }
    }].concat(_decryptionTransforms.transforms).concat(_encryptionTransforms.transforms)
  },
  config: _config2.default
}); /*!
     * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
     */
//# sourceMappingURL=index.js.map
