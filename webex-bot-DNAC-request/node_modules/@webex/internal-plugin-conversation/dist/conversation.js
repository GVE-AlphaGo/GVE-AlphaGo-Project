'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _map2 = require('babel-runtime/core-js/map');

var _map3 = _interopRequireDefault(_map2);

var _uniq2 = require('lodash/uniq');

var _uniq3 = _interopRequireDefault(_uniq2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

var _map4 = require('lodash/map');

var _map5 = _interopRequireDefault(_map4);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _events = require('events');

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _helperImage = require('@webex/helper-image');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _convoError = require('./convo-error');

var _shareActivity = require('./share-activity');

var _shareActivity2 = _interopRequireDefault(_shareActivity);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var DEFAULT_CLUSTER = process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER || 'urn:TEAM:us-east-2_a:identityLookup';

var idToUrl = new _map3.default();

var getConvoLimit = function getConvoLimit() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var limit = void 0;

  if (options.conversationsLimit) {
    limit = {
      value: options.conversationsLimit,
      name: 'conversationsLimit'
    };
  }

  return limit;
};

var Conversation = _webexCore.WebexPlugin.extend({
  namespace: 'Conversation',

  /**
   * @param {String} cluster the cluster containing the id
   * @param {UUID} [id] the id of the conversation.
   *  If empty, just return the base URL.
   * @returns {String} url of the conversation
   */
  getUrlFromClusterId: function getUrlFromClusterId() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cluster = _ref.cluster,
        cluster = _ref$cluster === undefined ? 'us' : _ref$cluster,
        id = _ref.id;

    var clusterId = cluster === 'us' ? DEFAULT_CLUSTER : cluster;

    var _ref2 = this.webex.internal.services.getServiceFromClusterId({ clusterId: clusterId }) || {},
        url = _ref2.url;

    if (!url) {
      throw Error('Could not find service for cluster [' + cluster + ']');
    }

    return id ? url + '/conversations/' + id : url;
  },


  /**
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  acknowledge: function acknowledge(conversation, object, activity) {
    var _this = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'acknowledge',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'activity',
        id: object.id,
        url: object.url
      }
    }).then(function (a) {
      return _this.submit(a);
    });
  },


  /**
   * Adds a participant to a conversation
   * @param {Object} conversation
   * @param {Object|string} participant
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  add: function add(conversation, participant, activity) {
    var _this2 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    return this.webex.internal.user.asUUID(participant, { create: true }).then(function (id) {
      return _this2.prepare(activity, {
        verb: 'add',
        target: _this2.prepareConversation(convoWithUrl),
        object: {
          id: id,
          objectType: 'person'
        },
        kmsMessage: {
          method: 'create',
          uri: '/authorizations',
          resourceUri: '<KRO>',
          userIds: [id]
        }
      }).then(function (a) {
        return _this2.submit(a);
      });
    });
  },


  /**
   * Creates a conversation
   * @param {Object} params
   * @param {Array<Participant>} params.participants
   * @param {Array<File>} params.files
   * @param {string} params.comment
   * @param {string} params.html
   * @param {Object} params.displayName
   * @param {Object} options
   * @param {Boolean} options.allowPartialCreation
   * @param {Boolean} options.forceGrouped
   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation
   * @returns {Promise<Conversation>}
   */
  create: function create(params) {
    var _this3 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!params.participants || params.participants.length === 0) {
      return _promise2.default.reject(new Error('`params.participants` is required'));
    }

    return _promise2.default.all(params.participants.map(function (participant) {
      return _this3.webex.internal.user.asUUID(participant, { create: true })
      // eslint-disable-next-line arrow-body-style
      .catch(function (err) {
        return options.allowPartialCreation ? undefined : _promise2.default.reject(err);
      });
    })).then(function (participants) {
      participants.unshift(_this3.webex.internal.device.userId);
      participants = (0, _uniq3.default)(participants);

      var validParticipants = participants.filter(function (participant) {
        return participant;
      });

      params.participants = validParticipants;

      // check if original participants list was to create a 1:1
      if (participants.length === 2 && !(options && options.forceGrouped)) {
        if (!params.participants[1]) {
          return _promise2.default.reject(new _convoError.InvalidUserCreation());
        }

        if (options.skipOneOnOneFetch) {
          return _this3._createOneOnOne(params);
        }

        return _this3._maybeCreateOneOnOneThenPost(params, options);
      }

      return _this3._createGrouped(params, options);
    }).then(function (c) {
      idToUrl.set(c.id, c.url);

      if (!params.files) {
        return c;
      }

      return _this3.webex.internal.conversation.share(c, params.files).then(function (a) {
        c.activities.items.push(a);

        return c;
      });
    });
  },


  /**
   * delete content
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  delete: function _delete(conversation, object, activity) {
    var _this4 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'delete',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _pick3.default)(object, 'id', 'url', 'objectType')
    }).then(function (a) {
      return _this4.submit(a);
    });
  },


  /**
   * Downloads the file specified in item.scr or item.url
   * @param {Object} item
   * @param {Object} item.scr
   * @param {string} item.url
   * @param {Object} options
   * @param {Object} options.headers
   * @returns {Promise<File>}
   */
  download: function download(item, options) {
    var _this5 = this;

    var isEncrypted = Boolean(item.scr && item.scr.key);
    var shunt = new _events.EventEmitter();
    var promise = void 0;

    if (isEncrypted) {
      promise = this.webex.internal.encryption.download(item.scr, item.options);
    } else if (item.scr && item.scr.loc) {
      promise = this._downloadUnencryptedFile(item.scr.loc, options);
    } else {
      promise = this._downloadUnencryptedFile(item.url, options);
    }

    promise = promise.on('progress', function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return shunt.emit.apply(shunt, ['progress'].concat(args));
    }).then(function (res) {
      return (0, _helperImage.readExifData)(item, res);
    }).then(function (file) {
      _this5.logger.info('conversation: file downloaded');

      if (item.displayName && !file.name) {
        file.name = item.displayName;
      }

      if (!file.type && item.mimeType) {
        file.type = item.mimeType;
      }

      return file;
    });

    (0, _common.proxyEvents)(shunt, promise);

    return promise;
  },


  /**
   * Downloads an unencrypted file
   * @param {string} uri
   * @param {Object} options
   * @param {Ojbect} options.headers
   * @returns {Promise<File>}
   */
  _downloadUnencryptedFile: function _downloadUnencryptedFile(uri) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    (0, _assign2.default)(options, {
      uri: uri,
      responseType: 'buffer'
    });

    var promise = this.request(options).then(function (res) {
      return res.body;
    });

    (0, _common.proxyEvents)(options.download, promise);

    return promise;
  },


  /**
   * Helper method that expands a set of parameters into an activty object
   * @param {string} verb
   * @param {Object} object
   * @param {Object} target
   * @param {Object|string} actor
   * @returns {Object}
   */
  expand: function expand(verb, object, target, actor) {
    var activity = {
      actor: actor,
      objectType: 'activity',
      verb: verb
    };

    if (!actor) {
      actor = this.webex.internal.device.userId;
    }

    if ((0, _isString3.default)(actor)) {
      activity.actor = {
        objectType: 'person',
        id: actor
      };
    }

    if (object) {
      activity.object = object;
    }

    if (target) {
      activity.target = target;
    }

    return activity;
  },


  /**
  * Gets an array of activities with an array of activity URLS
  * @param {Array} activityUrls
  * @param {String} [cluster] cluster where the activities are located
  * @returns {Promise<Object>} Resolves with the activities
  * TODO: add cluster functionality when clusters are ready
  */
  bulkActivitiesFetch: function bulkActivitiesFetch(activityUrls, cluster) {
    var resource = 'bulk_activities_fetch';
    var params = {
      method: 'POST',
      body: {
        activityUrls: activityUrls
      }
    };

    if (cluster) {
      var uri = this.getUrlFromClusterId({ cluster: cluster }) + '/' + resource;

      (0, _assign2.default)(params, {
        uri: uri
      });
    } else {
      (0, _assign2.default)(params, {
        api: 'conversation',
        resource: resource
      });
    }

    return this.webex.request(params).then(function (res) {
      var activitiesArr = [];

      if (res.body.multistatus) {
        res.body.multistatus.forEach(function (statusData) {
          if (statusData.status === '200' && statusData.data && statusData.data.activity) {
            activitiesArr.push(statusData.data.activity);
          }
        });
      }

      return activitiesArr;
    });
  },


  /**
   * Fetches a single conversation
   * @param {Object} conversation
   * @param {String} [conversation.url] The URL where the conversation is located.
   * @param {String|UUID} [conversation.user] The user to look up in the conversation service
   *   If specified, the user lookup will take precedence over the url lookup
   * @param {Object} options
   * @returns {Promise<Conversation>}
   */
  get: function get(conversation) {
    var _this6 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var user = conversation.user;

    var uri = void 0;

    try {
      uri = !user ? this.getConvoUrl(conversation) : '';
    } catch (err) {
      return _promise2.default.reject(Error(err));
    }

    var params = {
      qs: (0, _assign2.default)({
        uuidEntryFormat: true,
        personRefresh: true,
        activitiesLimit: 0,
        includeConvWithDeletedUserUUID: false,
        includeParticipants: false
      }, (0, _omit3.default)(options, 'id', 'user', 'url'))
    };

    // Default behavior is to set includeParticipants=false,
    // which makes the payload lighter by removing participant info.
    // If the caller explicitly sets the participantAckFilter or
    // participantsLimit, we don't want that default setting.
    if ('participantAckFilter' in options || 'participantsLimit' in options) {
      delete params.qs.includeParticipants;
    }

    return _promise2.default.resolve(user ? this.webex.internal.user.asUUID(user) : null).then(function (userId) {
      if (userId) {
        (0, _assign2.default)(params, {
          service: 'conversation',
          resource: 'conversations/user/' + userId
        });
      } else {
        params.uri = uri;
      }

      return _this6.request(params);
    }).then((0, _common.tap)(function (_ref3) {
      var body = _ref3.body;
      var id = body.id,
          url = body.url;


      _this6._recordUUIDs(body);
      idToUrl.set(id, url);
    })).then(function (res) {
      return res.body;
    });
  },


  /**
   * Leaves the conversation or removes the specified user from the specified
   * conversation
   * @param {Object} conversation
   * @param {Object|string} participant If not specified, defaults to current
   * user
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  leave: function leave(conversation, participant, activity) {
    var _this7 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve().then(function () {
      if (!participant) {
        participant = _this7.webex.internal.device.userId;
      }

      return _this7.webex.internal.user.asUUID(participant).then(function (id) {
        return _this7.prepare(activity, {
          verb: 'leave',
          target: _this7.prepareConversation(convoWithUrl),
          object: {
            id: id,
            objectType: 'person'
          },
          kmsMessage: {
            method: 'delete',
            uri: '<KRO>/authorizations?' + _querystring2.default.stringify({ authId: id })
          }
        });
      });
    }).then(function (a) {
      return _this7.submit(a);
    });
  },


  /**
   * Lists a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @returns {Promise<Array<Conversation>>}
   */
  list: function list(options) {
    return this._list({
      service: 'conversation',
      resource: 'conversations',
      qs: (0, _omit3.default)(options, 'deferDecrypt'),
      deferDecrypt: options.deferDecrypt,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(results), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var convo = _step.value;

          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return results;
    });
  },


  /**
   * Lists the conversations the current user has left. By default does not
   * fetch activities or participants
   * @param {Object} options
   * @returns {Promise<Array<Conversation>>}
   */
  listLeft: function listLeft(options) {
    return this._list({
      service: 'conversation',
      resource: 'conversations/left',
      qs: options,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(results), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var convo = _step2.value;

          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return results;
    });
  },


  /**
   * List activities for the specified conversation
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @returns {Promise<Array<Activity>>}
   */
  listActivities: function listActivities(options) {
    return this._listActivities((0, _assign2.default)(options, { resource: 'activities' }));
  },


  /**
   * Lists activities in which the current user was mentioned
   * @param {Object} options
   * @returns {Promise<Array<Activity>>}
   */
  listMentions: function listMentions(options) {
    return this._list({
      service: 'conversation',
      resource: 'mentions',
      qs: (0, _omit3.default)(options, 'mentions')
    });
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMentions: function muteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMessages: function muteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_OFF']
    }, activity);
  },


  /**
   * @param {Object} conversation
   * @param {Object} inputs
   * @param {Object} parentActivity
   * @param {Object} activity
   * @returns {Promise}
   */
  cardAction: function cardAction(conversation, inputs, parentActivity) {
    var _this8 = this;

    var activity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    activity.parent = {
      id: parentActivity.id,
      type: 'cardAction'
    };

    return this.prepare(activity, {
      verb: 'cardAction',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign2.default)({ objectType: 'submit' }, inputs)
    }).then(function (a) {
      return _this8.submit(a);
    });
  },


  /**
   * Posts a message to a conversation
   * @param {Object} conversation
   * @param {Object|string} message if string, treated as plaintext; if object,
   * assumed to be object property of `post` activity
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  post: function post(conversation, message, activity) {
    var _this9 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    if ((0, _isString3.default)(message)) {
      message = {
        displayName: message
      };
    }

    return this.prepare(activity, {
      verb: 'post',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign2.default)({ objectType: 'comment' }, message)
    }).then(function (a) {
      return _this9.submit(a);
    });
  },
  prepareConversation: function prepareConversation(conversation) {
    return (0, _defaults3.default)((0, _pick3.default)(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {
      objectType: 'conversation'
    });
  },
  prepare: function prepare(activity, params) {
    var _this10 = this;

    params = params || {};
    activity = activity || {};

    return _promise2.default.resolve(activity.prepare ? activity.prepare(params) : activity).then(function (act) {
      (0, _defaults3.default)(act, {
        verb: params.verb,
        kmsMessage: params.kmsMessage,
        objectType: 'activity',
        clientTempId: _uuid2.default.v4(),
        actor: _this10.webex.internal.device.userId
      });

      // Workaround because parent is a reserved props in Ampersand
      if (activity.parentActivityId && activity.activityType || activity.parent && activity.parent.id && activity.parent.type) {
        act.parent = {
          id: activity.parentActivityId || activity.parent.id,
          type: activity.activityType || activity.parent.type
        };
      }

      if ((0, _isString3.default)(act.actor)) {
        act.actor = {
          objectType: 'person',
          id: act.actor
        };
      }

      ['actor', 'object'].forEach(function (key) {
        if (params[key]) {
          act[key] = act[key] || {};
          (0, _defaults3.default)(act[key], params[key]);
        }
      });

      if (params.target) {
        (0, _merge3.default)(act, {
          target: (0, _pick3.default)(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')
        });
      }

      ['object', 'target'].forEach(function (key) {
        if (act[key] && act[key].url && !act[key].id) {
          act[key].id = act[key].url.split('/').pop();
        }
      });

      ['actor', 'object', 'target'].forEach(function (key) {
        if (act[key] && !act[key].objectType) {
          // Reminder: throwing here because it's the only way to get out of
          // this loop in event of an error.
          throw new Error('`act.' + key + '.objectType` must be defined');
        }
      });

      if (act.object && act.object.content && !act.object.displayName) {
        return _promise2.default.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));
      }

      return act;
    });
  },


  /**
   * Handles incoming conversation.activity mercury messages
   * @param {Event} event
   * @returns {Promise}
   */
  processActivityEvent: function processActivityEvent(event) {
    return this.webex.transform('inbound', event).then(function () {
      return event;
    });
  },


  /**
   * Removes all mute-related tags
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  removeAllMuteTags: function removeAllMuteTags(conversation, activity) {
    return this.untag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF', 'MENTION_NOTIFICATIONS_ON', 'MESSAGE_NOTIFICATIONS_OFF', 'MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Creates a ShareActivty for the specified conversation
   * @param {Object} conversation
   * @param {Object} activity
   * @returns {ShareActivty}
   */
  makeShare: function makeShare(conversation, activity) {
    // if we pass activity as null then it does not take care of the
    // clientTempId created by the web-client while making the provisional
    // activity, hence we need to pass the activity which was created by the
    // web-client. This fixes the issue where the image activities do not come
    // back properly oriented from the server since the clientTempId is missing
    return _shareActivity2.default.create(conversation, activity, this.webex);
  },


  /**
   * Assigns an avatar to a room
   * @param {Object} conversation
   * @param {File} avatar
   * @returns {Promise<Activity>}
   */
  assign: function assign(conversation, avatar) {
    var _this11 = this;

    if ((avatar.size || avatar.length) > 1024 * 1024) {
      return _promise2.default.reject(new Error('Room avatars must be less than 1MB'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve().then(function () {
      var activity = _shareActivity2.default.create(conversation, null, _this11.webex);

      activity.enableThumbnails = false;
      activity.add(avatar);

      return _this11.prepare(activity, {
        target: _this11.prepareConversation(convoWithUrl)
      });
    }).then(function (a) {
      // yes, this seems a little hacky; will likely be resolved as a result
      // of #213
      a.verb = 'assign';

      return _this11.submit(a);
    });
  },


  /**
   * Get url from convo object. If there isn't one, get it from the cache
   *
   * @param {String} url The location of the conversation
   * @param {UUID} id If there is no url, fall back to id to lookup in cache or with cluster
   * @param {String} cluster Used with id to lookup url
   * @param {UUID} generalConversationUuid If this is a team, the id of the general conversation
   * @param {Object} conversations If this is a team, the list of conversations in the team
   * @returns {String} url for the specific convo
   */
  getConvoUrl: function getConvoUrl(_ref4) {
    var id = _ref4.id,
        url = _ref4.url,
        cluster = _ref4.cluster,
        conversations = _ref4.conversations,
        generalConversationUuid = _ref4.generalConversationUuid;

    if (generalConversationUuid) {
      // This is a Team
      // Because Convo doesn't have an endpoint for the team URL
      // we have to use the general convo URL.
      var generalConvo = conversations.items.find(function (convo) {
        return convo.id === generalConversationUuid;
      });

      return generalConvo.url;
    }

    if (url) {
      return url;
    }

    if (id) {
      if (cluster) {
        return this.getUrlFromClusterId({ cluster: cluster, id: id });
      }
      this.logger.warn('You should be using the `url` instead of the `id` property');
      var relatedUrl = idToUrl.get(id);

      if (!relatedUrl) {
        throw Error('Could not find the `url` from the given `id`');
      }

      return relatedUrl;
    }

    throw Error('The space needs a `url` property');
  },


  /**
   * Sets the typing status of the current user in a conversation
   *
   * @param {Object} conversation
   * @param {Object} options
   * @param {boolean} options.typing
   * @returns {Promise}
   */
  updateTypingStatus: function updateTypingStatus(conversation, options) {
    if (!conversation.id) {
      if (conversation.url) {
        conversation.id = conversation.url.split('/').pop();
      } else {
        return _promise2.default.reject(new Error('conversation: could not identify conversation'));
      }
    }

    var eventType = void 0;

    if (options.typing) {
      eventType = 'status.start_typing';
    } else {
      eventType = 'status.stop_typing';
    }

    var url = this.getConvoUrl(conversation);
    var resource = 'status/typing';
    var params = {
      method: 'POST',
      body: {
        conversationId: conversation.id,
        eventType: eventType
      },
      url: url + '/' + resource
    };

    return this.request(params);
  },


  /**
   * Shares files to the specified conversation
   * @param {Object} conversation
   * @param {ShareActivity|Array<File>} activity
   * @returns {Promise<Activity>}
   */
  share: function share(conversation, activity) {
    var _this12 = this;

    if ((0, _isArray3.default)(activity)) {
      activity = {
        object: {
          files: activity
        }
      };
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    if (!(activity instanceof _shareActivity2.default)) {
      activity = _shareActivity2.default.create(convoWithUrl, activity, this.webex);
    }

    return this.prepare(activity, {
      target: this.prepareConversation(convoWithUrl)
    }).then(function (a) {
      return _this12.submit(a);
    });
  },


  /**
   * Submits an activity to the conversation service
   * @param {Object} activity
   * @param {String} [endpoint] endpoint to submit activity. If empty, find in activity
   * @returns {Promise<Activity>}
   */
  submit: function submit(activity, endpoint) {
    var url = endpoint || this.getConvoUrl(activity.target);
    var resource = activity.verb === 'share' ? 'content' : 'activities';
    var params = {
      method: 'POST',
      body: activity,
      qs: {
        personRefresh: true
      },
      url: url + '/' + resource
    };

    if (activity.verb === 'share') {
      (0, _assign2.default)(params.qs, {
        transcode: true,
        async: false
      });
    }

    // triggers user-activity to reset logout timer
    this.webex.trigger('user-activity');

    return this.request(params).then(function (res) {
      return res.body;
    });
  },


  /**
   * Remove the avatar from a room
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise}
   */
  unassign: function unassign(conversation, activity) {
    var _this13 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: 'unassign',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'content',
        files: {
          items: []
        }
      }
    }).then(function (a) {
      return _this13.submit(a);
    });
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMentions: function unmuteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMessages: function unmuteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Update an existing activity
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  update: function update(conversation, object, activity) {
    var _this14 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: 'update',
      target: this.prepareConversation(convoWithUrl),
      object: object
    }).then(function (a) {
      return _this14.submit(a);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  updateKey: function updateKey(conversation, key, activity) {
    var _this15 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.get(convoWithUrl, {
      activitiesLimit: 0,
      includeParticipants: true
    }).then(function (c) {
      return _this15._updateKey(c, key, activity);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @private
   * @returns {Promise<Activity>}
   */
  _updateKey: function _updateKey(conversation, key, activity) {
    var _this16 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve(key || this.webex.internal.encryption.kms.createUnboundKeys({ count: 1 })).then(function (keys) {
      var k = (0, _isArray3.default)(keys) ? keys[0] : keys;
      var params = {
        verb: 'updateKey',
        target: _this16.prepareConversation(convoWithUrl),
        object: {
          defaultActivityEncryptionKeyUrl: k.uri,
          objectType: 'conversation'
        }
      };

      // Reminder: the kmsResourceObjectUrl is only usable if there is
      // defaultActivityEncryptionKeyUrl.
      // Valid defaultActivityEncryptionKeyUrl start with 'kms:'
      if (convoWithUrl.kmsResourceObjectUrl && convoWithUrl.kmsResourceObjectUrl.startsWith('kms:')) {
        params.kmsMessage = {
          method: 'update',
          resourceUri: '<KRO>',
          uri: k.uri
        };
      } else {
        params.kmsMessage = {
          method: 'create',
          uri: '/resources',
          userIds: (0, _map5.default)(convoWithUrl.participants.items, 'id'),
          keyUris: [k.uri]
        };
      }

      return _this16.prepare(activity, params).then(function (a) {
        return _this16.submit(a);
      });
    });
  },


  /**
   * @param {Object} payload
   * @param {Object} options
   * @private
   * @returns {Promise<Activity>}
   */
  _create: function _create(payload) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return this.request({
      method: 'POST',
      service: 'conversation',
      resource: 'conversations',
      body: payload,
      qs: {
        forceCreate: options.allowPartialCreation
      }
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createGrouped: function _createGrouped(params, options) {
    return this._create(this._prepareConversationForCreation(params), options);
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createOneOnOne: function _createOneOnOne(params) {
    var payload = this._prepareConversationForCreation(params);

    payload.tags = ['ONE_ON_ONE'];

    return this._create(payload);
  },


  /**
   * Get the current conversation url.
   *
   * @returns {Promise<string>} - conversation url
   */
  getConversationUrl: function getConversationUrl() {
    var _this17 = this;

    this.logger.info('conversation: getting the conversation service url');

    var convoUrl = this.webex.internal.services.get('conversation');

    // Validate if the conversation url exists in the services plugin and
    // resolve with its value.
    if (convoUrl) {
      return _promise2.default.resolve(convoUrl);
    }

    // Wait for the postauth catalog to update and then try to retrieve the
    // conversation service url again.
    return this.webex.internal.waitForCatalog('postauth').then(function () {
      return _this17.webex.internal.services.get('conversation');
    }).catch(function (error) {
      _this17.logger.warn('conversation: unable to get conversation url', error.message);

      return _promise2.default.reject(error);
    });
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _inferConversationUrl: function _inferConversationUrl(conversation) {
    var _this18 = this;

    if (conversation.id) {
      return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
        if (haMessagingEnabled) {
          // recompute conversation URL each time as the host may have changed
          // since last usage
          return _this18.getConversationUrl().then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;

            return conversation;
          });
        }
        if (!conversation.url) {
          return _this18.getConversationUrl().then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;
            /* istanbul ignore else */
            if (process.env.NODE_ENV !== 'production') {
              _this18.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');
            }

            return conversation;
          });
        }

        return _promise2.default.resolve(conversation);
      });
    }

    return _promise2.default.resolve(conversation);
  },


  /**
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @param {String} options.resource The URL resource to hit for a list of objects
   * @private
   * @returns {Promise<Array<Activity>>}
   */
  _listActivities: function _listActivities(options) {
    var id = options.conversationId;
    var url = this.getConvoUrl({ url: options.conversationUrl, id: id });
    var resource = options.resource;


    return this._list({
      qs: (0, _omit3.default)(options, 'resource'),
      url: url + '/' + resource
    });
  },


  /**
   * @param {Object} options
   * @private
   * @returns {Promise<Array<Conversation>>}
   */
  _list: function () {
    var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(options) {
      var _this19 = this;

      var res, list, limit, results, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, result, items;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options.qs = (0, _assign2.default)({
                personRefresh: true,
                uuidEntryFormat: true,
                activitiesLimit: 0,
                participantsLimit: 0
              }, options.qs);

              _context.next = 3;
              return this.request(options);

            case 3:
              res = _context.sent;

              if (!(!res.body || !res.body.items || res.body.items.length === 0)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt('return', []);

            case 6:
              list = res.body.items.slice(0);


              if ((0, _last3.default)(list).published < list[0].published) {
                list.reverse();
              }

              // The user has more data in another cluster.
              // Follow the 'additionalUrls' for that data.

              if (!res.body.additionalUrls) {
                _context.next = 34;
                break;
              }

              limit = 0;

              // If the user asked for a specific amount of data,
              // don't fetch more than what was asked.
              // Here we figure out how much is left from the original request.
              // Divide that by the number of additional URLS.
              // This won't get us the exact limit but it will retrieve something
              // from every cluster listed.

              if (options.limit) {
                limit = Math.floor((options.limit.value - list.length) / res.body.additionalUrls.length);
              }

              // If the limit is 0 for some reason,
              // don't bother requesting from other clusters

              if (!(!options.limit || limit !== 0)) {
                _context.next = 34;
                break;
              }

              _context.next = 14;
              return _promise2.default.all(res.body.additionalUrls.map(function (host) {
                var url = host + '/' + options.resource;
                var newOptions = (0, _assign2.default)({}, options, { uri: url, url: url });

                if (options.limit) {
                  newOptions.qs[newOptions.limit.name] = limit;
                }

                return _this19.request(newOptions);
              }));

            case 14:
              results = _context.sent;
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context.prev = 18;


              for (_iterator3 = (0, _getIterator3.default)(results); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                result = _step3.value;

                if (result.body && result.body.items && result.body.items.length) {
                  items = result.body.items;


                  if ((0, _last3.default)(items).published < items[0].published) {
                    items.reverse();
                  }
                  list = list.concat(items);
                }
              }
              _context.next = 26;
              break;

            case 22:
              _context.prev = 22;
              _context.t0 = _context['catch'](18);
              _didIteratorError3 = true;
              _iteratorError3 = _context.t0;

            case 26:
              _context.prev = 26;
              _context.prev = 27;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 29:
              _context.prev = 29;

              if (!_didIteratorError3) {
                _context.next = 32;
                break;
              }

              throw _iteratorError3;

            case 32:
              return _context.finish(29);

            case 33:
              return _context.finish(26);

            case 34:
              _context.next = 36;
              return _promise2.default.all(list.map(function (item) {
                return _this19._recordUUIDs(item);
              }));

            case 36:
              return _context.abrupt('return', list);

            case 37:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this, [[18, 22, 26, 34], [27,, 29, 33]]);
    }));

    function _list(_x8) {
      return _ref5.apply(this, arguments);
    }

    return _list;
  }(),


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise<Conversation>}
   */
  _maybeCreateOneOnOneThenPost: function _maybeCreateOneOnOneThenPost(params, options) {
    var _this20 = this;

    return this.get((0, _defaults3.default)({
      // the use of uniq in Conversation#create guarantees participant[1] will
      // always be the other user
      user: params.participants[1]
    }), (0, _assign2.default)(options, { includeConvWithDeletedUserUUID: true, includeParticipants: true })).then(function (conversation) {
      if (params.comment || params.html) {
        return _this20.post(conversation, { content: params.html, displayName: params.comment }).then(function (activity) {
          conversation.activities.items.push(activity);

          return conversation;
        });
      }

      return conversation;
    }).catch(function (reason) {
      if (reason.statusCode !== 404) {
        return _promise2.default.reject(reason);
      }

      return _this20._createOneOnOne(params);
    });
  },


  /**
   * @param {Object} params
   * @private
   * @returns {Object}
   */
  _prepareConversationForCreation: function _prepareConversationForCreation(params) {
    var _this21 = this;

    var payload = {
      activities: {
        items: [this.expand('create')]
      },
      objectType: 'conversation',
      kmsMessage: {
        method: 'create',
        uri: '/resources',
        userIds: (0, _cloneDeep3.default)(params.participants),
        keyUris: []
      }
    };

    if (params.displayName) {
      payload.displayName = params.displayName;
    }

    params.participants.forEach(function (participant) {
      payload.activities.items.push(_this21.expand('add', {
        objectType: 'person',
        id: participant
      }));
    });

    if (params.comment) {
      payload.activities.items.push(this.expand('post', {
        objectType: 'comment',
        content: params.html,
        displayName: params.comment
      }));
    }

    return payload;
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _recordUUIDs: function _recordUUIDs(conversation) {
    var _this22 = this;

    if (!conversation.participants || !conversation.participants.items) {
      return _promise2.default.resolve(conversation);
    }

    return _promise2.default.all(conversation.participants.items.map(function (participant) {
      // ROOMs or LYRA_SPACEs do not have email addresses, so there's no point attempting to
      // record their UUIDs.
      if (participant.type === 'ROOM' || participant.type === 'LYRA_SPACE') {
        return _promise2.default.resolve();
      }

      return _this22.webex.internal.user.recordUUID(participant).catch(function (err) {
        return _this22.logger.warn('Could not record uuid', err);
      });
    }));
  },
  version: '1.80.147'
});

['favorite', 'hide', 'lock', 'mute', 'unfavorite', 'unhide', 'unlock', 'unmute'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {
    var _this23 = this;

    var convoWithUrl = this.prepareConversation((0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) }));

    return this.prepare(activity, {
      verb: verb,
      object: convoWithUrl,
      target: convoWithUrl
    }).then(function (a) {
      return _this23.submit(a);
    });
  };
});

['assignModerator', 'unassignModerator'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {
    var _this24 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.all([convoWithUrl, moderator ? this.webex.internal.user.asUUID(moderator) : this.webex.internal.device.userId]).then(function (_ref6) {
      var _ref7 = (0, _slicedToArray3.default)(_ref6, 2),
          c = _ref7[0],
          userId = _ref7[1];

      return _this24.prepare(activity, {
        verb: verb,
        target: _this24.prepareConversation(c),
        object: {
          id: userId,
          objectType: 'person'
        }
      });
    }).then(function (a) {
      return _this24.submit(a);
    });
  };
});

/**
 * Sets/unsets space property for convo
 * @param {Object} conversation
 * @param {string} tag
 * @param {Activity} activity
 * @returns {Promise<Activity>}
 */
['setSpaceProperty', 'unsetSpaceProperty'].forEach(function (fnName) {
  var verb = fnName.startsWith('set') ? 'set' : 'unset';

  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {
    var _this25 = this;

    if (!(0, _isString3.default)(tag)) {
      return _promise2.default.reject(new Error('`tag` must be a string'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: verb,
      target: this.prepareConversation(convoWithUrl),
      object: {
        tags: [tag],
        objectType: 'spaceProperty'
      }
    }).then(function (a) {
      return _this25.submit(a);
    });
  };
});

['tag', 'untag'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {
    var _this26 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    var c = this.prepareConversation((0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) }));

    return this.prepare(activity, {
      verb: verb,
      target: c,
      object: (0, _assign2.default)(c, object)
    }).then(function (a) {
      return _this26.submit(a);
    });
  };
});

exports.default = Conversation;
//# sourceMappingURL=conversation.js.map
