'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FILE_SYMBOL = exports.EMITTER_SYMBOL = undefined;

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _map2 = require('babel-runtime/core-js/map');

var _map3 = _interopRequireDefault(_map2);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _some2 = require('lodash/some');

var _some3 = _interopRequireDefault(_some2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _map4 = require('lodash/map');

var _map5 = _interopRequireDefault(_map4);

var _filter2 = require('lodash/filter');

var _filter3 = _interopRequireDefault(_filter2);

var _events = require('events');

var _nodeScr = require('node-scr');

var _nodeScr2 = _interopRequireDefault(_nodeScr);

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _helperImage = require('@webex/helper-image');

var _sha = require('crypto-js/sha256');

var _sha2 = _interopRequireDefault(_sha);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var EMITTER_SYMBOL = exports.EMITTER_SYMBOL = (0, _symbol2.default)('EMITTER_SYMBOL');
var FILE_SYMBOL = exports.FILE_SYMBOL = (0, _symbol2.default)('FILE_SYMBOL');
var PROMISE_SYMBOL = (0, _symbol2.default)('PROMISE_SYMBOL');

/**
 * @class
 */
var ShareActivity = _webexCore.WebexPlugin.extend({
  getSymbols: function getSymbols() {
    return {
      file: FILE_SYMBOL,
      emitter: EMITTER_SYMBOL
    };
  },


  namespace: 'Conversation',

  derived: {
    target: {
      deps: ['conversation'],
      fn: function fn() {
        return this.conversation;
      }
    }
  },

  session: {
    conversation: {
      required: true,
      type: 'object'
    },

    content: 'string',

    clientTempId: 'string',

    displayName: 'string',

    enableThumbnails: {
      default: true,
      type: 'boolean'
    },

    hiddenSpaceUrl: 'object',

    mentions: 'object',

    spaceUrl: 'object',

    uploads: {
      type: 'object',
      default: function _default() {
        return new _map3.default();
      }
    }
  },

  initialize: function initialize(attrs, options) {
    (0, _apply2.default)(_webexCore.WebexPlugin.prototype.initialize, this, [attrs, options]);

    if (attrs && attrs.conversation) {
      this.spaceUrl = _promise2.default.resolve(attrs.conversation._spaceUrl || this._retrieveSpaceUrl(attrs.conversation.url + '/space').then(function (url) {
        attrs.conversation._spaceUrl = url;

        return url;
      }));

      this.hiddenSpaceUrl = _promise2.default.resolve(attrs.conversation._hiddenSpaceUrl || this._retrieveSpaceUrl(attrs.conversation.url + '/space/hidden').then(function (url) {
        attrs.conversation._hiddenSpaceUrl = url;

        return url;
      }));
    }
  },


  /**
   * Adds an additional GIF to the share activity
   * Different from regular add to skip uploading to webex files service
   * @param {File} gif
   * @param {Object} options
   * @param {Object} options.actions
   * @returns {Promise}
   */
  addGif: function addGif(gif, options) {
    var _this = this;

    var gifToAdd = this.uploads.get(gif);

    // If the gif already exists, then don't do anything
    if (gifToAdd) {
      return _promise2.default.resolve();
    }

    gifToAdd = (0, _assign2.default)((0, _defineProperty3.default)({
      displayName: gif.name,
      fileSize: gif.size || gif.byteLength || gif.length,
      mimeType: gif.type,
      url: 'https://giphy.com',
      objectType: 'file'
    }, FILE_SYMBOL, gif), (0, _pick3.default)(options, 'actions'));

    this.uploads.set(gif, gifToAdd);

    /* Instead of encryptBinary, which produces a encrypted version of
     * the file for upload and a SCR (contains info needed to encrypt the
     * SCR itself and the displayName), we directly create an SCR.
     * Because we are skipping uploading, the encrypted file is not needed.
     */
    return _nodeScr2.default.create().then(function (scr) {
      scr.loc = gif.giphyURL;
      gifToAdd.scr = scr;

      return _promise2.default.resolve((0, _helperImage.processImage)({
        file: gif,
        type: gif.type,
        thumbnailMaxWidth: _this.config.thumbnailMaxWidth,
        thumbnailMaxHeight: _this.config.thumbnailMaxHeight,
        enableThumbnails: _this.enableThumbnails,
        logger: _this.logger
      }));
    }).then(function (imageData) {
      if (imageData) {
        /* Similar reasoning to the above comment, but this for the thumbnail
         * which is in the image property of the object.
         */
        return _nodeScr2.default.create().then(function (scr) {
          var _imageData = (0, _slicedToArray3.default)(imageData, 3),
              thumbnail = _imageData[0],
              fileDimensions = _imageData[1],
              thumbnailDimensions = _imageData[2];

          (0, _assign2.default)(gifToAdd, fileDimensions);

          if (thumbnail && thumbnailDimensions) {
            scr.loc = gif.thumbnailURL;
            gifToAdd.image = thumbnailDimensions;
            gifToAdd.image.url = 'https://giphy.com';
            gifToAdd.image.scr = scr;
          }
        });
      }

      // if there isn't any imageData, we just don't have a image field
      return _promise2.default.resolve();
    });
  },


  /**
   * Adds an additional file to the share and begins submitting it to webex
   * files
   * @param {File} file
   * @param {Object} options
   * @param {Object} options.actions
   * @returns {EventEmittingPromise}
   */
  add: function add(file, options) {
    var _Object$assign3,
        _this2 = this;

    options = options || {};
    var upload = this.uploads.get(file);

    if (upload) {
      return upload[PROMISE_SYMBOL];
    }
    var emitter = new _events.EventEmitter();

    upload = (0, _assign2.default)((_Object$assign3 = {
      displayName: file.name,
      fileSize: file.size || file.byteLength || file.length,
      mimeType: file.type,
      objectType: 'file'
    }, (0, _defineProperty3.default)(_Object$assign3, EMITTER_SYMBOL, emitter), (0, _defineProperty3.default)(_Object$assign3, FILE_SYMBOL, file), _Object$assign3), (0, _pick3.default)(options, 'actions'));

    this.uploads.set(file, upload);
    var promise = (0, _helperImage.detectFileType)(file, this.logger).then(function (type) {
      upload.mimeType = type;

      return (0, _helperImage.processImage)({
        file: file,
        type: type,
        thumbnailMaxWidth: _this2.config.thumbnailMaxWidth,
        thumbnailMaxHeight: _this2.config.thumbnailMaxHeight,
        enableThumbnails: _this2.enableThumbnails,
        logger: _this2.logger
      });
    }).then(function (imageData) {
      var main = _this2.webex.internal.encryption.encryptBinary(file).then(function (_ref) {
        var scr = _ref.scr,
            cdata = _ref.cdata;

        upload.scr = scr;

        return _promise2.default.all([cdata, _this2.spaceUrl]);
      }).then(function (_ref2) {
        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
            cdata = _ref3[0],
            spaceUrl = _ref3[1];

        var uploadPromise = _this2._upload(cdata, spaceUrl + '/upload_sessions');

        (0, _common.transferEvents)('progress', uploadPromise, emitter);

        return uploadPromise;
      }).then(function (metadata) {
        upload.url = upload.scr.loc = metadata.downloadUrl;
      });

      var thumb = void 0;

      if (imageData) {
        var _imageData2 = (0, _slicedToArray3.default)(imageData, 3),
            thumbnail = _imageData2[0],
            fileDimensions = _imageData2[1],
            thumbnailDimensions = _imageData2[2];

        (0, _assign2.default)(upload, fileDimensions);

        if (thumbnail && thumbnailDimensions) {
          upload.image = thumbnailDimensions;
          thumb = _this2.webex.internal.encryption.encryptBinary(thumbnail).then(function (_ref4) {
            var scr = _ref4.scr,
                cdata = _ref4.cdata;

            upload.image.scr = scr;

            return _promise2.default.all([cdata, _this2.hiddenSpaceUrl]);
          }).then(function (_ref5) {
            var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
                cdata = _ref6[0],
                spaceUrl = _ref6[1];

            return _this2._upload(cdata, spaceUrl + '/upload_sessions');
          }).then(function (metadata) {
            upload.image.url = upload.image.scr.loc = metadata.downloadUrl;
          });
        }
      }

      return _promise2.default.all([main, thumb]);
    });

    upload[PROMISE_SYMBOL] = promise;

    (0, _common.proxyEvents)(emitter, promise);

    return promise;
  },


  /**
   * Fetches the files from the share
   * @returns {Array}
   */
  getFiles: function getFiles() {
    var files = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(this.uploads), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _ref7 = _step.value;

        var _ref8 = (0, _slicedToArray3.default)(_ref7, 1);

        var key = _ref8[0];

        files.push(this.uploads.get(key)[FILE_SYMBOL]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return files;
  },


  /**
   * @param {File} file
   * @param {string} uri
   * @private
   * @returns {Promise}
   */
  _upload: function _upload(file, uri) {
    var fileSize = file.length || file.size || file.byteLength;
    var fileHash = (0, _sha2.default)(file).toString();

    return this.webex.upload({
      uri: uri,
      file: file,
      qs: {
        transcode: true
      },
      phases: {
        initialize: { fileSize: fileSize },
        upload: {
          $url: function $url(session) {
            return session.uploadUrl;
          }
        },
        finalize: {
          $uri: function $uri(session) {
            return session.finishUploadUrl;
          },

          body: { fileSize: fileSize, fileHash: fileHash }
        }
      }
    });
  },


  /**
   * Removes the specified file from the share (Does not currently delete the
   * uploaded file)
   * @param {File} file
   * @returns {Promise}
   */
  remove: function remove(file) {
    this.uploads.delete(file);

    // Returns a promise for future-proofiness.
    return _promise2.default.resolve();
  },


  /**
   * @private
   * @returns {Promise<Object>}
   */
  prepare: function prepare() {
    if (!this.uploads.size) {
      throw new Error('Cannot submit a share activity without atleast one file');
    }

    var activity = {
      verb: 'share',
      object: {
        objectType: 'content',
        displayName: this.object && this.object.displayName ? this.object.displayName : undefined,
        content: this.object && this.object.content ? this.object.content : undefined,
        mentions: this.object && this.object.mentions ? this.object.mentions : undefined,
        files: {
          items: []
        }
      },
      clientTempId: this.clientTempId
    };

    var promises = [];

    this.uploads.forEach(function (item) {
      activity.object.files.items.push(item);
      promises.push(item[PROMISE_SYMBOL]);
    });

    activity.object.contentCategory = this._determineContentCategory(activity.object.files.items);

    return _promise2.default.all(promises).then(function () {
      return activity;
    });
  },


  /**
   * @param {Array} items
   * @param {string} mimeType
   * @private
   * @returns {boolean}
   */
  _itemContainsActionWithMimeType: function _itemContainsActionWithMimeType(items, mimeType) {
    return (0, _some3.default)(items.map(function (item) {
      return (0, _some3.default)(item.actions, { mimeType: mimeType });
    }));
  },


  /**
   * @param {Array} items
   * @private
   * @returns {string}
   */
  _determineContentCategory: function _determineContentCategory(items) {
    // determine if the items contain an image
    if (this._itemContainsActionWithMimeType(items, 'application/x-cisco-webex-whiteboard')) {
      return 'documents';
    }

    var mimeTypes = (0, _filter3.default)((0, _map5.default)(items, 'mimeType'));

    if (mimeTypes.length !== items.length) {
      return 'documents';
    }

    var contentCategory = mimeTypes[0].split('/').shift();

    if (contentCategory !== 'video' && contentCategory !== 'image') {
      return 'documents';
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)(mimeTypes), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var mimeType = _step2.value;

        if (mimeType.split('/').shift() !== contentCategory) {
          return 'documents';
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return contentCategory + 's';
  },


  /**
   * @param {string} uri
   * @returns {Promise}
   */
  _retrieveSpaceUrl: function _retrieveSpaceUrl(uri) {
    return this.webex.request({
      method: 'PUT',
      uri: uri
    }).then(function (res) {
      return res.body.spaceUrl;
    });
  },
  version: '1.80.147'
});

/**
 * Instantiates a ShareActivity
 * @param {Object} conversation
 * @param {ShareActivity|Object|array} object
 * @param {ProxyWebex} webex
 * @returns {ShareActivity}
 */
ShareActivity.create = function create(conversation, object, webex) {
  if (object instanceof ShareActivity) {
    return object;
  }

  var files = void 0;

  if (object && object.object && object.object.files) {
    files = object.object.files;
    (0, _deleteProperty2.default)(object.object, 'files');
  }

  var share = new ShareActivity((0, _assign2.default)({
    conversation: conversation
  }, object), {
    parent: webex
  });

  files = files && files.items || files;
  if (files) {
    files.forEach(function (file) {
      return share.add(file);
    });
  }

  return share;
};

exports.default = ShareActivity;
//# sourceMappingURL=share-activity.js.map
