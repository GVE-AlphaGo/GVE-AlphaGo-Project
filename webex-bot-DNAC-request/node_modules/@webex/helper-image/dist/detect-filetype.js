'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.default = detectFileType;

var _httpCore = require('@webex/http-core');

var _mimeTypes = require('mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determines the file type of the specified file
 * @param {FileLike} file
 * @param {Object} logger
 * @returns {Promise<string>}
 */
/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

function detectFileType(file, logger) {
  if (file.type) {
    logger.info('file already has type ' + file.type + '. using existing file.type.');

    return _promise2.default.resolve(file.type);
  }

  if (file.mimeType) {
    logger.info('file already has mimeType ' + file.type + '. using existing file.mimeType.');

    return _promise2.default.resolve(file.mimeType);
  }

  // This kinda belongs in http core, but since we have no guarantee that
  // buffers are expected to have names there, it'll stay here for now.
  return (0, _httpCore.detect)(file).then(function (type) {
    if (type === 'application/x-msi' || type === 'application/octet-stream') {
      logger.info('detected filetype to be ' + type + '. Falling back to mime.lookup');

      return _mimeTypes2.default.lookup(file.name);
    }

    logger.info('detected filetype to be ' + type + '. returning it');

    return type;
  });
}
//# sourceMappingURL=detect-filetype.js.map
