'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

exports.default = processImage;

var _index = require('./index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-env browser */

/**
 * Determins the dimensions of an image
 * @param {Object} constraints
 * @param {Number} constraints.width
 * @param {Number} constraints.height
 * @param {Number} maxWidth
 * @param {Number} maxHeight
 * @returns {Object}
 */
function computeDimensions(_ref, maxWidth, maxHeight) {
  var width = _ref.width,
      height = _ref.height;

  if (height > width) {
    if (height > maxHeight) {
      width = width * maxHeight / height;
      height = maxHeight;
    }

    if (width > maxWidth) {
      height = height * maxWidth / width;
      width = maxWidth;
    }
  } else {
    if (width > maxWidth) {
      height = height * maxWidth / width;
      width = maxWidth;
    }

    if (height > maxHeight) {
      width = width * maxHeight / height;
      height = maxHeight;
    }
  }

  return { height: height, width: width };
}

/**
 * Measures an image file and produces a thumbnail for it
 * @param {Object} options
 * @param {Blob|ArrayBuffer} options.file
 * @param {Number} options.thumbnailMaxWidth
 * @param {Number} options.thumbnailMaxHeight
 * @param {Boolean} options.enableThumbnails
 * @param {Object} options.logger
 * @param {Boolean} options.isAvatar
 * @returns {Promise<Array>} Buffer, Dimensions, thumbnailDimensions
 */
/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

function processImage(_ref2) {
  var file = _ref2.file,
      type = _ref2.type,
      thumbnailMaxWidth = _ref2.thumbnailMaxWidth,
      thumbnailMaxHeight = _ref2.thumbnailMaxHeight,
      enableThumbnails = _ref2.enableThumbnails,
      logger = _ref2.logger,
      isAvatar = _ref2.isAvatar;

  if (!type || !type.startsWith('image')) {
    return _promise2.default.resolve();
  }

  file = file instanceof Blob ? file : new Blob([file]);

  return new _promise2.default(function (resolve, reject) {
    var img = new Image();

    img.onload = function onload() {
      resolve(img);
    };
    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  }).then(function (img) {
    var fileDimensions = (0, _pick3.default)(img, 'height', 'width');

    if (isAvatar) {
      // only if image is a profile avatar
      logger.info('dimensions will be set for avatar image');
      var size = fileDimensions.height > fileDimensions.width ? fileDimensions.height : fileDimensions.width;

      fileDimensions.height = size;
      fileDimensions.width = size;
    }
    if (!enableThumbnails) {
      logger.info('thumbnails not enabled');

      return [null, fileDimensions, null];
    }
    var thumbnailDimensions = computeDimensions(fileDimensions, thumbnailMaxWidth, thumbnailMaxHeight);

    var canvas = document.createElement('canvas');

    canvas.width = thumbnailDimensions.width;
    canvas.height = thumbnailDimensions.height;

    var ctx = canvas.getContext('2d');

    (0, _index.orient)({
      orientation: file && file.image ? file.image.orientation : '',
      img: img,
      x: 0,
      y: 0,
      width: thumbnailDimensions.width,
      height: thumbnailDimensions.height,
      ctx: ctx
    }, file);
    var parts = canvas.toDataURL('image/png').split(',');
    // Thumbnail uploads were failing with common/base64 decoding
    var byteString = atob(parts[1]);

    var buffer = new ArrayBuffer(byteString.length);
    var view = new DataView(buffer);

    for (var i = 0; i < byteString.length; i += 1) {
      view.setUint8(i, byteString.charCodeAt(i));
    }

    return [buffer, fileDimensions, thumbnailDimensions];
  });
}
//# sourceMappingURL=process-image.browser.js.map
