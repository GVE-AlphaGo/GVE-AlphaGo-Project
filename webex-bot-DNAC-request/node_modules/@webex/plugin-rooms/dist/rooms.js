'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

/**
 * Helper method to build a roomInfo object from a conversation object
 * @param {Conversation~ConversationObject} conversation
 * @returns {Promise<RoomInfoObject>}
 */
var buildRoomInfo = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(conversation) {
    var type, title, lastActivityDate, roomInfo;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            type = (0, _common.getHydraRoomType)(conversation.tags);
            title = conversation.displayName ? conversation.displayName : conversation.computedTitle;
            lastActivityDate = conversation.lastReadableActivityDate ? conversation.lastReadableActivityDate : conversation.lastRelevantActivityDate;
            roomInfo = (0, _extends3.default)({
              id: (0, _common.buildHydraRoomId)(conversation.id),
              type: type
            }, title && { title: conversation.displayName }, lastActivityDate && { lastActivityDate: lastActivityDate }, {
              lastSeenActivityDate: conversation.lastSeenActivityDate ? conversation.lastSeenActivityDate :
              // If user has never been seen set the date to "a long time ago"
              new Date(0).toISOString()
            });
            return _context2.abrupt('return', _promise2.default.resolve(roomInfo));

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2['catch'](0);
            return _context2.abrupt('return', _promise2.default.reject(_context2.t0));

          case 11:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this, [[0, 8]]);
  }));

  return function buildRoomInfo(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * Helper method to build a list of roomInfo object from conversation list
 * @param {Conversation~ConversationObjectList} conversations
 * @returns {Promise<RoomInfoList>}
 */


var buildRoomInfoList = function () {
  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(conversations) {
    var roomReadInfo, roomInfoPromises, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, conversation;

    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            // Convert each Conversation into a roomInfo object
            roomReadInfo = { items: [] };
            roomInfoPromises = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context3.prev = 5;


            for (_iterator = (0, _getIterator3.default)(conversations); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              conversation = _step.value;

              roomInfoPromises.push(buildRoomInfo(conversation));
            }

            _context3.next = 13;
            break;

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3['catch'](5);
            _didIteratorError = true;
            _iteratorError = _context3.t0;

          case 13:
            _context3.prev = 13;
            _context3.prev = 14;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 16:
            _context3.prev = 16;

            if (!_didIteratorError) {
              _context3.next = 19;
              break;
            }

            throw _iteratorError;

          case 19:
            return _context3.finish(16);

          case 20:
            return _context3.finish(13);

          case 21:
            return _context3.abrupt('return', _promise2.default.all(roomInfoPromises).then(function (roomInfoList) {
              roomReadInfo.items = roomInfoList;
              roomReadInfo.items.sort(function (a, b) {
                return a.lastActivityDate < b.lastActivityDate ? 1 : -1;
              });

              return roomReadInfo;
            }));

          case 22:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this, [[5, 9, 13, 21], [14,, 16, 20]]);
  }));

  return function buildRoomInfoList(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

var _webexCore = require('@webex/webex-core');

var _common = require('@webex/common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var debug = require('debug')('memberships');

/**
 * @typedef {Object} RoomObject
 * @property {string} id - (server generated) Unique identifier for the room
 * @property {string} title - The display name for the room. All room members
 * will see the title so make it something good
 * @property {string} teamId - (optional) The ID of the team to which the room
 * belongs
 * @property {isoDate} created - (server generated) The date and time that the
 * room was created
 */

/**
 * Rooms are virtual meeting places for getting stuff done. This resource
 * represents the room itself. Check out the {@link Memberships} API to learn
 * how to add and remove people from rooms and the {@link Messages} API for
 * posting and managing content.
 * @class
 * @name Rooms
 */
var Rooms = _webexCore.WebexPlugin.extend({
  /**
   * Register to listen for incoming rooms events
   * This is an alternate approach to registering for rooms webhooks.
   * The events passed to any registered handlers will be similar to the webhook JSON,
   * but will omit webhook specific fields such as name, secret, url, etc.
   * To utilize the `listen()` method, the authorization token used
   * will need to have `spark:all` and `spark:kms` scopes enabled.
   * Note that by configuring your application to enable or disable `spark:all`
   * via its configuration page will also enable or disable `spark:kms`.
   * See the <a href="https://js.samples.s4d.io/browser-socket/">Sample App</a>
   * for more details.
   * @instance
   * @memberof Rooms
   * @returns {Promise}
   * @example
   * webex.rooms.listen()
   *   .then(() => {
   *     console.log('listening to room events');
   *     webex.rooms.on('created', (event) => console.log(`Got a room:created event:\n${event}`);
   *     webex.rooms.on('updated', (event) => console.log(`Got a room:updated event:\n${event}`);
   *   })
   *   .catch((e) => console.error(`Unable to register for room events: ${e}`));
   * // Some app logic...
   * // WHen it is time to cleanup
   * webex.rooms.stopListening();
   * webex.rooms.off('created');
   * webex.rooms.off('updated');
   */
  listen: function listen() {
    var _this = this;

    return (0, _common.createEventEnvelope)(this.webex, _common.SDK_EVENT.EXTERNAL.RESOURCE.ROOMS).then(function (envelope) {
      _this.eventEnvelope = envelope;

      return _this.webex.internal.mercury.connect().then(function () {
        _this.listenTo(_this.webex.internal.mercury, _common.SDK_EVENT.INTERNAL.TEAMS_ACTIVITY, function (event) {
          return _this.onWebexApiEvent(event);
        });
      });
    });
  },


  /**
   * Creates a new room. The authenticated user is automatically added as a
   * member of the room. See the {@link Memberships} API to learn how to add
   * more people to the room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * webex.rooms.create({title: 'Create Room Example'})
   *   .then(function(room) {
   *     var assert = require('assert')
   *     assert(typeof room.created === 'string');
   *     assert(typeof room.id === 'string');
   *     assert(room.title === 'Create Room Example');
   *     console.log(room.title);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(room) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'rooms',
      body: room
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Returns a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @param {Object} options
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * webex.rooms.create({title: 'Get Room Example'})
   *   .then(function(r) {
   *     room = r
   *     return webex.rooms.get(room.id)
   *   })
   *   .then(function(r) {
   *     var assert = require('assert');
   *     assert.deepEqual(r, room);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(room, options) {
    var id = room.id || room;

    return this.request({
      service: 'hydra',
      resource: 'rooms/' + id,
      qs: options
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * Returns a list of rooms. In most cases the results will only contain rooms
   * that the authentiated user is a member of.
   * @instance
   * @memberof Rooms
   * @param {Object} options
   * @param {Object} options.max Limit the maximum number of rooms in the
   * response.
   * @returns {Promise<Page<RoomObject>>}
   * @example
   * var createdRooms;
   * Promise.all([
   *   webex.rooms.create({title: 'List Rooms Example 1'}),
   *   webex.rooms.create({title: 'List Rooms Example 2'}),
   *   webex.rooms.create({title: 'List Rooms Example 3'})
   * ])
   *   .then(function(r) {
   *     createdRooms = r;
   *     return webex.rooms.list({max: 3})
   *       .then(function(rooms) {
   *         var assert = require('assert');
   *         assert(rooms.length === 3);
   *         for (var i = 0; i < rooms.items.length; i+= 1) {
   *           assert(createdRooms.filter(function(room) {
   *             return room.id === rooms.items[i].id;
   *           }).length === 1);
   *         }
   *         return 'success';
   *       });
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this2 = this;

    return this.request({
      service: 'hydra',
      resource: 'rooms/',
      qs: options
    }).then(function (res) {
      return new _webexCore.Page(res, _this2.webex);
    });
  },


  /**
   * Returns a list of rooms with details about the data of the last
   * actvity in the room, and the date of the users last presences in
   * the room. The list is sorted with this with most recent activity first
   *
   * For rooms where lastActivityDate > lastSeenDate the space
   * can be considerd to be "unread"
   *
   * This differs from the rooms.list() function in the following ways:
   *  -- when called with no parameters it returns an array of all
   *     spaces, up to 1000, that the user is a member of
   *  -- pagination is not supported. ALL rooms are returned which
   *     can result in a large payload
   *  -- For users with hundreds of spaces, this API can take some time to
   *     to return, for this reason it supports an optional maxRecent parameter.
   *     If set this will return only the specified number of spaces with activity
   *     in the last two weeks.  Reccomended value is 30.  Max supported is 100.
   *  -- only "id", "type", "lastActivityDate", and "lastSeenDate" are
   *     guaranteed to be available for each room in the list
   *  -- "title" is usually returned, but not guaranteed
   *
   * In general this function should be used only when the client needs to
   * access read status info, for example on startup.
   * After startup, clients should track message and membership:seen events
   * to maintain read status client side.
   *
   * Since this API can take some time to return up to 1000 spaces, it is
   * recommended that custom clients call this first with the maxRecent parameter
   * set to 30, so that they can display some of the more recents spaces.  Calling
   * this API a second time with no parameters will return all the spaces.
   *
   * Not all spaces may be returned, for example when users in more than 1000
   * spaces, or when a new spaces is added after this function is called,
   * but before it returns. Custom clients should be prepared to gracefully
   * andle cases where an event occurs in a space not returned by this call,
   * by querying rooms.getWithReadStatus() with the id of the room in question
   *
   * This function may be deprecated when this info is provided in the membership
   * objects returned in the list function.
   * @instance
   * @param {int} maxRecent
   * @memberof Rooms
   * @returns {Promise<RoomInfoObjectList>}
   */
  listWithReadStatus: function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var _this3 = this;

      var maxRecent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var now, options;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              now = new Date();
              options = {
                activitiesLimit: 0,
                computeTitleIfEmpty: true,
                conversationsLimit: 1000,
                isActive: true
              };

              if (!(maxRecent > 0)) {
                _context.next = 7;
                break;
              }

              options.conversationsLimit = maxRecent;
              options.sinceDate = now.setDate(now.getDate() - 14);
              _context.next = 9;
              break;

            case 7:
              if (!(maxRecent < 0 || maxRecent > 100)) {
                _context.next = 9;
                break;
              }

              return _context.abrupt('return', _promise2.default.reject(new Error('rooms.listWithReadStatus: ' + 'optional maxRecent parameter must be an integer between 1 and 100')));

            case 9:
              return _context.abrupt('return', (0, _common.ensureConvoAvailability)(this.webex).then(function () {
                return _this3.webex.internal.conversation.list(options);
              }).then(function (conversations) {
                return buildRoomInfoList(conversations);
              }));

            case 10:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function listWithReadStatus() {
      return _ref.apply(this, arguments);
    }

    return listWithReadStatus;
  }(),


  /**
   * Returns a single room object with details about the data of the last
   * actvity in the room, and the date of the users last presence in
   * the room.
   *
   * For rooms where lastActivityDate > lastSeenDate the room
   * can be considerd to be "unread"
   *
   * This differs from the rooms.get() function in the following ways:
   *  -- it takes a single roomId parameter to fetch
   *  -- no other options are considered
   *  -- only "id", "type", "lastActivityDate", and "lastSeenDate" are
   *     guaranteed to be available in the return object
   *  -- "title" is usually returned, but not guaranteed
   *
   * In general clients should use the listWithReadStatus() method on startup
   * to get the initial roomStatus and then update their client side copy by
   * responding to message, membership and room events.
    * This function allows a custom client to be "nimble" if it is responding
   * to an event with a roomId that was not in the original fetch.  The
   * anticipated behavior is that getWithReadStats is called "just in time",
   * with the resulting room object being added to the list of cached room
   * objects on the client side.
   *
   * This function may be deprecated when this info is provided in the room
   * object returned in the get function.
   * @instance
   * @memberof Rooms
   * @param {string} roomId
   * @returns {Promise<RoomInfoObject>}
   */
  getWithReadStatus: function getWithReadStatus(roomId) {
    var _this4 = this;

    var deconstructedId = (0, _common.deconstructHydraId)(roomId);
    var conversation = {
      id: deconstructedId.id,
      cluster: deconstructedId.cluster
    };

    return (0, _common.ensureConvoAvailability)(this.webex).then(function () {
      return _this4.webex.internal.conversation.get(conversation, {
        computeTitleIfEmpty: true,
        activitiesLimit: 0 // don't send the whole history of activity
      }).then(function (convo) {
        return buildRoomInfo(convo);
      });
    });
  },


  /**
   * Deletes a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @returns {Promise}
   * @example
   * var room;
   * webex.rooms.create({title: 'Remove Room Example'})
   *  .then(function(r) {
   *    room = r;
   *    return webex.rooms.remove(room.id);
   *  })
   *  .then(function() {
   *    return webex.rooms.get(room.id);
   *  })
   *  .then(function() {
   *    var assert = require('assert');
   *    assert(false, 'the previous get should have failed');
   *  })
   *  .catch(function(reason) {
   *    var assert = require('assert');
   *    assert.equal(reason.statusCode, 404);
   *    return 'success'
   *  });
   *  // => success
   */
  remove: function remove(room) {
    var id = room.id || room;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: 'rooms/' + id
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }

      return res.body;
    });
  },


  /**
   * Used to update a single room's properties.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * webex.rooms.update({title: 'Update Room Example'})
   *   .then(function(r) {
   *     room = r;
   *     room.title = 'Update Room Example (Updated Title)';
   *     return webex.rooms.update(room);
   *   })
   *   .then(function() {
   *     return webex.rooms.get(room.id);
   *   })
   *   .then(function(room) {
   *    var assert = require('assert');
   *     assert.equal(room.title, 'Update Room Example (Updated Title)');
   *     return 'success';
   *   });
   *   // => success
   */
  update: function update(room) {
    var id = room.id;


    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: 'rooms/' + id,
      body: room
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * This function is called when an internal membership events fires,
   * if the user registered for these events with the listen() function.
   * External users of the SDK should not call this function
   * @private
   * @memberof Rooms
   * @param {Object} event
   * @returns {void}
   */
  onWebexApiEvent: function onWebexApiEvent(event) {
    var activity = event.data.activity;

    /* eslint-disable no-case-declarations */

    switch (activity.verb) {
      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:
        var roomCreatedEvent = this.getRoomEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);

        if (roomCreatedEvent) {
          debug('room "created" payload:             ' + (0, _stringify2.default)(roomCreatedEvent));
          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);
        }
        break;

      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:
        var roomUpdatedEvent = this.getRoomEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);

        if (roomUpdatedEvent) {
          debug('room "updated" payload:             ' + (0, _stringify2.default)(roomUpdatedEvent));
          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);
        }
        break;

      default:
        break;
    }
  },


  /**
   * Constructs the data object for an event on the rooms resource,
   * adhering to Hydra's Webehook data structure.
   * External users of the SDK should not call this function
   * @private
   * @memberof Rooms
   * @param {Object} activity from mercury
   * @param {Object} event type of "webhook" event
   * @returns {Object} constructed event
   */
  getRoomEvent: function getRoomEvent(activity, event) {
    try {
      var sdkEvent = (0, _cloneDeep3.default)(this.eventEnvelope);
      var room = void 0;

      sdkEvent.event = event;
      sdkEvent.data.created = activity.published;
      sdkEvent.actorId = (0, _common.buildHydraPersonId)(activity.actor.entryUUID);
      if (event === _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {
        room = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;
        sdkEvent.data.creatorId = (0, _common.buildHydraPersonId)(activity.actor.entryUUID);
        sdkEvent.data.lastActivity = activity.published;
      } else if (event === _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {
        room = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET;
        // TODO - lastActivity is not in the mercury 'update' event
        // would need to make an async call to get more conversation details
        // or we can skip this for the SDK, since we will provide an
        // SDK api to allow the app to query this directly if it needs
        // sdkEvent.data.lastActivity = 'to do';
      } else {
        throw new Error('unexpected event type');
      }
      sdkEvent.data.id = (0, _common.buildHydraRoomId)(activity[room].id);
      sdkEvent.data.type = (0, _common.getHydraRoomType)(activity[room].tags);
      sdkEvent.data.isLocked = activity[room].tags.includes(_common.SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);

      return sdkEvent;
    } catch (e) {
      this.webex.logger.error('Unable to generate SDK event from mercury \'socket activity for rooms:' + event + ' event: ' + e.message);

      return null;
    }
  },
  version: '1.80.147'
});

exports.default = Rooms;
//# sourceMappingURL=rooms.js.map
