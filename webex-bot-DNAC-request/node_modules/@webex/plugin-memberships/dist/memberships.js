'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var debug = require('debug')('memberships');

/**
 * @typedef {Object} MembershipObject
 * @property {string} id - Unique identifier for the membership
 * @property {string} roomId - The room ID
 * @property {string} personId - The person ID
 * @property {email} personEmail - The email address of the person / room member
 * @property {boolean} isModerator - Indicates whether the specified person should be a room moderator
 * @property {boolean} isMonitor - Indicates whether the specified member is a room monitor
 * @property {isoDate} created - The date and time that this membership was created
 */

/**
 * Memberships represent a person's relationship to a room. Use this API to list
 * members of any room that you're in or create memberships to invite someone
 * to a room. Memberships can also be updated to make someone a moderator
 * or deleted to remove them from the room.
 * @class
 * @name Memberships
 */
var Memberships = _webexCore.WebexPlugin.extend({
  /**
   * Register to listen for incoming membership events
   * This is an alternate approach to registering for membership webhooks.
   * The events passed to any registered handlers will be similar to the webhook JSON,
   * but will omit webhook specific fields such as name, secret, url, etc.
   * To utilize the `listen()` method, the authorization token used
   * will need to have `spark:all` and `spark:kms` scopes enabled.
   * Note that by configuring your application to enable or disable `spark:all`
   * via its configuration page will also enable or disable `spark:kms`.
   * See the <a href="https://js.samples.s4d.io/browser-socket/">Sample App</a>
   * for more details.
   * @instance
   * @memberof Memberships
   * @returns {Promise}
   * @example
   * webex.memberships.listen()
   *   .then(() => {
   *     console.log('listening to membership events');
   *     webex.memberships.on('created', (event) => {
   *       console.log(`Got a membership:created event:\n${event}`);
   *     }
   *     webex.memberships.on('updated', (event) => {
   *        console.log(`Got a membership:updated event:\n${event}`);
   *     }
   *     webex.memberships.on('seen', (event) => {
   *       // This represents a "read receipt" and will include a
   *       // lastSeenId for the message this member has just "read",
   *       // There is currently no equivelent webhook for this event.
   *       console.log(`Got a membership:seen event:\n${event}`);
   *     }
   *     webex.memberships.on('deleted', (event) =>  => {
   *       console.log(`Got a membership:created event:\n${event}`);
   *     }
   *   })
   *   .catch((e) => console.error(`Unable to register for membership events: ${e}`));
   * // App logic goes here...
   * // Later when it is time to clean up
   * webex.memberships.stopListening();
   * webex.memberships.off('created');
   * webex.memberships.off('updated');
   * webex.memberships.off('seen');
   * webex.memberships.off('deleted');
    */
  listen: function listen() {
    var _this = this;

    // Create a common envelope that we will wrap all events in
    return (0, _common.createEventEnvelope)(this.webex, _common.SDK_EVENT.EXTERNAL.RESOURCE.MEMBERSHIPS).then(function (envelope) {
      _this.eventEnvelope = envelope;

      // Register to listen to events
      return _this.webex.internal.mercury.connect().then(function () {
        _this.listenTo(_this.webex.internal.mercury, _common.SDK_EVENT.INTERNAL.TEAMS_ACTIVITY, function (event) {
          return _this.onWebexApiEvent(event);
        });
      });
    });
  },


  /**
   * Adds a person to a room. The person can be added by ID (`personId`) or by
   * Email Address (`personEmail`). The person can be optionally added to the room
   * as a moderator.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * webex.rooms.create({title: 'Create Membership Example'})
   *   .then(function(room) {
   *     return webex.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *    });
   *   })
   *   .then(function(membership) {
   *     var assert = require('assert');
   *     assert(membership.id);
   *     assert(membership.roomId);
   *     assert(membership.personId);
   *     assert(membership.personEmail);
   *     assert('isModerator' in membership);
   *     assert('isMonitor' in membership);
   *     assert(membership.created);
   *     return 'success';
   *   });
   *   // => success
   */
  create: function create(membership) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'memberships',
      body: membership
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Returns a single membership.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * var membership;
   * webex.rooms.create({title: 'Get Membership Example'})
   *   .then(function(room) {
   *     return webex.memberships.create({
   *       personEmail: 'alice@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return webex.memberships.get(m.id);
   *   })
   *   .then(function(m) {
   *     var assert = require('assert');
   *     assert.deepEqual(m, membership);
   *     return 'success';
   *   });
   *   // => success
   */
  get: function get(membership) {
    var id = membership.id || membership;

    return this.request({
      service: 'hydra',
      resource: 'memberships/' + id
    }).then(function (res) {
      return res.body.items || res.body;
    });
  },


  /**
   * Returns a list of memberships. In most cases the results will only contain
   * rooms that the authentiated user is a member of. You can filter the results
   * by room to list people in a room or by person to find rooms that a
   * specific person is a member of.
   * @instance
   * @memberof Memberships
   * @param {Object} options
   * @param {string} options.personId
   * @param {string} options.personEmail
   * @param {string} options.roomId
   * @param {number} options.max
   * @returns {Promise<Page<MembershipObject>>}
   * @example
   * var room;
   * webex.rooms.create({title: 'List Membership Example'})
   *   .then(function(r) {
   *     room = r;
   *     return webex.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *     });
   *   })
   *   .then(function() {
   *     return webex.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 2);
   *     for (var i = 0; i < memberships.length; i+= 1) {
   *       assert.equal(memberships.items[i].roomId, room.id);
   *     }
   *     return 'success';
   *   });
   *   // => success
   */
  list: function list(options) {
    var _this2 = this;

    return this.request({
      service: 'hydra',
      resource: 'memberships',
      qs: options
    }).then(function (res) {
      return new _webexCore.Page(res, _this2.webex);
    });
  },


  /**
   * Returns a list of memberships with details about the lastSeenId for each
   * user, allowing a client to indicate "read status" in a space GUI
   *
   * This differs from the memberships.list() function in the following ways:
   *  -- it accepts only a room or object with a valid roomId
   *  -- no other options, eg: max, are considered
   *  -- results are not paginated
   *  -- memberships in the return do not include the
   *     "created", "isRoomHidden", fields
   *  -- memberships in the return do include the new
   *    "lastSeenId", and "lastSeenDate" fields
   *     these will not exist if the member has never "seen" the space
   *
   * In general this function should be used only when the
   * client needs to access read status info.
   *
   * This function may be deprecated when this info is provided in the membership
   * objects returned in the list function.
   *
   *
   * @instance
   * @memberof Memberships
   * @param {Object} options
   * @param {string} options.roomId
   * @returns {Promise<MembershipObjectList>}
   */
  listWithReadStatus: function listWithReadStatus(options) {
    var _this3 = this;

    var deconstructedId = (0, _common.deconstructHydraId)(options.roomId);
    var conversation = {
      id: deconstructedId.id,
      cluster: deconstructedId.cluster
    };

    return (0, _common.ensureMyIdIsAvailable)(this.webex).then(function () {
      return (0, _common.ensureConvoAvailability)(_this3.webex).then(function () {
        return _this3.webex.internal.conversation.get(conversation, {
          participantAckFilter: 'all', // show lastAck info for each participant
          activitiesLimit: 0 // don't send the whole history of activity
        }).then(function (resp) {
          try {
            // We keep track of the last read message by each user
            var roomUUID = resp.id;
            var roomId = (0, _common.buildHydraRoomId)(roomUUID);
            var particpants = resp.participants.items;
            var lastReadInfo = { items: [] };
            var roomType = (0, _common.getHydraRoomType)(resp.tags);
            var myId = _this3.webex.internal.me.id;
            var isRoomHidden = resp.tags.includes(_common.SDK_EVENT.INTERNAL.ACTIVITY_TAG.HIDDEN);

            for (var i = 0; i < particpants.length; i += 1) {
              var participant = particpants[i];
              var participantInfo = {
                id: (0, _common.buildHydraMembershipId)(participant.entryUUID, roomUUID),
                roomId: roomId,
                personId: (0, _common.buildHydraPersonId)(participant.entryUUID),
                personEmail: participant.entryEmailAddress || participant.entryEmail,
                personDisplayName: participant.displayName,
                personOrgId: (0, _common.buildHydraOrgId)(participant.orgId),
                isMonitor: false, // deprecated, but included for completeness
                roomType: roomType
                // created is not available in the conversations payload
              };

              if (isRoomHidden && participantInfo.personId === myId) {
                participantInfo.isRoomHidden = isRoomHidden;
              }

              if ('roomProperties' in participant) {
                if ('lastSeenActivityDate' in participant.roomProperties) {
                  participantInfo.lastSeenId = (0, _common.buildHydraMessageId)(participant.roomProperties.lastSeenActivityUUID);
                  participantInfo.lastSeenDate = participant.roomProperties.lastSeenActivityDate;
                }
                if ('isModerator' in participant.roomProperties) {
                  participantInfo.isModerator = participant.roomProperties.isModerator;
                }
              }

              lastReadInfo.items.push(participantInfo);
            }

            return _promise2.default.resolve(lastReadInfo);
          } catch (e) {
            return _promise2.default.reject(e);
          }
        });
      });
    });
  },


  /**
   * Deletes a single membership.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise}
   * @example
   * var membership, room;
   * webex.rooms.create({title: 'Remove Membership Example'})
   *   .then(function(r) {
   *     room = r;
   *     return webex.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return webex.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 2);
   *     return webex.memberships.remove(membership);
   *   })
   *   .then(function() {
   *     return webex.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 1);
   *     return 'success';
   *   });
   *   // => success
   */
  remove: function remove(membership) {
    var id = membership.id || membership;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: 'memberships/' + id
    }).then(function (res) {
      // Firefox has some issues with 204s and/or DELETE. This should move to
      // http-core
      if (res.statusCode === 204) {
        return undefined;
      }

      return res.body;
    });
  },


  /**
   * Used to update a single membership's properties
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * var membership, room;
   * webex.rooms.create({title: 'Memberships Example'})
   *   .then(function(r) {
   *     room = r;
   *     return webex.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     membership = memberships.items[0];
   *     var assert = require('assert');
   *     assert.equal(membership.isModerator, false);
   *     membership.isModerator = true;
   *     return webex.memberships.update(membership);
   *   })
   *   .then(function() {
   *     return webex.memberships.get(membership.id);
   *   })
   *   .then(function(membership) {
   *     var assert = require('assert');
   *     assert.equal(membership.isModerator, true);
   *     return 'success';
   *   });
   *   // => success
   */
  update: function update(membership) {
    var id = membership.id || membership;

    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: 'memberships/' + id,
      body: membership
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Updates the lastSeenId attribute of a membership.
   * Call this method to send a "read receipt" for a given message.
   * This will update the lastSeenId for the user's membership in
   * space where the message is.
   * @instance
   * @memberof Memberships
   * @param {string} message
   * @returns {Promise<MembershipObject>}
   */
  updateLastSeen: function updateLastSeen(message) {
    var _this4 = this;

    var activity = {
      id: (0, _common.deconstructHydraId)(message.id).id
    };
    var deconstructedId = (0, _common.deconstructHydraId)(message.roomId);
    var conversation = {
      id: deconstructedId.id,
      cluster: deconstructedId.cluster
    };

    return (0, _common.ensureConvoAvailability)(this.webex).then(function () {
      return _this4.webex.internal.conversation.acknowledge(conversation, activity).then(function (ack) {
        return {
          lastSeenId: (0, _common.buildHydraMessageId)(ack.object.id),
          id: (0, _common.buildHydraMembershipId)(ack.actor.entryUUID, ack.target.id),
          personId: (0, _common.buildHydraPersonId)(ack.actor.entryUUID),
          personEmail: ack.actor.emailAddress || ack.actor.entryEmail,
          personDisplayName: ack.actor.displayName,
          personOrgId: (0, _common.buildHydraOrgId)(ack.actor.orgId),
          roomId: (0, _common.buildHydraRoomId)(ack.target.id),
          roomType: (0, _common.getHydraRoomType)(ack.target.tags),
          isRoomHidden: false, // any activity unhides a space.
          isMonitor: false, // deprecated, returned for back compat
          created: ack.published
        };
      });
    });
  },


  /**
   * This function is called when an internal membership events fires,
   * if the user registered for these events with the public listen() method.
   * External users of the SDK should not call this function
   * @private
   * @memberof Memberships
   * @param {Object} event
   * @returns {void}
   */
  onWebexApiEvent: function onWebexApiEvent(event) {
    var _this5 = this;

    var activity = event.data.activity;

    /* eslint-disable no-case-declarations */

    switch (activity.verb) {
      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:
        var membershipCreatedEventDataArray = activity.object.participants.items.map(function (participant) {
          var output = (0, _cloneDeep3.default)(activity);

          output.target = (0, _cloneDeep3.default)(activity.object);
          output.object = (0, _cloneDeep3.default)(participant);

          return _this5.getMembershipEvent(output, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);
        });

        membershipCreatedEventDataArray.forEach(function (data) {
          if (data) {
            debug('membership "created" payload: ' + (0, _stringify2.default)(data));
            _this5.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, data);
          }
        });
        break;

      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.ADD:
        var membershipCreatedEventData = this.getMembershipEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);

        if (membershipCreatedEventData) {
          debug('membership "created" payload:             ' + (0, _stringify2.default)(membershipCreatedEventData));
          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, membershipCreatedEventData);
        }
        break;

      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.LEAVE:
        var membershipDeletedEventData = this.getMembershipEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED);

        if (membershipDeletedEventData) {
          debug('membership "deleted" payload:             ' + (0, _stringify2.default)(membershipDeletedEventData));
          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED, membershipDeletedEventData);
        }
        break;

      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.ADD_MODERATOR:
      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.REMOVE_MODERATOR:
      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.HIDE:
        var membershipUpdatedEventData = this.getMembershipEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);

        if (membershipUpdatedEventData) {
          debug('membership "updated" payload:             ' + (0, _stringify2.default)(membershipUpdatedEventData));
          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, membershipUpdatedEventData);
        }
        break;

      case _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.ACKNOWLEDGE:
        var membershipSeenEventData = this.getMembershipEvent(activity, _common.SDK_EVENT.EXTERNAL.EVENT_TYPE.SEEN);

        if (membershipSeenEventData) {
          debug('membership "updated" payload:             ' + (0, _stringify2.default)(membershipSeenEventData));
          this.trigger(_common.SDK_EVENT.EXTERNAL.EVENT_TYPE.SEEN, membershipSeenEventData);
        }
        break;

      default:
        break;
    }
  },


  /**
   * Constructs the data object for an event on the memberships resource,
   * adhering to Hydra's Webehook data structure memberships.
   * External users of the SDK should not call this function
   * @private
   * @memberof Memberships
   * @param {Object} activity from mercury
   * @param {Object} event type of "webhook" event
   * @returns {Object} constructed event
   */
  getMembershipEvent: function getMembershipEvent(activity, event) {
    try {
      var sdkEvent = (0, _cloneDeep3.default)(this.eventEnvelope);
      var member = void 0;
      var space = void 0;

      sdkEvent.event = event;
      sdkEvent.data.created = activity.published;
      sdkEvent.actorId = (0, _common.buildHydraPersonId)(activity.actor.entryUUID);
      if (activity.verb !== _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.HIDE) {
        sdkEvent.data.roomId = (0, _common.buildHydraRoomId)(activity.target.id);
        sdkEvent.data.roomType = (0, _common.getHydraRoomType)(activity.target.tags);
        sdkEvent.data.isRoomHidden = false; // any activity unhides a space.
      } else {
        sdkEvent.data.roomId = (0, _common.buildHydraRoomId)(activity.object.id);
        sdkEvent.data.roomType = _common.SDK_EVENT.EXTERNAL.SPACE_TYPE.DIRECT;
        // currently hidden attribute is only set on 1-1
        sdkEvent.data.isRoomHidden = true;
      }
      if (activity.verb !== _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.ACKNOWLEDGE) {
        if (activity.object.roomProperties && activity.object.roomProperties.isModerator) {
          sdkEvent.data.isModerator = true;
        } else {
          sdkEvent.data.isModerator = false;
        }
      }
      // This is deprecated but still sent in the webhooks
      // We won't send it for our new SDK events
      // sdkEvent.data.isMonitor = false;

      if (activity.verb === _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.ACKNOWLEDGE) {
        // For a read receipt the person is the "actor" or the one who did the reading
        member = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.ACTOR;
        // The space with the read message is the "target"
        space = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET;
        // And the "object" is the message that was last seen
        sdkEvent.data.lastSeenId = (0, _common.buildHydraMessageId)(activity.object.id);
      } else if (activity.verb === _common.SDK_EVENT.INTERNAL.ACTIVITY_VERB.HIDE) {
        // For a hide activity the person is also the "actor"
        member = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.ACTOR;
        // But the space is now the "object"
        space = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;
      } else {
        // For most memberships events the person is the 'object"
        member = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;
        // and the space is the "target"
        space = _common.SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET;
      }

      sdkEvent.data.id = (0, _common.buildHydraMembershipId)(activity[member].entryUUID, activity[space].id);
      sdkEvent.data.personId = (0, _common.buildHydraPersonId)(activity[member].entryUUID);
      sdkEvent.data.personEmail = activity[member].emailAddress || activity[member].entryEmail;
      sdkEvent.data.personDisplayName = activity[member].displayName;
      sdkEvent.data.personOrgId = (0, _common.buildHydraOrgId)(activity[member].orgId);

      return sdkEvent;
    } catch (e) {
      this.webex.logger.error('Unable to generate SDK event from mercury \'socket activity for memberships:' + event + ' event: ' + e.message);

      return null;
    }
  },
  version: '1.80.147'
});

exports.default = Memberships;
//# sourceMappingURL=memberships.js.map
