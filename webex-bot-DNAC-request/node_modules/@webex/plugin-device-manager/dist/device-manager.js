'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

require('@webex/internal-plugin-lyra');

require('@webex/internal-plugin-search');

var _webexCore = require('@webex/webex-core');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _constants = require('./constants');

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */
var DeviceManager = _webexCore.WebexPlugin.extend({
  namespace: 'DeviceManager',
  _devicePendingPinChallenge: null,
  _pairedDevice: null,
  _boundSpace: null,

  initialize: function initialize() {
    var _this = this;

    // Lyra mercury events listener
    this.webex.internal.mercury.on('event:lyra.space_updated', function (_ref) {
      var data = _ref.data;

      _this._receiveDeviceUpdates(data);
    });
  },


  /**
  * Gets a list of all recent devices associated with the user
  * the device list gets populated from Redis
  * @returns {Promise<Device>}
  */
  getAll: function getAll() {
    return _collection2.default.getAll();
  },


  /**
  * Gets a list of all recent devices associated with the user
  * the device list gets populated from Redis
  * @returns {Promise<Device>}
  */
  refresh: function refresh() {
    var _this2 = this;

    _collection2.default.reset();

    return this.webex.request({
      api: 'wdm',
      resource: 'devices/auxiliary'
    }).then(function (res) {
      if (!res.body) {
        return _promise2.default.reject();
      }

      return _this2._updateDeviceMetadata(res.body.items).then(function (devices) {
        /* eslint-disable consistent-return */
        devices.forEach(function (device) {
          if (device.deviceInfo && device.deviceInfo.machineType === _constants.LYRA_SPACE) {
            return _this2.webex.internal.lyra.space.get(device.deviceInfo).catch(function (err) {
              _this2.logger.error('DeviceManager#refresh: failed to receive device info', err);
            });
          }
        });
        /* eslint-enable consistent-return */
        res.body.items.forEach(function (device) {
          _collection2.default.set(device);
        });

        return _this2.getAll();
      });
    }).catch(function (err) {
      _this2.logger.error('DeviceManager#refresh: failed to fetch recent devices', err);
    });
  },


  /**
  * Search for a device by name
  * @param {Object} options
  * @param {string} options.searchQuery
  * @returns {Promise<Device>}
  */
  search: function search(options) {
    var _this3 = this;

    if (!options || !options.searchQuery) {
      this.logger.error('DeviceManager#search: options.searchQuery is required');

      return _promise2.default.reject(new Error('DeviceManager#search: options.searchQuery is required'));
    }

    return this.webex.internal.search.people({
      searchId: _uuid2.default.v4(),
      searchType: 'DEVICE_SEARCH',
      searchEntity: 'device',
      includePeople: false,
      includeRooms: true,
      queryString: options.searchQuery
    }).catch(function (err) {
      _this3.logger.error('DeviceManager#search: failed to search a device', err);
    });
  },


  /**
  * Caches the device info and also registers to Redis for subsequent fetches
  * @param {Object} device
  * @param {string} device.id
  * @returns {deviceInfo}
  */
  upsert: function upsert(device) {
    var _this4 = this;

    var deviceId = device.id || device.identity && device.identity.id;

    if (!deviceId) {
      this.logger.error('DeviceManager#upsert: device.id is required');

      return _promise2.default.reject(new Error('DeviceManager#upsert: device.id is required'));
    }
    this._pairedDevice = this._devicePendingPinChallenge;
    this._devicePendingPinChallenge = null;
    // check if the device is already existing, if so then merge else add
    var existingDevice = _collection2.default.get(deviceId);

    if (existingDevice) {
      _collection2.default.set(device);

      return _promise2.default.resolve(_collection2.default.get(deviceId));
    }

    // new device requested, add to wdm for subsequent retreivals
    return this.webex.request({
      api: 'wdm',
      method: 'PUT',
      resource: 'devices/auxiliary/Room/' + deviceId
    }).then(function (res) {
      var auxDevice = res.body;

      return _this4._decryptDeviceName(auxDevice);
    }).then(function (device) {
      _collection2.default.set(device);

      return _promise2.default.resolve(_collection2.default.get(deviceId));
    }).catch(function (err) {
      _this4.logger.error('DeviceManager#upsert: failed to add/update a device', err);

      return _promise2.default.reject(err);
    });
  },


  /**
  * Retreives device info of a particular device
  * @param {string} token
  * @returns {Promise<deviceInfo>}
  */
  get: function get(token) {
    var _this5 = this;

    if (!token) {
      this.logger.error('DeviceManager#get: token is required');

      return _promise2.default.reject(new Error('DeviceManager#get: token is required'));
    }
    var deviceInfo = void 0;

    return this.webex.internal.lyra.getAdvertisedEndpoint(token).then(function (res) {
      deviceInfo = res;

      return _this5.webex.internal.lyra.space.get({ id: res.advertiser.id });
    }).then(function (result) {
      // the deviceInfo doesn't have proper displayName, hence update
      // displayName on deviceInfo for search to work
      if (result && result.identity && result.identity.displayName) {
        deviceInfo.advertiser.displayName = result.identity.displayName;
      }

      return deviceInfo;
    }).catch(function (err) {
      _this5.logger.error('DeviceManager#get: failed to get device info', err);

      return _promise2.default.reject(err);
    });
  },


  /**
  * Unregisters the device from Redis, will not fetch in subsequent loads,
  * similar to space.deleteBinding()
  * @param {string} deviceId
  * @returns {Promise<deviceInfo>}
  */
  remove: function remove(deviceId) {
    var _this6 = this;

    if (!deviceId) {
      this.logger.error('DeviceManager#remove: deviceId is required');

      return _promise2.default.reject(new Error('DeviceManager#remove: deviceId is required'));
    }

    return this.webex.request({
      method: 'delete',
      api: 'wdm',
      resource: 'devices/auxiliary/' + deviceId
    }).catch(function (error) {
      _this6.logger.error('DeviceManager#remove: failed to remove the device', error);

      return _promise2.default.reject(error);
    });
  },


  /**
  * Requests to display PIN on the device
  * @param {object} device
  * @param {object} options
  * @param {object} options.data
  * @returns {Promise<deviceInfo>}
  */
  requestPin: function requestPin(device) {
    var _this7 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var deviceId = device.id || device.identity && device.identity.id;

    if (!deviceId) {
      this.logger.error('DeviceManager#requestPin: device.id is required');

      return _promise2.default.reject(new Error('DeviceManager#requestPin: device.id is required'));
    }
    var space = { id: deviceId, url: '/spaces/' + deviceId };

    return this.webex.internal.lyra.space.get(space).then(function (dev) {
      // check if the space is pinChallenge capable
      if (dev && dev.occupants && dev.occupants.pinChallenge) {
        _this7.logger.info('DeviceManager#requestPin: space is PIN challenge capable');

        return _this7.webex.internal.lyra.space.join(space, {
          passType: 'MANUAL',
          verificationInitiation: 'PIN',
          data: options.data
        }).then(function () {
          _this7._devicePendingPinChallenge = dev;

          // return the actual device so that it can be upserted on successful
          // PIN exchange
          return dev;
        });
      }
      // pairs with the space if it's not PIN challenge capable
      _this7.logger.info('DeviceManager#requestPin: space is not PIN challenge capable, probably already occupied, will still return device info');

      return _this7.webex.internal.lyra.space.get(space).then(function () {
        return _promise2.default.resolve(dev);
      });
    }).catch(function (err) {
      _this7.logger.error('DeviceManager#requestPin: device failed PIN challenge request', err);

      return _promise2.default.reject(err);
    });
  },


  /**
  * pairs the device with the user (manual pairing), also adds it to
  * user's recents list for subsequent fetches.
  * similar to space.join()
  * @param {object} options
  * @param {number} options.pin
  * @returns {Promise<deviceInfo>}
  */
  pair: function pair() {
    var _this8 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!options.pin) {
      this.logger.error('DeviceManager#pair: options.pin is required');

      return _promise2.default.reject(new Error('DeviceManager#pair: options.pin is required'));
    }
    if (this._devicePendingPinChallenge) {
      var space = { id: this._devicePendingPinChallenge.identity.id, url: '/spaces/' + this._devicePendingPinChallenge.identity.id };

      return this.webex.internal.lyra.space.join(space, {
        passType: 'PIN_ANSWER',
        data: options.pin
      }).catch(function (err) {
        _this8.logger.error('DeviceManager#pair: incorrect PIN, unable to pair ', err);

        return _promise2.default.reject(err);
      }).then(function () {
        return _this8.upsert(_this8._devicePendingPinChallenge);
      });
    }
    this.logger.error('DeviceManager#pair: no device to pair');

    return _promise2.default.reject(new Error('DeviceManager#pair: no device to pair'));
  },


  /**
  * unpairs the device with the user (manual/ultrasonic pairing), but still
  * keeps in the recents list/does not remove from Redis
  * options.removeAllDevices will remove all associated devices to user
  * similar to space.leave()
  * @param {object} options
  * @param {boolean} options.removeAllDevices
  * @returns {Promise<deviceInfo>}
  */
  unpair: function unpair() {
    var _this9 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#unpair: no device to unpair');

      return _promise2.default.reject(new Error('DeviceManager#unpair: no device to unpair'));
    }
    var space = { url: '/spaces/' + this._pairedDevice.identity.id };

    return this.webex.internal.lyra.space.leave(space, options).catch(function (err) {
      _this9.logger.error('DeviceManager#unpair: failed to remove device from Lyra', err);

      return _promise2.default.reject(err);
    });
  },


  /**
  * binds the space to the paired device (if supported)
  * similar to space.bindConversation()
  * @param {object} options
  * @param {boolean} options.url, conversation url
  * @param {boolean} options.kmsResourceObjectUrl of the convo
  * @returns {Promise<deviceInfo>}
  */
  bindSpace: function bindSpace() {
    var _this10 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!options.url) {
      this.logger.error('DeviceManager#pair: options.url is required');

      return _promise2.default.reject(new Error('DeviceManager#bindSpace: options.url is required'));
    }
    if (!options.kmsResourceObjectUrl) {
      this.logger.error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required');

      return _promise2.default.reject(new Error('DeviceManager#bindSpace: options.kmsResourceObjectUrl is required'));
    }
    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#bindSpace: No device paired currently');

      return _promise2.default.reject(new Error('DeviceManager#bindSpace: No device paired currently'));
    }
    var space = { url: '/spaces/' + this._pairedDevice.identity.id, id: this._pairedDevice.identity.id };

    this._boundSpace = {
      kmsResourceObjectUrl: options.kmsResourceObjectUrl,
      url: options.url
    };

    return this.webex.internal.lyra.space.bindConversation(space, this._boundSpace).catch(function (err) {
      _this10.logger.error('DeviceManager#bindSpace: failed to bind device to Space');

      return _promise2.default.reject(err);
    });
  },


  /**
  * unbinds the space to the paired device (if supported)
  * similar to space.unbindConversation()
  * @returns {Promise<deviceInfo>}
  */
  unbindSpace: function unbindSpace() {
    var _this11 = this;

    if (!this._pairedDevice || !this._boundSpace) {
      this.logger.error('DeviceManager#unbindSpace: No space currently bound to the device');

      return _promise2.default.reject(new Error('DeviceManager#unbindSpace: No space currently bound to the device'));
    }
    var space = { url: '/spaces/' + this._pairedDevice.identity.id, id: this._pairedDevice.identity.id };

    return this.webex.internal.lyra.space.unbindConversation(space, this._boundSpace).then(function (res) {
      _this11._boundSpace = null;

      return _promise2.default.resolve(res);
    }).catch(function (err) {
      _this11.logger.error('DeviceManager#unbindSpace: failed to unbind Space to device');

      return _promise2.default.reject(err);
    });
  },


  /**
  * Gets the audio state of the paired device
  * similar to device.getAudioState()
  * @returns {Promise<audioState>}
  */
  getAudioState: function getAudioState() {
    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#getAudioState: Currently no device is paired');

      return _promise2.default.reject(new Error('DeviceManager#getAudioState: Currently no device is paired'));
    }

    return this.webex.internal.lyra.device.getAudioState(this._pairedDevice);
  },


  /**
  * Updates audio state of the paired device, should be called every 10 minutes
  * or when mic or volume state is changed
  * similar to device.putAudioState()
  * @param {object} space
  * @param {object} audioState
  * @returns {Promise<audioState>}
  */
  putAudioState: function putAudioState(space) {
    var audioState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return this.webex.internal.lyra.device.putAudioState(space, audioState);
  },


  /**
  * Mutes paired device
  * similar to device.mute()
  * @returns {Promise<audioState>}
  */
  mute: function mute() {
    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#mute: Currently no device is paired');

      return _promise2.default.reject(new Error('DeviceManager#mute: Currently no device is paired'));
    }

    return this.webex.internal.lyra.device.mute(this._pairedDevice);
  },


  /**
  * Unmutes paired device
  * similar to device.unmute()
  * @returns {Promise<audioState>}
  */
  unmute: function unmute() {
    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#unmute: Currently no device is paired');

      return _promise2.default.reject(new Error('DeviceManager#unmute: Currently no device is paired'));
    }

    return this.webex.internal.lyra.device.unmute(this._pairedDevice);
  },


  /**
  * Increases paired device's volume
  * similar to device.increaseVolume()
  * @returns {Promise<audioState>}
  */
  increaseVolume: function increaseVolume() {
    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#increaseVolume: Currently no device is paired');

      return _promise2.default.reject(new Error('DeviceManager#increaseVolume: Currently no device is paired'));
    }

    return this.webex.internal.lyra.device.increaseVolume(this._pairedDevice);
  },


  /**
  * Decreases paired device's volume
  * similar to device.decreaseVolume()
  * @returns {Promise<audioState>}
  */
  decreaseVolume: function decreaseVolume() {
    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#decreaseVolume: Currently no device is paired');

      return _promise2.default.reject(new Error('DeviceManager#decreaseVolume: Currently no device is paired'));
    }

    return this.webex.internal.lyra.device.decreaseVolume(this._pairedDevice);
  },


  /**
  * Sets paired device's volume but should use increase and decrease api instead
  * similar to device.setVolume()
  * @param {number} level
  * @returns {Promise<audioState>}
  */
  setVolume: function setVolume() {
    var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (!this._pairedDevice) {
      this.logger.error('DeviceManager#setVolume: Currently no device is paired');

      return _promise2.default.reject(new Error('DeviceManager#setVolume: Currently no device is paired'));
    }

    return this.webex.internal.lyra.device.setVolume(this._pairedDevice, level);
  },


  /**
  * Utility function to update decrypted device name on device object
  * @param {Array} deviceArray
  * @returns {device}
  */
  _updateDeviceMetadata: function _updateDeviceMetadata() {
    var _this12 = this;

    var deviceArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    if (!deviceArray.length) {
      return _promise2.default.resolve(deviceArray);
    }
    var devices = (0, _cloneDeep3.default)(deviceArray);

    return _promise2.default.all(devices.map(function (device, index) {
      return _this12.webex.internal.services.waitForCatalog('postauth').then(function () {
        if (device.deviceClass === _constants.UC_CLOUD) {
          device.id = _this12.webex.internal.services.get('wdm') + '/' + device.id;
        }

        return _this12._decryptDeviceName(device);
      }).then(function (updatedDevice) {
        devices[index] = updatedDevice;

        return _promise2.default.resolve();
      });
    })).then(function () {
      return _promise2.default.resolve(devices);
    });
  },


  /**
  * Utility function to update decrypted device name on device object
  * @param {object} inDevice
  * @returns {device}
  */
  _decryptDeviceName: function _decryptDeviceName() {
    var _this13 = this;

    var inDevice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var device = (0, _cloneDeep3.default)(inDevice);

    if (device.metadata && device.metadata.encryptedUserAssignedName && device.metadata.encryptionKeyUrl) {
      return this.webex.internal.encryption.decryptText(device.metadata.encryptionKeyUrl, device.metadata.encryptedUserAssignedName).then(function (decryptedDeviceName) {
        // set userAssignedName as the decypted value, unset encryptedUserAssignedName since it's not needed
        device.metadata.encryptedUserAssignedName = undefined;
        device.metadata.userAssignedName = decryptedDeviceName;

        return _promise2.default.resolve(device);
      }).catch(function (err) {
        // unset encryptedUserAssignedName if failed to decrypt
        device.metadata.encryptedUserAssignedName = undefined;
        _this13.logger.error('DeviceCollection#_decryptDeviceName: failed to decrypt device name', err);
      });
    }

    return _promise2.default.resolve(device);
  },


  /**
  * Utility function to update device info on mercury updates
  * @param {object} device
  * @returns {device}
  */
  _receiveDeviceUpdates: function _receiveDeviceUpdates(device) {
    var _this14 = this;

    // we care only the updates are for the registered devices
    if (device && device.spaceUrl) {
      var deviceId = device.spaceUrl.substring(device.spaceUrl.lastIndexOf('/') + 1);
      var existingDevice = _collection2.default.get(deviceId);

      if (existingDevice) {
        return this.webex.internal.lyra.space.get({ id: deviceId }).then(function (space) {
          var device = _collection2.default.get(deviceId);

          if (device && space.occupants && (!space.occupants.self || !space.occupants.self.verified)) {
            device.productName = space.devices && space.devices[0] && space.devices[0].productName || _constants.DEFAULT_PRODUCT_NAME;
            // pin challenge is not verified reset _pairedDevice if ids
            // match
            var pairedDeviceId = _this14._pairedDevice && (_this14._pairedDevice.id || _this14._pairedDevice.identity.id);

            if (pairedDeviceId === deviceId) {
              _this14._pairedDevice = null;
              _this14.logger.info('DeviceManager#_receiveDeviceUpdates: device ' + deviceId + ' lost pairing');

              return _promise2.default.resolve();
            }
            // we do not want to reset the device pending PIN challenge
            if (_this14._devicePendingPinChallenge.identity.id !== deviceId) {
              return _this14.upsert(device);
            }

            return _promise2.default.resolve();
          }

          return _promise2.default.resolve();
        }).catch(function (err) {
          _this14.logger.error('DeviceManager#_receiveDeviceUpdates: failed to receive updates for Lyra space', err);
        });
      }
    }

    return _promise2.default.resolve();
  },
  version: '1.80.147'
});

exports.default = DeviceManager;
//# sourceMappingURL=device-manager.js.map
