{"version":3,"sources":["user.js"],"names":["User","WebexPlugin","extend","keyFactory","email","options","String","create","namespace","children","batcher","UserUUIDBatcher","props","hasPassword","default","type","session","store","UserUUIDStore","activate","verificationToken","confirmationCode","id","reject","Error","scope","webex","config","credentials","activateOptions","request","uri","activationUrl","method","body","auth","user","client_id","pass","client_secret","sendImmediately","then","res","set","supertoken","tokenData","asUUID","all","map","u","_extractUUID","force","patterns","uuid","test","resolve","_extractEmailAddress","getUUID","fetchUUID","recordUUID","emailAddress","get","service","resource","getByEmail","userExists","catch","initialize","args","prototype","add","register","verify","setPassword","password","getUserToken","token","setPasswordUrl","internal","device","userId","headers","authorization","toString","schemas","update","displayName","verifyDefaults","services","collectPreauthCatalog","getClientToken","preloginId","shouldRefreshAccessToken","sso","getUserCI","lookupCI","verifyOptions","suppressEmail","userEntities","idBrokerUrl","idbroker","url","identityUrl","identity","entryUUID","entryEmail"],"mappings":"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","file":"user.js","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\nimport {deprecated, oneFlight, patterns, tap} from '@webex/common';\nimport {persist, WebexPlugin, waitForValue} from '@webex/webex-core';\n\nimport UserUUIDBatcher from './user-uuid-batcher';\nimport UserUUIDStore from './user-uuid-store';\n\n/**\n * @class\n */\nconst User = WebexPlugin.extend({\n  namespace: 'User',\n\n  children: {\n    batcher: UserUUIDBatcher\n  },\n\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  session: {\n    store: {\n      default() {\n        return new UserUUIDStore();\n      },\n      type: 'any'\n    }\n  },\n\n  @waitForValue('@')\n  /**\n   * Activates a Webex user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate(options = {}) {\n    if (!(options.verificationToken || (options.confirmationCode && options.id))) {\n      return Promise.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    }\n\n    options.scope = this.webex.config.credentials.scope;\n\n    // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n    const activateOptions = Object.assign({}, options);\n\n    delete activateOptions.email;\n\n    return this.request({\n      uri: this.webex.config.credentials.activationUrl,\n      method: 'POST',\n      body: activateOptions,\n      auth: {\n        user: this.webex.config.credentials.client_id,\n        pass: this.webex.config.credentials.client_secret,\n        sendImmediately: true\n      }\n    })\n      .then((res) => {\n        this.webex.credentials.set({supertoken: res.body.tokenData});\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID(user, options) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (isArray(user)) {\n      return Promise.all(user.map((u) => this.asUUID(u, options)));\n    }\n\n    const id = this._extractUUID(user);\n\n    if (!(options && options.force) && patterns.uuid.test(id)) {\n      return Promise.resolve(id);\n    }\n\n    const email = this._extractEmailAddress(user);\n\n    if (!patterns.email.test(email)) {\n      return Promise.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID(email, options) {\n    return this.batcher.request({\n      email,\n      create: options && options.create\n    })\n      .then((user) => this.recordUUID(Object.assign({emailAddress: email}, user))\n        .then(() => user.id));\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get() {\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    })\n      .then((res) => res.body)\n      .then(tap((user) => this.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      })));\n  },\n\n  /**\n   * Converts an email address to a uuid, perhaps by doing a network lookup\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  @oneFlight({keyFactory: (email, options) => email + String(options && options.create)})\n  getUUID(email, options) {\n    return this.store.getByEmail(email)\n      .then((user) => {\n        if (options && options.create && !user.userExists) {\n          return Promise.reject(new Error('User for specified email cannot be confirmed to exist'));\n        }\n\n        if (!user.id) {\n          return Promise.reject(new Error('No id recorded for specified user'));\n        }\n\n        return user.id;\n      })\n      .catch(() => this.fetchUUID(email, options));\n  },\n\n  @persist('@')\n  initialize(...args) {\n    return Reflect.apply(WebexPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID(user) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return Promise.reject(new Error('`user.id` is required'));\n    }\n\n    if (!patterns.uuid.test(user.id)) {\n      return Promise.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return Promise.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!patterns.email.test(user.emailAddress)) {\n      return Promise.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n\n  @deprecated('Use User#verify()')\n  register(...args) {\n    return this.verify(...args);\n  },\n\n  /**\n   * Updates a user's password with webex.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword(options) {\n    options = options || {};\n    if (!options.password) {\n      return Promise.reject(new Error('`options.password` is required'));\n    }\n\n    return this.webex.credentials.getUserToken()\n      .then((token) => this.request({\n        uri: `${this.webex.config.credentials.setPasswordUrl}/${this.webex.internal.device.userId}`,\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body: {\n          schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n          password: options.password\n        }\n      }))\n      .then((res) => {\n        this.hasPassword = true;\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update(options) {\n    options = options || {};\n    if (!options.displayName) {\n      return Promise.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify(options) {\n    options = Object.assign({}, this.config.verifyDefaults, options);\n    const {email} = options;\n\n    if (!email) {\n      return Promise.reject(new Error('`options.email` is required'));\n    }\n\n    return this.webex.internal.services.collectPreauthCatalog({email})\n      .then(() => this.webex.credentials.getUserToken())\n      .catch(() => this.webex.credentials.getClientToken())\n      .then((token) => this.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      }))\n      .then((res) => {\n        if (res.body.hasPassword || res.body.sso) {\n          this.hasPassword = true;\n        }\n\n        return res.body;\n      });\n  },\n\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      const verifyOptions = {\n        email,\n        suppressEmail: true\n      };\n\n      return this.verify(verifyOptions).then((res) => Promise.resolve(res.userEntities));\n    }\n\n    return Promise.resolve(\n      {\n        idBrokerUrl: this.webex.config.credentials.idbroker.url,\n        identityUrl: this.webex.config.credentials.identity.url\n      }\n    );\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  }\n\n});\n\nexport default User;\n"]}