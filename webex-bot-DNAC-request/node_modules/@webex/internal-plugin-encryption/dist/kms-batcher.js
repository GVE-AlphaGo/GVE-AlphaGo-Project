'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TIMEOUT_SYMBOL = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _symbol = require('babel-runtime/core-js/symbol');

var _symbol2 = _interopRequireDefault(_symbol);

var _commonTimers = require('@webex/common-timers');

var _webexCore = require('@webex/webex-core');

var _kmsErrors = require('./kms-errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TIMEOUT_SYMBOL = exports.TIMEOUT_SYMBOL = (0, _symbol2.default)('TIMEOUT_SYMBOL');

/**
 * @class
 */
/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

var KmsBatcher = _webexCore.Batcher.extend({
  namespace: 'Encryption',

  /**
   * Accepts a kmsMessage event and passes its contents to acceptItem
   * @param {Object} event
   * @returns {Promise}
   */
  processKmsMessageEvent: function processKmsMessageEvent(event) {
    var _this = this;

    this.logger.info('kms-batcher: received kms message');

    return _promise2.default.all(event.encryption.kmsMessages.map(function (kmsMessage) {
      return new _promise2.default(function (resolve) {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== 'production') {
          _this.logger.info('kms-batcher:', kmsMessage.body);
        }

        resolve(_this.acceptItem(kmsMessage));
      });
    }));
  },


  /**
   * Attaches a timeout to the given KMS message
   * @param {Object} item
   * @returns {Promise<Object>}
   */
  prepareItem: function prepareItem(item) {
    var _this2 = this;

    return this.getDeferredForRequest(item).then(function (defer) {
      var timeout = item[TIMEOUT_SYMBOL];

      /* istanbul ignore if */
      if (!timeout) {
        throw new Error('timeout is required');
      }

      var timer = (0, _commonTimers.safeSetTimeout)(function () {
        _this2.logger.warn('kms: request timed out; request id: ' + item.requestId + '; timeout: ' + timeout);
        _this2.handleItemFailure(item, new _kmsErrors.KmsTimeoutError({
          timeout: timeout,
          request: item
        }));
      }, timeout);

      // Reminder: reassign `promise` is not a viable means of inserting into
      // the Promise chain
      defer.promise.then(function () {
        return clearTimeout(timer);
      });
      defer.promise.catch(function () {
        return clearTimeout(timer);
      });

      return item;
    });
  },


  /**
   * Attaches the final bits of cluster info to the payload
   * @param {Array} queue
   * @returns {Promise<Array>}
   */
  prepareRequest: function prepareRequest(queue) {
    return this.webex.internal.encryption.kms._getKMSCluster().then(function (cluster) {
      return {
        destination: cluster,
        kmsMessages: queue.map(function (req) {
          return req.wrapped;
        })
      };
    });
  },


  /**
   * @param {Object} payload
   * @returns {Promise<HttpResponseObject>}
   */
  submitHttpRequest: function submitHttpRequest(payload) {
    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);

    return this.webex.request({
      method: 'POST',
      service: 'encryption',
      resource: '/kms/messages',
      body: payload
    });
  },


  /**
   * Does nothing; the http response doesn't carry our response data
   * @returns {Promise}
   */
  handleHttpSuccess: function handleHttpSuccess() {
    return _promise2.default.resolve();
  },


  /**
   * @param {Object} item
   * @returns {Promise<boolean>}
   */
  didItemFail: function didItemFail(item) {
    return _promise2.default.resolve(item.status >= 400);
  },


  /**
   * @param {Object} item
   * @returns {Promise}
   */
  handleItemSuccess: function handleItemSuccess(item) {
    return this.getDeferredForResponse(item).then(function (defer) {
      defer.resolve(item.body);
    });
  },


  /**
   * @param {Object} item
   * @param {KmsError} [reason]
   * @returns {Promise}
   */
  handleItemFailure: function handleItemFailure(item, reason) {
    return this.getDeferredForResponse(item).then(function (defer) {
      defer.reject(reason || new _kmsErrors.KmsError(item.body));
    });
  },


  /**
   * @param {Object} item
   * @returns {Promise}
   */
  fingerprintRequest: function fingerprintRequest(item) {
    return _promise2.default.resolve(item.requestId);
  },


  /**
   * @param {Object} item
   * @returns {Promise}
   */
  fingerprintResponse: function fingerprintResponse(item) {
    return _promise2.default.resolve(item.requestId);
  }
});

exports.default = KmsBatcher;
//# sourceMappingURL=kms-batcher.js.map
