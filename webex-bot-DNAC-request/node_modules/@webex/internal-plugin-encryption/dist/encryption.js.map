{"version":3,"sources":["encryption.js"],"names":["Encryption","WebexPlugin","extend","children","kms","KMS","namespace","processKmsMessageEvent","event","decryptBinary","scr","buffer","then","b","length","byteLength","reject","Error","decrypt","decryptScr","key","cipherScr","options","getKey","k","SCR","fromJWE","jwk","decryptText","ciphertext","jose","JWE","createDecrypt","result","plaintext","toString","download","loc","shunt","EventEmitter","promise","_fetchDownloadUrl","uri","method","responseType","ret","request","res","body","logger","info","process","env","NODE_ENV","includes","resolve","inputBody","endpoints","endpointUrl","url","parse","protocol","pathname","format","allow","params","warn","encryptBinary","file","create","encrypt","ensureBuffer","cdata","encryptScr","toJWE","encryptText","createEncrypt","config","joseOptions","header","alg","reference","final","onBehalfOf","asKey","storageKey","unboundedStorage","get","keyString","JSON","keyObject","catch","fetchKey","put","replacer","v","json","toJSON"],"mappings":"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","file":"encryption.js","sourcesContent":["/*!\n * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {EventEmitter} from 'events';\nimport url from 'url';\n\nimport {WebexPlugin} from '@webex/webex-core';\nimport {proxyEvents, tap, transferEvents} from '@webex/common';\nimport jose from 'node-jose';\nimport SCR from 'node-scr';\n\nimport ensureBuffer from './ensure-buffer';\nimport KMS from './kms';\n\nconst Encryption = WebexPlugin.extend({\n  children: {\n    kms: KMS\n  },\n\n  namespace: 'Encryption',\n\n  processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n\n  decryptBinary(scr, buffer) {\n    return ensureBuffer(buffer)\n      .then((b) => {\n        /* istanbul ignore if */\n        if (buffer.length === 0 || buffer.byteLength === 0) {\n          return Promise.reject(new Error('Attempted to decrypt zero-length buffer'));\n        }\n\n        return scr.decrypt(b);\n      });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options)\n      .then((k) => SCR.fromJWE(k.jwk, cipherScr));\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText(key, ciphertext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createDecrypt(k.jwk)\n        .decrypt(ciphertext)\n        .then((result) => result.plaintext.toString()));\n  },\n\n  /**\n   * Validate and initiate a Download request for requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise}\n   */\n  download(scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('`scr.loc` is required'));\n    }\n\n    const shunt = new EventEmitter();\n    const promise = this._fetchDownloadUrl(scr, options)\n      .then((uri) => {\n        const options = {\n          method: 'GET',\n          uri,\n          responseType: 'buffer'\n        };\n\n        const ret = this.request(options);\n\n        transferEvents('progress', options.download, shunt);\n\n        return ret;\n      })\n      .then((res) => this.decryptBinary(scr, res.body));\n\n    proxyEvents(shunt, promise);\n\n    return promise;\n  },\n\n  /**\n   * Fetch Download URL for the requested file\n   *\n   * @param {Object} scr - Plaintext\n   * @param {Object} options - optional paramaters to download a file\n   * @returns {promise} url of the downloadable file\n   */\n  _fetchDownloadUrl(scr, options) {\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing webex files because this looks to be a test file on localhost');\n\n      return Promise.resolve(scr.loc);\n    }\n\n    const inputBody = {\n      endpoints: [scr.loc]\n    };\n    const endpointUrl = url.parse(scr.loc);\n\n    // hardcode the url to use 'https' and the file service '/v1/download/endpoints' api\n    endpointUrl.protocol = 'https';\n    endpointUrl.pathname = '/v1/download/endpoints';\n\n    return this.request({\n      method: 'POST',\n      uri: url.format(endpointUrl),\n      body: options ? {\n        ...inputBody,\n        allow: options.params.allow\n      } : inputBody\n    })\n      .then((res) => {\n        const url = res.body.endpoints[scr.loc];\n\n        if (!url) {\n          this.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n          return scr.loc;\n        }\n        this.logger.info('encryption: retrieved download url for encrypted file');\n\n        return url;\n      });\n  },\n\n  encryptBinary(file) {\n    return ensureBuffer(file)\n      .then((buffer) => SCR.create()\n        .then((scr) => scr.encrypt(buffer)\n          .then(ensureBuffer)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((cdata) => ({scr, cdata}))));\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options)\n      .then((k) => scr.toJWE(k.jwk));\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText(key, plaintext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createEncrypt(this.config.joseOptions, {\n          key: k.jwk,\n          header: {\n            alg: 'dir'\n          },\n          reference: null\n        })\n        .final(plaintext, 'utf8'));\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey(uri, {onBehalfOf} = {}) {\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    let storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += `/onBehalfOf/${onBehalfOf}`;\n    }\n\n    return this.unboundedStorage.get(storageKey)\n      .then((keyString) => JSON.parse(keyString))\n      .then((keyObject) => this.kms.asKey(keyObject))\n      .catch(() => this.kms.fetchKey({uri, onBehalfOf})\n        .then(tap((key) => this.unboundedStorage.put(storageKey, JSON.stringify(key, replacer)))));\n  }\n});\n\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    const json = this[k].toJSON(true);\n\n    return json;\n  }\n\n  return v;\n}\n\nexport default Encryption;\n"]}