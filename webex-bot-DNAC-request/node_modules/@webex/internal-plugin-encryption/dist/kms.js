'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _dec, _desc, _value, _obj; /*!
                                * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
                                */

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _commonTimers = require('@webex/common-timers');

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _nodeKms = require('node-kms');

var _nodeJose = require('node-jose');

var _nodeJose2 = _interopRequireDefault(_nodeJose);

var _kmsBatcher = require('./kms-batcher');

var _kmsBatcher2 = _interopRequireDefault(_kmsBatcher);

var _kmsCertificateValidation = require('./kms-certificate-validation');

var _kmsCertificateValidation2 = _interopRequireDefault(_kmsCertificateValidation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var contexts = new _weakMap2.default();
var kmsDetails = new _weakMap2.default();
var partialContexts = new _weakMap2.default();

var consoleDebug = require('debug')('kms');

/**
 * @class
 */
var KMS = _webexCore.WebexPlugin.extend((_dec = (0, _common.oneFlight)({
  keyFactory: function keyFactory(_ref) {
    var uri = _ref.uri,
        onBehalfOf = _ref.onBehalfOf;
    return uri + '/' + onBehalfOf;
  }
}), (_obj = {
  namespace: 'Encryption',

  children: {
    batcher: _kmsBatcher2.default
  },

  /**
   * Binds a key to a resource
   * @param {Object} options
   * @param {KMSResourceObject} options.kro
   * @param {string} options.kroUri
   * @param {Key} options.key
   * @param {string} options.keyUri
   * @returns {Promise<Key>}
   */
  bindKey: function bindKey(_ref2) {
    var _this = this;

    var kro = _ref2.kro,
        kroUri = _ref2.kroUri,
        key = _ref2.key,
        keyUri = _ref2.keyUri;

    kroUri = kroUri || kro.uri;
    keyUri = keyUri || key.uri;

    this.logger.info('kms: binding key to resource');

    /* istanbul ignore if */
    if (!kroUri) {
      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));
    }

    /* istanbul ignore if */
    if (!keyUri) {
      return _promise2.default.reject(new Error('`key` or `keyUri` is required'));
    }

    return this.request({
      method: 'update',
      resourceUri: kroUri,
      uri: keyUri
    }).then(function (res) {
      _this.logger.info('kms: bound key to resource');

      return res.key;
    });
  },


  /**
   * Creates a new KMS Resource
   * @param {Object} options
   * @param {Array<string>} options.userIds
   * @param {Array<string>} options.keyUris
   * @param {Key} options.key
   * @param {Array<Keys>} options.keys
   * @returns {Promise<KMSResourceObject>}
   */
  createResource: function createResource(_ref3) {
    var _this2 = this;

    var userIds = _ref3.userIds,
        keyUris = _ref3.keyUris,
        key = _ref3.key,
        keys = _ref3.keys;

    keyUris = keyUris || [];
    /* istanbul ignore if */
    if (keys) {
      keyUris = keys.reduce(function (uris, k) {
        uris.push(k.uri);

        return uris;
      }, keyUris);
    }

    /* istanbul ignore else */
    if (key) {
      keyUris.push(key.uri);
    }

    /* istanbul ignore if */
    if (keyUris.length === 0) {
      return _promise2.default.reject(new Error('Cannot create KMS Resource without at least one keyUri'));
    }

    this.logger.info('kms: creating resource');

    return this.request({
      method: 'create',
      uri: '/resources',
      userIds: userIds,
      keyUris: keyUris
    }).then(function (res) {
      _this2.logger.info('kms: created resource');

      return res.resource;
    });
  },


  /**
   * Authorizes a user or KRO to a KRO
   * @param {Object} options
   * @param {Array<string>} options.userIds
   * @param {Array<string>} options.authIds interchangable with userIds
   * @param {KMSResourceObject} options.kro the target kro
   * @param {string} options.kroUri
   * @returns {Promise<KMSAuthorizationObject>}
   */
  addAuthorization: function addAuthorization(_ref4) {
    var _this3 = this;

    var userIds = _ref4.userIds,
        authIds = _ref4.authIds,
        kro = _ref4.kro,
        kroUri = _ref4.kroUri;

    userIds = userIds || [];
    kroUri = kroUri || kro.uri;

    if (authIds) {
      userIds = userIds.concat(authIds);
    }

    /* istanbul ignore if */
    if (userIds.length === 0) {
      return _promise2.default.reject(new Error('Cannot add authorization without userIds or authIds'));
    }

    /* istanbul ignore if */
    if (!kroUri) {
      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));
    }

    this.logger.info('kms: adding authorization to kms resource');

    return this.request({
      method: 'create',
      uri: '/authorizations',
      resourceUri: kroUri,
      userIds: userIds
    }).then(function (res) {
      _this3.logger.info('kms: added authorization');

      return res.authorizations;
    });
  },


  /**
   * Retrieve a list of users that have been authorized to the KRO
   * @param {Object} options
   * @param {KMSResourceObject} options.kro the target kro
   * @param {string} options.kroUri
   * @returns {Array<authId>}
   */
  listAuthorizations: function listAuthorizations(_ref5) {
    var _this4 = this;

    var kro = _ref5.kro,
        kroUri = _ref5.kroUri;

    kroUri = kroUri || kro.uri;
    /* istanbul ignore if */
    if (!kroUri) {
      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));
    }

    return this.request({
      method: 'retrieve',
      uri: kroUri + '/authorizations'
    }).then(function (res) {
      _this4.logger.info('kms: retrieved authorization list');

      return res.authorizations;
    });
  },


  /**
   * Deauthorizes a user or KRO from a KRO
   * @param {Object} options
   * @param {string} options.userId
   * @param {string} options.authId interchangable with userIds
   * @param {KMSResourceObject} options.kro the target kro
   * @param {string} options.kroUri
   * @returns {Promise<KMSAuthorizationObject>}
   */
  removeAuthorization: function removeAuthorization(_ref6) {
    var _this5 = this;

    var authId = _ref6.authId,
        userId = _ref6.userId,
        kro = _ref6.kro,
        kroUri = _ref6.kroUri;

    authId = authId || userId;
    kroUri = kroUri || kro.uri;

    /* istanbul ignore if */
    if (!authId) {
      return _promise2.default.reject(new Error('Cannot remove authorization without authId'));
    }

    /* istanbul ignore if */
    if (!kroUri) {
      return _promise2.default.reject(new Error('`kro` or `kroUri` is required'));
    }

    this.logger.info('kms: removing authorization from kms resource');

    return this.request({
      method: 'delete',
      uri: kroUri + '/authorizations?' + _querystring2.default.stringify({ authId: authId })
    }).then(function (res) {
      _this5.logger.info('kms: removed authorization');

      return res.authorizations;
    });
  },


  /**
   * Requests `count` unbound keys from the kms
   * @param {Object} options
   * @param {Number} options.count
   * @returns {Array<Key>}
   */
  createUnboundKeys: function createUnboundKeys(_ref7) {
    var _this6 = this;

    var count = _ref7.count;

    this.logger.info('kms: request ' + count + ' unbound keys');

    /* istanbul ignore if */
    if (!count) {
      return _promise2.default.reject(new Error('`options.count` is required'));
    }

    return this.request({
      method: 'create',
      uri: '/keys',
      count: count
    }).then(function (res) {
      _this6.logger.info('kms: received unbound keys');

      return _promise2.default.all(res.keys.map(_this6.asKey));
    });
  },
  fetchKey: function fetchKey(_ref8) {
    var _this7 = this;

    var uri = _ref8.uri,
        onBehalfOf = _ref8.onBehalfOf;

    /* istanbul ignore if */
    if (!uri) {
      return _promise2.default.reject(new Error('`options.uri` is required'));
    }

    this.logger.info('kms: fetching key');

    return this.request({
      method: 'retrieve',
      uri: uri
    }, { onBehalfOf: onBehalfOf }).then(function (res) {
      _this7.logger.info('kms: fetched key');

      return _this7.asKey(res.key);
    });
  },


  /**
   * Pings the kms. Mostly for testing
   * @returns {Promise}
   */
  ping: function ping() {
    return this.request({
      method: 'update',
      uri: '/ping'
    });
  },


  /**
   * Ensures a key obect is Key instance
   * @param {Object} key
   * @returns {Promise<Key>}
   */
  asKey: function asKey(key) {
    return _nodeJose2.default.JWK.asKey(key.jwk).then(function (jwk) {
      key.jwk = jwk;

      return key;
    });
  },


  /**
   * Adds appropriate metadata to the KMS request
   * @param {Object} payload
   * @param {Object} onBehalfOf Optional parameter to prepare the request on behalf of another user
   * @returns {Promise<KMS.Request>}
   */
  prepareRequest: function prepareRequest(payload, onBehalfOf) {
    var _this8 = this;

    var isECDHRequest = payload.method === 'create' && payload.uri.includes('/ecdhe');

    return _promise2.default.resolve(isECDHRequest ? partialContexts.get(this) : this._getContext()).then(function (context) {
      _this8.logger.info('kms: wrapping ' + (isECDHRequest ? 'ephemeral key' : 'kms') + ' request');
      var req = new _nodeKms.Request(payload);
      var requestContext = context;

      if (onBehalfOf) {
        requestContext = _this8._contextOnBehalfOf(context, onBehalfOf);
      }

      return req.wrap(requestContext, { serverKey: isECDHRequest }).then(function () {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== 'production') {
          _this8.logger.info('kms: request payload', _util2.default.inspect((0, _omit3.default)(JSON.parse((0, _stringify2.default)(req)), 'wrapped'), { depth: null }));
        }

        return req;
      });
    });
  },


  /**
   * Accepts a kms message event, decrypts it, and passes it to the batcher
   * @param {Object} event
   * @returns {Promise<Object>}
   */
  processKmsMessageEvent: function processKmsMessageEvent(event) {
    var _this9 = this;

    this.logger.info('kms: received kms message');

    return _promise2.default.all(event.encryption.kmsMessages.map(function (kmsMessage, index) {
      return _this9._isECDHEMessage(kmsMessage).then(function (isECDHMessage) {
        _this9.logger.info('kms: received ' + (isECDHMessage ? 'ecdhe' : 'normal') + ' message');
        var res = new _nodeKms.Response(kmsMessage);

        return _promise2.default.resolve(isECDHMessage ? partialContexts.get(_this9) : contexts.get(_this9))
        // eslint-disable-next-line max-nested-callbacks
        .then(function (context) {
          return res.unwrap(context);
        })
        // eslint-disable-next-line max-nested-callbacks
        .then(function () {
          if (process.env.NODE_ENV !== 'production') {
            _this9.logger.info('kms: response payload', _util2.default.inspect((0, _omit3.default)(JSON.parse((0, _stringify2.default)(res)), 'wrapped'), { depth: null }));
          }
        })
        // eslint-disable-next-line max-nested-callbacks
        .then(function () {
          event.encryption.kmsMessages[index] = res;
        })
        // eslint-disable-next-line max-nested-callbacks
        .then(function () {
          return res;
        });
      });
    })).then(function () {
      return _this9.batcher.processKmsMessageEvent(event);
    }).catch(function (reason) {
      _this9.logger.error('kms: decrypt failed', reason.stack);

      return _promise2.default.reject(reason);
    }).then(function () {
      return event;
    });
  },


  /**
   * Decrypts a kms message
   * @param {Object} kmsMessage
   * @returns {Promise<Object>}
   */
  decryptKmsMessage: function decryptKmsMessage(kmsMessage) {
    var res = new _nodeKms.Response(kmsMessage);

    return contexts.get(this).then(function (context) {
      return res.unwrap(context);
    }).then(function () {
      return res.body;
    });
  },


  /**
   * Determines if the kms message is an ecdhe message or a normal message
   * @param {Object} kmsMessage
   * @returns {Promise<boolean>}
   */
  _isECDHEMessage: function _isECDHEMessage(kmsMessage) {
    return this._getKMSStaticPubKey().then(function (kmsStaticPubKey) {
      var fields = kmsMessage.split('.');

      if (fields.length !== 3) {
        return false;
      }

      var header = JSON.parse(_nodeJose2.default.util.base64url.decode(fields[0]));

      return header.kid === kmsStaticPubKey.kid;
    });
  },


  /**
   * Sends a request to the kms
   * @param {Object} payload
   * @param {Object} options
   * @param {Number} options.timeout (internal)
   * @param {string} options.onBehalfOf Run the request on behalf of another user (UUID), used in compliance scenarios
   * @returns {Promise<Object>}
   */
  request: function request(payload) {
    var _this10 = this;

    var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        timeout = _ref9.timeout,
        onBehalfOf = _ref9.onBehalfOf;

    timeout = timeout || this.config.kmsInitialTimeout;

    // Note: this should only happen when we're using the async kms batcher;
    // once we implement the sync batcher, this'll need to be smarter.
    return this.webex.internal.mercury.connect().then(function () {
      return _this10.prepareRequest(payload, onBehalfOf);
    }).then(function (req) {
      req[_kmsBatcher.TIMEOUT_SYMBOL] = timeout;

      return _this10.batcher.request(req);
    })
    // High complexity is due to attempt at test mode resiliency
    // eslint-disable-next-line complexity
    .catch(function (reason) {
      if (process.env.NODE_ENV === 'test' && (reason.status === 403 || reason.statusCode === 403) && reason.message.match(/Failed to resolve authorization token in KmsMessage request for user/)) {
        _this10.logger.warn('kms: rerequested key due to test-mode kms auth failure');

        return _this10.request(payload, { onBehalfOf: onBehalfOf });
      }

      // KMS Error. Notify the user
      if (reason instanceof _kmsCertificateValidation.KMSError) {
        _this10.webex.trigger('client:InvalidRequestError');

        return _promise2.default.reject(reason);
      }

      // Ideally, most or all of the code below would go in kms-batcher, but
      // but batching needs at least one more round of refactoring for that to
      // work.
      if (!reason.statusCode && !reason.status) {
        /* istanbul ignore else */
        if (process.env.NODE_ENV !== 'production') {
          /* istanbul ignore next: reason.stack vs stack difficult to control in test */
          _this10.logger.info('kms: request error', reason.stack || reason);
        }

        consoleDebug('timeout ' + timeout);
        timeout *= 2;

        if (timeout >= _this10.config.ecdhMaxTimeout) {
          _this10.logger.info('kms: exceeded maximum KMS request retries');

          return _promise2.default.reject(reason);
        }

        // Peek ahead to make sure we don't reset the timeout if the next timeout
        // will exceed the maximum timeout for renegotiating ECDH keys.
        var nextTimeout = timeout * 2;

        if (timeout >= _this10.config.kmsMaxTimeout && nextTimeout < _this10.config.ecdhMaxTimeout) {
          _this10.logger.info('kms: exceeded maximum KMS request retries; negotiating new ecdh key');

          /* istanbul ignore else */
          if (process.env.NODE_ENV !== 'production') {
            _this10.logger.info('kms: timeout/maxtimeout', timeout, _this10.config.kmsMaxTimeout);
          }

          contexts.delete(_this10);
          timeout = 0;
        }

        return _this10.request(payload, { timeout: timeout, onBehalfOf: onBehalfOf });
      }

      return _promise2.default.reject(reason);
    });
  },


  /**
   * @private
   * @returns {Promise<string>}
   */
  _getAuthorization: function _getAuthorization() {
    return this.webex.credentials.getUserToken('spark:kms').then(function (token) {
      return token.access_token;
    });
  },

  /**
   * @private
   * @param {String} onBehalfOf create context on behalf of another user, undefined when this is not necessary
   * @returns {Promise<Object>}
   */
  _getContext: function _getContext() {
    var _this11 = this;

    var promise = contexts.get(this);

    if (!promise) {
      promise = this._prepareContext();
      contexts.set(this, promise);
      promise.then(function (context) {
        var expiresIn = context.ephemeralKey.expirationDate - Date.now() - 30000;

        (0, _commonTimers.safeSetTimeout)(function () {
          return contexts.delete(_this11);
        }, expiresIn);
      });
    }

    return _promise2.default.all([promise, this._getAuthorization()]).then(function (_ref10) {
      var _ref11 = (0, _slicedToArray3.default)(_ref10, 2),
          context = _ref11[0],
          authorization = _ref11[1];

      context.clientInfo.credential.bearer = authorization;

      return context;
    });
  },


  /**
   * @private
   * @returns {Promise<Object>}
   */
  _getKMSCluster: function _getKMSCluster() {
    this.logger.info('kms: retrieving KMS cluster');

    return this._getKMSDetails().then(function (_ref12) {
      var kmsCluster = _ref12.kmsCluster;
      return kmsCluster;
    });
  },


  /**
   * @private
   * @returns {Promise<Object>}
   */
  _getKMSDetails: function _getKMSDetails() {
    var _this12 = this;

    var details = kmsDetails.get(this);

    if (!details) {
      this.logger.info('kms: fetching KMS details');
      details = this.webex.request({
        service: 'encryption',
        resource: '/kms/' + this.webex.internal.device.userId
      }).then(function (res) {
        _this12.logger.info('kms: fetched KMS details');
        var body = res.body;


        body.rsaPublicKey = JSON.parse(body.rsaPublicKey);

        return body;
      }).catch(function (reason) {
        _this12.logger.error('kms: failed to fetch KMS details', reason);

        return _promise2.default.reject(reason);
      });

      kmsDetails.set(this, details);
    }

    return details;
  },


  /**
   * @private
   * @returns {Promise<Object>}
   */
  _getKMSStaticPubKey: function _getKMSStaticPubKey() {
    this.logger.info('kms: retrieving KMS static public key');

    return this._getKMSDetails().then(function (_ref13) {
      var rsaPublicKey = _ref13.rsaPublicKey;
      return rsaPublicKey;
    });
  },


  /**
   * @private
   * @returns {Promise<Object>}
   */
  _prepareContext: function _prepareContext() {
    var _this13 = this;

    this.logger.info('kms: creating context');
    var context = new _nodeKms.Context();

    return _promise2.default.all([this._getKMSStaticPubKey().then((0, _kmsCertificateValidation2.default)(this.config.caroots)), this._getAuthorization()]).then(function (_ref14) {
      var _ref15 = (0, _slicedToArray3.default)(_ref14, 2),
          kmsStaticPubKey = _ref15[0],
          authorization = _ref15[1];

      context.clientInfo = {
        clientId: _this13.webex.internal.device.url,
        credential: {
          userId: _this13.webex.internal.device.userId,
          bearer: authorization
        }
      };

      context.serverInfo = {
        key: kmsStaticPubKey
      };

      _this13.logger.info('kms: creating local ephemeral key');

      return context.createECDHKey();
    }).then(function (localECDHKey) {
      context.ephemeralKey = localECDHKey;
      partialContexts.set(_this13, context);

      return _promise2.default.all([localECDHKey.asKey(), _this13._getKMSCluster()]);
    }).then(function (_ref16) {
      var _ref17 = (0, _slicedToArray3.default)(_ref16, 2),
          localECDHKey = _ref17[0],
          cluster = _ref17[1];

      _this13.logger.info('kms: submitting ephemeral key request');

      return _this13.request({
        uri: cluster + '/ecdhe',
        method: 'create',
        jwk: localECDHKey.toJSON()
      });
    }).then(function (res) {
      _this13.logger.info('kms: deriving final ephemeral key');

      return context.deriveEphemeralKey(res.key);
    }).then(function (key) {
      context.ephemeralKey = key;
      partialContexts.delete(_this13);
      _this13.logger.info('kms: derived final ephemeral key');

      return context;
    }).catch(function (reason) {
      _this13.logger.error('kms: failed to negotiate ephemeral key', reason);

      return _promise2.default.reject(reason);
    });
  },


  /**
   * KMS 'retrieve' requests can be made on behalf of another user. This is useful
   * for scenarios such as eDiscovery. i.e. Where an authorized compliance officer is
   * entitled to retrieve content generated by any organisational user.
   * As the KMSContext is cached, updating it will affect separate requests. Hence when
   * making a request onBehalfOf another user create a new context for just this request.
   * However this context will be 'light' as it only needs to change one field.
   * @param {Object} originalContext - The base context to 'copy'
   * @param {String} onBehalfOf - The user specified in the new context
   * @returns {Context} A 'copy' of the existing context with a new user specified
   * @private
   */
  _contextOnBehalfOf: function _contextOnBehalfOf(originalContext, onBehalfOf) {
    var context = new _nodeKms.Context();

    context.clientInfo = context.clientInfo = {
      clientId: originalContext.clientInfo.clientId,
      credential: {
        userId: onBehalfOf,
        bearer: originalContext.clientInfo.credential.bearer
      }
    };
    context.serverInfo = originalContext.serverInfo;
    context.ephemeralKey = originalContext.ephemeralKey;

    return context;
  },
  version: '1.80.147'
}, (_applyDecoratedDescriptor(_obj, 'fetchKey', [_dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'fetchKey'), _obj), _applyDecoratedDescriptor(_obj, '_getContext', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_getContext'), _obj)), _obj)));

exports.default = KMS;
//# sourceMappingURL=kms.js.map
