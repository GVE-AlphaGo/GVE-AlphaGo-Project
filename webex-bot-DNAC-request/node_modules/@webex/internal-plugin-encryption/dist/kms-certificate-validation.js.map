{"version":3,"sources":["kms-certificate-validation.js"],"names":["webcrypto","Crypto","CryptoEngine","name","crypto","subtle","VALID_KTY","VALID_KID_PROTOCOL","X509_COMMON_NAME_KEY","X509_SUBJECT_ALT_NAME_KEY","KMSError","message","kmsError","Error","throwError","err","decodeCert","pem","der","Buffer","from","ber","Uint8Array","buffer","asn1","Certificate","schema","result","validateKtyHeader","kty","validateKidHeader","kid","protocol","validateCommonName","certificate","kidHostname","hostname","validationSuccessful","extensions","extension","extnID","altNames","parsedValue","entry","san","value","subjectAttributes","subject","typesAndValues","attribute","type","commonName","valueBlock","validatePublicCertificate","publicExponent","e","modulus","n","encode","jose","util","base64url","publicKey","subjectPublicKeyInfo","subjectPublicKey","asn1PublicCert","valueHex","publicCert","RSAPublicKey","publicExponentHex","modulusHex","validateCertificatesSignature","certificates","caroots","certificateEngine","CertificateChainValidationEngine","trustedCerts","map","certs","verify","then","resultCode","resultMessage","validateKMS","jwt","resolve","x5c","length","promise"],"mappings":"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","file":"kms-certificate-validation.js","sourcesContent":["import {parse as parseUrl} from 'url';\n\nimport {isUri} from 'valid-url';\nimport {fromBER} from 'asn1js';\nimport {\n  Certificate,\n  RSAPublicKey,\n  CertificateChainValidationEngine,\n  CryptoEngine,\n  setEngine\n} from 'pkijs';\nimport {isArray} from 'lodash';\nimport jose from 'node-jose';\nimport {Crypto} from '@peculiar/webcrypto';\n\nconst webcrypto = new Crypto();\n\nsetEngine(\n  'newEngine',\n  webcrypto,\n  new CryptoEngine({name: '', crypto: webcrypto, subtle: webcrypto.subtle})\n);\n\nconst VALID_KTY = 'RSA';\nconst VALID_KID_PROTOCOL = 'kms:';\n\nconst X509_COMMON_NAME_KEY = '2.5.4.3';\n\nconst X509_SUBJECT_ALT_NAME_KEY = '2.5.29.17';\n\n/**\n * Customize Error so the SDK knows to quit retrying and notify\n * the user\n */\nexport class KMSError extends Error {\n  /**\n   * add kmsError field to notify\n   * @param {string} message\n   */\n  constructor(message) {\n    super(message);\n    this.kmsError = true;\n  }\n}\n\nconst throwError = (err) => {\n  throw new KMSError(`INVALID KMS: ${err}`);\n};\n\n/**\n * Converts the PEM string to a pkijs certificate object\n * @param {string} pem PEM representation of a certificate\n * @returns {Certificate} pkijs object of the certificate\n */\nconst decodeCert = (pem) => {\n  if (typeof pem !== 'string') {\n    throwError('certificate needs to be a string');\n  }\n\n  const der = Buffer.from(pem, 'base64');\n  const ber = new Uint8Array(der).buffer;\n\n  const asn1 = fromBER(ber);\n\n  return new Certificate({schema: asn1.result});\n};\n\n/**\n * Validate the 'kty' property of the KMS credentials\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kty type of certificate\n * @throws {KMSError} if kty is not a valid type\n * @returns {void}\n */\nconst validateKtyHeader = ({kty}) => {\n  if (kty !== VALID_KTY) {\n    throwError(`'kty' header must be '${VALID_KTY}'`);\n  }\n};\n\nconst validateKidHeader = ({kid}) => {\n  if (!isUri(kid)) {\n    throwError('\\'kid\\' is not a valid URI');\n  }\n\n  if (parseUrl(kid).protocol !== VALID_KID_PROTOCOL) {\n    throwError(`'kid' protocol must be '${VALID_KID_PROTOCOL}'`);\n  }\n};\n\n/**\n * Checks the first certificate matches the 'kid' in the JWT.\n * It first checks the Subject Alternative Name then it checks\n * the Common Name\n * @param {Certificate} certificate represents the KMS\n * @param {Object} JWT KMS credentials\n * @param {string} JWT.kid the uri of the KMS\n * @throws {KMSError} if unable to validate certificate against KMS credentials\n * @returns {void}\n */\nconst validateCommonName = ([certificate], {kid}) => {\n  const kidHostname = parseUrl(kid).hostname;\n  let validationSuccessful = false;\n\n  if (certificate.extensions) {\n    // Subject Alt Names are in here\n    for (const extension of certificate.extensions) {\n      if (extension.extnID === X509_SUBJECT_ALT_NAME_KEY) {\n        const {altNames} = extension.parsedValue;\n\n        for (const entry of altNames) {\n          const san = entry.value;\n\n          validationSuccessful = san === kidHostname;\n          if (validationSuccessful) {\n            break;\n          }\n        }\n\n        if (validationSuccessful) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (!validationSuccessful) {\n    // Didn't match kid in the Subject Alt Names, checking the Common Name\n    const subjectAttributes = certificate.subject.typesAndValues;\n\n    for (const attribute of subjectAttributes) {\n      if (attribute.type === X509_COMMON_NAME_KEY) {\n        const commonName = attribute.value.valueBlock.value;\n\n        validationSuccessful = commonName === kidHostname;\n        if (validationSuccessful) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (!validationSuccessful) {\n    throwError('hostname of the 1st certificate does not match \\'kid\\'');\n  }\n};\n\n/**\n * Validate the first KMS certificate against the information\n * provided in the JWT\n * @param {Certificate} certificate first certificate the identifies the KMS\n * @param {Object} JWT credentials of the KMS\n * @param {string} JWT.e Public exponent of the first certificate\n * @param {string} KWT.n Modulus of the first certificate\n * @throws {KMSError} if e or n doesn't match the first certificate\n * @returns {void}\n */\nconst validatePublicCertificate =\n  ([certificate], {e: publicExponent, n: modulus}) => {\n    const {encode} = jose.util.base64url;\n\n    const publicKey = certificate.subjectPublicKeyInfo.subjectPublicKey;\n    const asn1PublicCert = fromBER(publicKey.valueBlock.valueHex);\n    const publicCert = new RSAPublicKey({schema: asn1PublicCert.result});\n    const publicExponentHex = publicCert.publicExponent.valueBlock.valueHex;\n    const modulusHex = publicCert.modulus.valueBlock.valueHex;\n\n    if (publicExponent !== encode(publicExponentHex)) {\n      throwError('Public exponent is invalid');\n    }\n    if (modulus !== encode(modulusHex)) {\n      throwError('Modulus is invalid');\n    }\n  };\n\n/**\n * Validates the list of certificates against the CAs provided\n * @param {certificate[]} certificates list of certificates provided\n *   by the KMS to certify itself\n * @param {string[]} [caroots=[]] list of Certificate Authorities used to\n *   validate the KMS's certificates\n * @returns {Promise} rejects if unable to validate the certificates\n */\nconst validateCertificatesSignature = (certificates, caroots = []) => {\n  const certificateEngine = new CertificateChainValidationEngine({\n    trustedCerts: caroots.map(decodeCert),\n    certs: certificates\n  });\n\n  return certificateEngine.verify()\n    .then(({result, resultCode, resultMessage}) => {\n      if (!result) {\n        throwError(\n          `Certificate Validation failed [${resultCode}]: ${resultMessage}`\n        );\n      }\n    });\n};\n\n/**\n * Validates the information provided by the KMS. This is a curried function.\n * The first function takes the caroots param and returns a second function.\n * The second function takes the credentials of the KMS and validates it\n * @param {string[]} caroots PEM encoded certificates that will be used\n *   as Certificate Authorities\n * @param {Object} jwt Object containing the fields necessary to\n *   validate the KMS\n * @returns {Promise} when resolved will return the jwt\n */\nconst validateKMS = (caroots) => (jwt = {}) => Promise.resolve()\n  .then(() => {\n    validateKtyHeader(jwt);\n    validateKidHeader(jwt);\n\n    if (!(isArray(jwt.x5c) && jwt.x5c.length > 0)) {\n      throwError('JWK does not contain a list of certificates');\n    }\n    const certificates = jwt.x5c.map(decodeCert);\n\n    validateCommonName(certificates, jwt);\n    validatePublicCertificate(certificates, jwt);\n\n    // Skip validating signatures if no CA roots were provided\n    const promise = caroots ?\n      validateCertificatesSignature(certificates, caroots) : Promise.resolve();\n\n    return promise\n      .then(() => jwt);\n  });\n\nexport default validateKMS;\n"]}