'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KMSError = undefined;

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _setPrototypeOf = require('babel-runtime/core-js/object/set-prototype-of');

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _construct = require('babel-runtime/core-js/reflect/construct');

var _construct2 = _interopRequireDefault(_construct);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _url = require('url');

var _validUrl = require('valid-url');

var _asn1js = require('asn1js');

var _pkijs = require('pkijs');

var _nodeJose = require('node-jose');

var _nodeJose2 = _interopRequireDefault(_nodeJose);

var _webcrypto = require('@peculiar/webcrypto');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = (0, _construct2.default)(cls, (0, _from2.default)(arguments));
    (0, _setPrototypeOf2.default)(instance, (0, _getPrototypeOf2.default)(this));
    return instance;
  }

  ExtendableBuiltin.prototype = (0, _create2.default)(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (_setPrototypeOf2.default) {
    (0, _setPrototypeOf2.default)(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

var webcrypto = new _webcrypto.Crypto();

(0, _pkijs.setEngine)('newEngine', webcrypto, new _pkijs.CryptoEngine({ name: '', crypto: webcrypto, subtle: webcrypto.subtle }));

var VALID_KTY = 'RSA';
var VALID_KID_PROTOCOL = 'kms:';

var X509_COMMON_NAME_KEY = '2.5.4.3';

var X509_SUBJECT_ALT_NAME_KEY = '2.5.29.17';

/**
 * Customize Error so the SDK knows to quit retrying and notify
 * the user
 */

var KMSError = exports.KMSError = function (_extendableBuiltin2) {
  (0, _inherits3.default)(KMSError, _extendableBuiltin2);

  /**
   * add kmsError field to notify
   * @param {string} message
   */
  function KMSError(message) {
    (0, _classCallCheck3.default)(this, KMSError);

    var _this = (0, _possibleConstructorReturn3.default)(this, (KMSError.__proto__ || (0, _getPrototypeOf2.default)(KMSError)).call(this, message));

    _this.kmsError = true;
    return _this;
  }

  return KMSError;
}(_extendableBuiltin(Error));

var throwError = function throwError(err) {
  throw new KMSError('INVALID KMS: ' + err);
};

/**
 * Converts the PEM string to a pkijs certificate object
 * @param {string} pem PEM representation of a certificate
 * @returns {Certificate} pkijs object of the certificate
 */
var decodeCert = function decodeCert(pem) {
  if (typeof pem !== 'string') {
    throwError('certificate needs to be a string');
  }

  var der = Buffer.from(pem, 'base64');
  var ber = new Uint8Array(der).buffer;

  var asn1 = (0, _asn1js.fromBER)(ber);

  return new _pkijs.Certificate({ schema: asn1.result });
};

/**
 * Validate the 'kty' property of the KMS credentials
 * @param {Object} JWT KMS credentials
 * @param {string} JWT.kty type of certificate
 * @throws {KMSError} if kty is not a valid type
 * @returns {void}
 */
var validateKtyHeader = function validateKtyHeader(_ref) {
  var kty = _ref.kty;

  if (kty !== VALID_KTY) {
    throwError('\'kty\' header must be \'' + VALID_KTY + '\'');
  }
};

var validateKidHeader = function validateKidHeader(_ref2) {
  var kid = _ref2.kid;

  if (!(0, _validUrl.isUri)(kid)) {
    throwError('\'kid\' is not a valid URI');
  }

  if ((0, _url.parse)(kid).protocol !== VALID_KID_PROTOCOL) {
    throwError('\'kid\' protocol must be \'' + VALID_KID_PROTOCOL + '\'');
  }
};

/**
 * Checks the first certificate matches the 'kid' in the JWT.
 * It first checks the Subject Alternative Name then it checks
 * the Common Name
 * @param {Certificate} certificate represents the KMS
 * @param {Object} JWT KMS credentials
 * @param {string} JWT.kid the uri of the KMS
 * @throws {KMSError} if unable to validate certificate against KMS credentials
 * @returns {void}
 */
var validateCommonName = function validateCommonName(_ref3, _ref4) {
  var _ref5 = (0, _slicedToArray3.default)(_ref3, 1),
      certificate = _ref5[0];

  var kid = _ref4.kid;

  var kidHostname = (0, _url.parse)(kid).hostname;
  var validationSuccessful = false;

  if (certificate.extensions) {
    // Subject Alt Names are in here
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(certificate.extensions), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var extension = _step.value;

        if (extension.extnID === X509_SUBJECT_ALT_NAME_KEY) {
          var altNames = extension.parsedValue.altNames;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {

            for (var _iterator2 = (0, _getIterator3.default)(altNames), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var entry = _step2.value;

              var san = entry.value;

              validationSuccessful = san === kidHostname;
              if (validationSuccessful) {
                break;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          if (validationSuccessful) {
            break;
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (!validationSuccessful) {
    // Didn't match kid in the Subject Alt Names, checking the Common Name
    var subjectAttributes = certificate.subject.typesAndValues;

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)(subjectAttributes), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var attribute = _step3.value;

        if (attribute.type === X509_COMMON_NAME_KEY) {
          var commonName = attribute.value.valueBlock.value;

          validationSuccessful = commonName === kidHostname;
          if (validationSuccessful) {
            break;
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  if (!validationSuccessful) {
    throwError('hostname of the 1st certificate does not match \'kid\'');
  }
};

/**
 * Validate the first KMS certificate against the information
 * provided in the JWT
 * @param {Certificate} certificate first certificate the identifies the KMS
 * @param {Object} JWT credentials of the KMS
 * @param {string} JWT.e Public exponent of the first certificate
 * @param {string} KWT.n Modulus of the first certificate
 * @throws {KMSError} if e or n doesn't match the first certificate
 * @returns {void}
 */
var validatePublicCertificate = function validatePublicCertificate(_ref6, _ref7) {
  var _ref8 = (0, _slicedToArray3.default)(_ref6, 1),
      certificate = _ref8[0];

  var publicExponent = _ref7.e,
      modulus = _ref7.n;
  var encode = _nodeJose2.default.util.base64url.encode;


  var publicKey = certificate.subjectPublicKeyInfo.subjectPublicKey;
  var asn1PublicCert = (0, _asn1js.fromBER)(publicKey.valueBlock.valueHex);
  var publicCert = new _pkijs.RSAPublicKey({ schema: asn1PublicCert.result });
  var publicExponentHex = publicCert.publicExponent.valueBlock.valueHex;
  var modulusHex = publicCert.modulus.valueBlock.valueHex;

  if (publicExponent !== encode(publicExponentHex)) {
    throwError('Public exponent is invalid');
  }
  if (modulus !== encode(modulusHex)) {
    throwError('Modulus is invalid');
  }
};

/**
 * Validates the list of certificates against the CAs provided
 * @param {certificate[]} certificates list of certificates provided
 *   by the KMS to certify itself
 * @param {string[]} [caroots=[]] list of Certificate Authorities used to
 *   validate the KMS's certificates
 * @returns {Promise} rejects if unable to validate the certificates
 */
var validateCertificatesSignature = function validateCertificatesSignature(certificates) {
  var caroots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var certificateEngine = new _pkijs.CertificateChainValidationEngine({
    trustedCerts: caroots.map(decodeCert),
    certs: certificates
  });

  return certificateEngine.verify().then(function (_ref9) {
    var result = _ref9.result,
        resultCode = _ref9.resultCode,
        resultMessage = _ref9.resultMessage;

    if (!result) {
      throwError('Certificate Validation failed [' + resultCode + ']: ' + resultMessage);
    }
  });
};

/**
 * Validates the information provided by the KMS. This is a curried function.
 * The first function takes the caroots param and returns a second function.
 * The second function takes the credentials of the KMS and validates it
 * @param {string[]} caroots PEM encoded certificates that will be used
 *   as Certificate Authorities
 * @param {Object} jwt Object containing the fields necessary to
 *   validate the KMS
 * @returns {Promise} when resolved will return the jwt
 */
var validateKMS = function validateKMS(caroots) {
  return function () {
    var jwt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return _promise2.default.resolve().then(function () {
      validateKtyHeader(jwt);
      validateKidHeader(jwt);

      if (!((0, _isArray3.default)(jwt.x5c) && jwt.x5c.length > 0)) {
        throwError('JWK does not contain a list of certificates');
      }
      var certificates = jwt.x5c.map(decodeCert);

      validateCommonName(certificates, jwt);
      validatePublicCertificate(certificates, jwt);

      // Skip validating signatures if no CA roots were provided
      var promise = caroots ? validateCertificatesSignature(certificates, caroots) : _promise2.default.resolve();

      return promise.then(function () {
        return jwt;
      });
    });
  };
};

exports.default = validateKMS;
//# sourceMappingURL=kms-certificate-validation.js.map
